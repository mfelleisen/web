NOMINATION FORM FOR ACM FELLOW 1999 

Submit by September 1, 2000 for 2001 Fellow Consideration 

To: Fellows Committee, ACM, 1515 Broadway, New York, NY 10036, USA 

FAX +1 (212) 869-0824, E-mail: nominate-fellows@acm.org 

Please read the "ACM Guide for Fellow Nominations." Information must 
be typed, machine printed or submitted electronically. It must be 
limited to the space provided or its electronic equivalent. No extra 
sheets will be considered. 

1. NAME OF CANDIDATE:
		  Felleisen, Matthias

Present Occupation 
		  Professor of Computer Science 

Business Address: Department of Computer Science, MS 132
		  Rice University
		  P.O. Box 1892
		  Houston, TX 77251-1892

Country           U.S.A.

Telephone	  (713) 348-4834

Fax		  (713) 285-5930

Email		  matthias@rice.edu

Home Address	  4116 Sunset Blvd
		  Houston, TX 77005
     
Country		  U.S.A.

Telephone	  (713) 664-9993

Email		  matthias@rice.edu

Birth Date (MM/DD /YY)  October 29, 1958

ACM Member No 2089571

2. Summary of Accomplishments: (Citation - 25 words or less)

For contributions to program design methods; to programming language
modeling, design, and analysis; and to the design and implementation of
modern programming environments.

3. EDUCATION: (List highest degree first)
Educational Institution / Location / Degree / Major Discipline / Year

Indiana University     / Bloomington, IN    / PhD   / Computer Science / 1987
Universtiaet Karlsruhe / Karlsruhe, Germany / Dipl. / Wirtschaftsing.  / 1984
University of Arizona  / Tucson, AZ         / MS    / Computer Science / 1981

4. PROFESSIONAL EXPERIENCE: (List current position first.) If necessary, 
cite only most recent positions.

1993 - 2000 Professor, Rice U. 

1993 - 1994 Visiting Professor, CMU

1982 - 1993 Associate Professor, Rice U. 

1987 - 1992 Assistant Professor, Rice U. 

1985 - Research Scientist, MCC 

1981 - 1983 - Programmer, EDS 

5. CANDIDATE'S ACCOMPLISHMENTS: Identify the most important contributions
which qualify the candidate for ACM Fellow according to the following two 
categories:
1) Achievements related to information technology; 
2) Outstanding service to ACM and the computing community. 
(Limit: 2 pages or a block of electronic text no more than 75 characters
 wide and no more than 110 lines long.)

Over the past 40 years, functional programming has emerged as a major arena
 for exploring ideas about program design, programming languages and
 environments. From there, these ideas (slowly) make their way into other
 academic languages and eventually industrial languages. For example,
 automatic memory management has been an integral component of LISP
 implementations from 1958. By the 1970s, it moved into academic
 object-oriented languages. With Java, it has become an essential part of
 the run-time environment of industrial programming languages. Other
 abstract examples include type systems, type soundness, module systems,
 program design patterns and syntax-aware programming environments.  For
 the past 15 years, Felleisen has explored functional programming in this
 manner, focusing on program design, analysis and design of languages, and
 the implementation of advanced programming environments.

Program design and organization: Computer science must develop methods for
 designing programs systematically. Consider two examples. First, we should
 be able to organize software in components such that others can add
 functions or data variants without modifying (editing or recompiling) our
 components.  Existing programming languages make it easy to add either
 functions or data variants but not both. Over the past six years,
 Felleisen has studied this old, open problem. His research provided the
 first abstract characterization of the problem. This work, in turn,
 suggested programming protocols for existing programming languages and
 appropriate extensions to languages. His work inspired the creation of two
 mailing lists on Java extensibility and genericity; his examples have
 become the de facto "benchmarks" for testing proposed solutions.

 Second, a first-year course should teach program design recipes that take
 a student step by step from a problem statement and a blank page to the
 program. If a student is stuck, a teacher should use the recipe to diagnose
 the state of the design. The teacher should then be able to ask a
 canonical question. None of the available design methods support this
 simple idea. Structured design, top-down design, bottom-up design,
 stepwise refinement and object-oriented design all fail in this regard;
 instead, they force students to tinker until they succeed. Starting in
 1984, Felleisen explored this problem and developed design recipes that
 match function organizations to the definition of data classes in the
 problem statement; organize generative recursive functions (fractals,
 quicksort); and so on. Initially, he incorporated these ideas into a
 rewrite of Daniel P. Friedman's "The Little LISPer" (2nd edition), a
 Socratic introduction to programming. Due to reader demand, this book is
 now in its fourth edition. It is by far the oldest (26 years) textbook
 for introductory programming, a major accomplishment in an age when
 publishers press for new language books every three years. In 1998,
 Felleisen also received the George R Brown Award for Innovative Teaching. 

Analysis and design of programming languages: Starting with his
 Ph.D. thesis, Felleisen developed models of programming languages and used
 these models to analyze language capabilities. The first application was a
 theory of expressiveness that distinguishes Turing equivalent languages.
 Many others have explored Felleisen's idea in more depth. The second
 application is a new proof method for the type soundness theorem, which
 guarantees that all well-typed programs terminate properly, with
 well-specified exceptions or diverge. Felleisen's is the first simple
 proof technique that applies in all contexts. It has been widely used with
 functional, imperative, object-oriented, distributed and concurrent
 languages (including subsets of Java). A third application opened an
 entire new active area in logic: the extension of the Howard-Curry
 isomorphism to classical logic. In the early 90s, Felleisen expanded his
 interests in this area to denotational semantics. With Cartwright, he
 produced the first sequential lambda calculus language with a fully
 abstract model, a problem that had been posed informally as early as
 1968. Felleisen has given several invited lectures on these topics at
 conferences and workshops in North America, Europe and Japan (REX,
 Categorical Logic, Lambda Jumelage, TACS).

 Since 1995, Felleisen has turned his attention to solving the
 extensibility problem of software design through language extensions. The
 problem, as described above, is to design software components so that
 others can extend them without access to the source (or at least without
 ability to edit it, a common commercial variant of the problem). With his
 team, he has identified the key linguistic ingredient for such components: 
 - connectors to other components must be external to the component
   (classes often have a fixed superclass, modules a fixed import, etc); 
 - the connections between components must be mutually recursive; 
 - programs must be able to load components dynamically.
 He has illustrated this general idea with typed extensions first for 
 functional and later for object-oriented languages. 

Advanced programming environments: Also in 1995, Felleisen turned his
 attention to programming environment problems. His idea was to use the
 safe semantics of a language to add "smart" tools to environments. To this
 end, he and his team built DrScheme, a programming environment for Scheme.
 This environment contains several smart tools: including a tool for
 dealing with lexical scope; an algebraic stepper, which lifts stepping
 from a syntactic concept (lines) to a semantic one (expression); and a
 static debugger. The static debugger is the most novel and the most
 powerful extension. It uses a powerful analysis to analyze the program for
 potential mistakes. The programmer can then inspect the potential fault
 sites and, if needed, can demand a graphical explanation of the potential
 problem. The static debugger then draws a data-flow image with
 explanations on top of the program. Felleisen has given several invited
 lectures on the environment and the static debugger at universities,
 workshops, and symposia. As of today, the programming environment is used
 at over 160 universities and some 100 high schools for introductory
 programming and courses on AI, languages and software engineering.

Service: Felleisen's service efforts cover three areas. First, he has
 served on numerous ACM program committees; he was a member of the merger
 committee for ICFP; he has served as general chair of ICFP; and he has
 organized three popular workshops on teaching methods and program
 design. Second, at Rice, he created an internationally visible research
 team in programming languages and principles of programming. Before his
 arrival, Rice had three faculty members (for several years) in the area
 but had only produced one student. His arrival activated the PhD
 program. The team (of two faculty now) has produced ten PhD students over
 the past 13 years, eight under his direction. Third, Felleisen has
 organized and taught numerous workshops for high school teachers and small
 college professors on introductory programming. The program has now grown
 into an internationally visible effort.


6. NOMINATOR:

NAME Moshe Vardi

DATE August 10, 2000

ACM MEMBER NO. 2985273

SIGNATURE ______________________________________ 
          (Not required for electronic submissions)

ADDRESS

Department of Computer Science, MS 132
Rice University
P.O. Box 1892
Houston

STATE/PROVINCE  Texas

ZIP/POSTAL CODE 77251-1892

Country USA


TELEPHONE (713) 348-4834

FAX       (713) 285-5930

E-MAIL    matthias@rice.edu


7. LIST ENDORSERS YOU WILL CONTACT.

Minimum of five ACM Members required.

Please provide no more than eight to allow for lack of response or for
persons who feel unqualified to judge candidate.

1.__________________________________

2.__________________________________

3.__________________________________

4.__________________________________

5.__________________________________

6.__________________________________

7.__________________________________

8.__________________________________



<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lectures</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="autobib.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">History of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="themes.html" class="tocviewlink" data-pltdoc="x">Themes</a></td></tr><tr><td align="right"></td><td><a href="form.html" class="tocviewlink" data-pltdoc="x">Assessment</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="#%28part._1%29" class="tocviewlink" data-pltdoc="x">Welcome</a></td></tr><tr><td align="right"></td><td><a href="#%28part._2%29" class="tocviewlink" data-pltdoc="x">Classical Denotational Semantics</a></td></tr><tr><td align="right"></td><td><a href="#%28part._3%29" class="tocviewlink" data-pltdoc="x">Classical Operational Semantics</a></td></tr><tr><td align="right"></td><td><a href="#%28part._4%29" class="tocviewlink" data-pltdoc="x">Defining Macros</a></td></tr><tr><td align="right"></td><td><a href="#%28part._5%29" class="tocviewlink" data-pltdoc="x">Hygienic Macros</a></td></tr><tr><td align="right"></td><td><a href="#%28part._6%29" class="tocviewlink" data-pltdoc="x">Higher-<wbr></wbr>Order Contracts </a></td></tr><tr><td align="right"></td><td><a href="#%28part._7%29" class="tocviewlink" data-pltdoc="x">The Operational Semantics of Gradual Typing</a></td></tr><tr><td align="right"></td><td><a href="#%28part._8%29" class="tocviewlink" data-pltdoc="x">Automatic Differentiation</a></td></tr><tr><td align="right"></td><td><a href="#%28part._9%29" class="tocviewlink" data-pltdoc="x">Meetings </a></td></tr><tr><td align="right"></td><td><a href="#%28part._10%29" class="tocviewlink" data-pltdoc="x">Hindley-<wbr></wbr>Milner Type Inference</a></td></tr><tr><td align="right"></td><td><a href="#%28part._11%29" class="tocviewlink" data-pltdoc="x">System F Type Systems:<span class="mywbr"> &nbsp;</span> From Theory to Practice </a></td></tr><tr><td align="right"></td><td><a href="#%28part._12%29" class="tocviewlink" data-pltdoc="x">Ideas:<span class="mywbr"> &nbsp;</span> From Conception to Programming <span class="strike" style="text-decoration:line-through">PER Semantics of Types</span> </a></td></tr><tr><td align="right"></td><td><a href="#%28part._13%29" class="tocviewlink" data-pltdoc="x">The PI Calculus</a></td></tr><tr><td align="right"></td><td><a href="#%28part._14%29" class="tocviewlink" data-pltdoc="x">Session Types</a></td></tr><tr><td align="right"></td><td><a href="#%28part._15%29" class="tocviewlink" data-pltdoc="x">Functional Reactive Programming</a></td></tr><tr><td align="right"></td><td><a href="#%28part._16%29" class="tocviewlink" data-pltdoc="x">Tracing JIT Compilation</a></td></tr><tr><td align="right"></td><td><a href="#%28part._17%29" class="tocviewlink" data-pltdoc="x">Meetings</a></td></tr><tr><td align="right"></td><td><a href="#%28part._18%29" class="tocviewlink" data-pltdoc="x">Programming Languages and Operating Systems</a></td></tr><tr><td align="right"></td><td><a href="#%28part._19%29" class="tocviewlink" data-pltdoc="x">Array Programming Languages</a></td></tr><tr><td align="right"></td><td><a href="#%28part._20%29" class="tocviewlink" data-pltdoc="x">Relational Programming</a></td></tr><tr><td align="right"></td><td><a href="#%28part._21%29" class="tocviewlink" data-pltdoc="x">How (Not) to Benchmark</a></td></tr><tr><td align="right"></td><td><a href="#%28part._22%29" class="tocviewlink" data-pltdoc="x">Logical Relations</a></td></tr><tr><td align="right"></td><td><a href="#%28part._23%29" class="tocviewlink" data-pltdoc="x">Designing Multi-<wbr></wbr>Language Systems</a></td></tr><tr><td align="right"></td><td><a href="#%28part._24%29" class="tocviewlink" data-pltdoc="x">Intermediate Compiler Forms for Functional Languages </a></td></tr><tr><td align="right"></td><td><a href="#%28part._26%29" class="tocviewlink" data-pltdoc="x">The ML Module System <span class="strike" style="text-decoration:line-through">Refinement Types</span></a></td></tr><tr><td align="right"></td><td><a href="#%28part._27%29" class="tocviewlink" data-pltdoc="x">The Evolution of Dependent Types</a></td></tr><tr><td align="right"></td><td><a href="#%28part._28%29" class="tocviewlink" data-pltdoc="x">The Implementation of Depdenent-<wbr></wbr>Type Proof Assistants</a></td></tr><tr><td align="right"></td><td><a href="#%28part._29%29" class="tocviewlink" data-pltdoc="x">Image-<wbr></wbr>Based Programming Systems</a></td></tr><tr><td align="right"></td><td><a href="#%28part._30%29" class="tocviewlink" data-pltdoc="x">Visual Teaching Languages</a></td></tr><tr><td align="right"></td><td><a href="#%28part._doc-bibliography%29" class="tocviewlink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._1%29" class="tocsubseclink" data-pltdoc="x">Welcome</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._2%29" class="tocsubseclink" data-pltdoc="x">Classical Denotational Semantics</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._3%29" class="tocsubseclink" data-pltdoc="x">Classical Operational Semantics</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._4%29" class="tocsubseclink" data-pltdoc="x">Defining Macros</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._5%29" class="tocsubseclink" data-pltdoc="x">Hygienic Macros</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._6%29" class="tocsubseclink" data-pltdoc="x">Higher-<wbr></wbr>Order Contracts </a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._7%29" class="tocsubseclink" data-pltdoc="x">The Operational Semantics of Gradual Typing</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._8%29" class="tocsubseclink" data-pltdoc="x">Automatic Differentiation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._9%29" class="tocsubseclink" data-pltdoc="x">Meetings </a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._10%29" class="tocsubseclink" data-pltdoc="x">Hindley-<wbr></wbr>Milner Type Inference</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._11%29" class="tocsubseclink" data-pltdoc="x">System F Type Systems:<span class="mywbr"> &nbsp;</span> From Theory to Practice </a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._12%29" class="tocsubseclink" data-pltdoc="x">Ideas:<span class="mywbr"> &nbsp;</span> From Conception to Programming <span class="strike" style="text-decoration:line-through">PER Semantics of Types</span> </a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._13%29" class="tocsubseclink" data-pltdoc="x">The PI Calculus</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._14%29" class="tocsubseclink" data-pltdoc="x">Session Types</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._15%29" class="tocsubseclink" data-pltdoc="x">Functional Reactive Programming</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._16%29" class="tocsubseclink" data-pltdoc="x">Tracing JIT Compilation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._17%29" class="tocsubseclink" data-pltdoc="x">Meetings</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._18%29" class="tocsubseclink" data-pltdoc="x">Programming Languages and Operating Systems</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._19%29" class="tocsubseclink" data-pltdoc="x">Array Programming Languages</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._20%29" class="tocsubseclink" data-pltdoc="x">Relational Programming</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._21%29" class="tocsubseclink" data-pltdoc="x">How (Not) to Benchmark</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._22%29" class="tocsubseclink" data-pltdoc="x">Logical Relations</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._23%29" class="tocsubseclink" data-pltdoc="x">Designing Multi-<wbr></wbr>Language Systems</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._24%29" class="tocsubseclink" data-pltdoc="x">Intermediate Compiler Forms for Functional Languages </a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._26%29" class="tocsubseclink" data-pltdoc="x">The ML Module System <span class="strike" style="text-decoration:line-through">Refinement Types</span></a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._27%29" class="tocsubseclink" data-pltdoc="x">The Evolution of Dependent Types</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._28%29" class="tocsubseclink" data-pltdoc="x">The Implementation of Depdenent-<wbr></wbr>Type Proof Assistants</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._29%29" class="tocsubseclink" data-pltdoc="x">Image-<wbr></wbr>Based Programming Systems</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._30%29" class="tocsubseclink" data-pltdoc="x">Visual Teaching Languages</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._doc-bibliography%29" class="tocsubseclink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.0.0.12</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="form.html" title="backward to &quot;Assessment&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;History of Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3><a name="(part._lectures)"></a>Lectures</h3><a name="(part._chap~3alectures)"></a><p>This page simulatenously serves as a repository for lecture abstracts
and a presentation schedule. It will stay as a permanent record of
this instance of HoPL.</p><h3><a name="(part._1)"></a>Welcome</h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="1.pdf">19 Jan 2021</a></p></blockquote></blockquote></blockquote><p>I will give a brief presentation on the dawn of programming language
history and how researchers began to tease out essential
concepts&#8212;<wbr></wbr>syntax, scope, types, semantics, pragmatics&#8212;<wbr></wbr>and the first
ideas that showed up within these categories.</p><p>We will also discuss why/how the lambda calculus quickly appeared as the
central idea to study these concepts, culminating in the thoroughly
under-appreciated dissertation of <span class="Autobibref"><a href="#%28autobib._.James._.Hiram._.Morris.Lambda-.Calculus._.Models._of._.Programming._.Languages.Ph...D..._dissertation%2C._.Massachusetts._.Institute._of._.Technology1968%29" class="AutobibLink" data-pltdoc="x">Morris</a>&nbsp;[<a href="#%28autobib._.James._.Hiram._.Morris.Lambda-.Calculus._.Models._of._.Programming._.Languages.Ph...D..._dissertation%2C._.Massachusetts._.Institute._of._.Technology1968%29" class="AutobibLink" data-pltdoc="x">1968</a>]</span>.</p><p>At the end, I will explain how this course works, its focus, and its
organization.</p><h3><a name="(part._2)"></a>Classical Denotational Semantics</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Matthias Felleisen</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="2.pdf">22 Jan 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>As the <a href="#%28part._1%29" data-pltdoc="x">Welcome</a> explained and as you may recall from your undergraduate
course on PPL, formulating a semantics for a programming language emerged
as the first hard problem. People imagined that, like syntax, semantics
could be specified at a rather high level and, like parsers, code
generators could be generated from a semantics.</p><p>Scott&rsquo;s denotational semantics<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Joe._.Stoy.Denotational._.Semantics~3a._.The._.Scott-.Strachey._.Approach._to._.Programming._.Language._.Theory.M.I.T._.Press1977https~3a%2F%2Fdl..acm..org%2Fdoi%2Fbook%2F10..5555%2F540155%29" class="AutobibLink" data-pltdoc="x">Stoy</a> <a href="#%28autobib._.Joe._.Stoy.Denotational._.Semantics~3a._.The._.Scott-.Strachey._.Approach._to._.Programming._.Language._.Theory.M.I.T._.Press1977https~3a%2F%2Fdl..acm..org%2Fdoi%2Fbook%2F10..5555%2F540155%29" class="AutobibLink" data-pltdoc="x">1977</a>]</span> of the (typed and untyped)
lambda calculus emerged as the first dominant approach. Because
denotational semantics seems to leverage ordinary mathematical ideas
(algebra, geometry, topology, etc.), researchers hoped that tools from
these areas could be used to analyze program behavior and that these
analyses could then play a role in code generation and optimization.
Sadly, this research direction ran into a rather unsolvable problems,
often now called the &ldquo;full abstraction&rdquo; problem<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Robin._.Milner.Fully._abstract._models._of._typed._~ce~bb-calculi.Theoretical._.Computer._.Science._4%281%29%2C._pp..._1--221977https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0304397577900536%29" class="AutobibLink" data-pltdoc="x">Milner</a> <a href="#%28autobib._.Robin._.Milner.Fully._abstract._models._of._typed._~ce~bb-calculi.Theoretical._.Computer._.Science._4%281%29%2C._pp..._1--221977https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0304397577900536%29" class="AutobibLink" data-pltdoc="x">1977</a>; <a href="#%28autobib._.Godon._.D..._.Plotkin.L.C.F._considered._as._a._programming._language.Theoretical._.Computer._.Science._3%285%29%2C._pp..._223--2551977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2F.L.C.F..pdf%29" class="AutobibLink" data-pltdoc="x">Plotkin</a> <a href="#%28autobib._.Godon._.D..._.Plotkin.L.C.F._considered._as._a._programming._language.Theoretical._.Computer._.Science._3%285%29%2C._pp..._223--2551977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2F.L.C.F..pdf%29" class="AutobibLink" data-pltdoc="x">1977<span class="AutobibLink">b</span></a>]</span>.</p><p>While (classical) denotational semantics has disappeared (in the US),
modern operational semantics directly draws on its ideas and will
continue to do so in the future.</p><h3><a name="(part._3)"></a>Classical Operational Semantics</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Matthias Felleisen</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="3.pdf">26 Jan 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>The very first efforts in operational semantics focused on two different directions:
interpreters<span class="Autobibref">&nbsp;[<a href="#%28autobib._.John._.Mc.Carthy.Recursive._functions._of._symbolic._expressions._and._their._computation._by._machine%2C._.Part._.I.Communications._of._the._.A.C.M._4%283%29%2C._pp..._182--2001960https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F367177..367199%29" class="AutobibLink" data-pltdoc="x">McCarthy</a> <a href="#%28autobib._.John._.Mc.Carthy.Recursive._functions._of._symbolic._expressions._and._their._computation._by._machine%2C._.Part._.I.Communications._of._the._.A.C.M._4%283%29%2C._pp..._182--2001960https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F367177..367199%29" class="AutobibLink" data-pltdoc="x">1960</a>]</span> and abstract machines<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Peter._.J..._.Landin.The._mechanical._evaluation._of._expressions.The._.Computer._.Journal._6%284%29%2C._pp..._308--3201964https~3a%2F%2Facademic..oup..com%2Fcomjnl%2Farticle%2F6%2F4%2F308%2F375725%29" class="AutobibLink" data-pltdoc="x">Landin</a> <a href="#%28autobib._.Peter._.J..._.Landin.The._mechanical._evaluation._of._expressions.The._.Computer._.Journal._6%284%29%2C._pp..._308--3201964https~3a%2F%2Facademic..oup..com%2Fcomjnl%2Farticle%2F6%2F4%2F308%2F375725%29" class="AutobibLink" data-pltdoc="x">1964</a>]</span>.</p><p>Compared to denotational semantics, people recognized early on that both
approaches to operational semantics feel <span style="font-style: italic">ad hoc</span> and seem to make
it difficult to study the meaning of programs
systematically. <span class="Autobibref"><a href="#%28autobib._.John._.C..._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference%2C._pp..._717--7401972https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F800194..805852%29" class="AutobibLink" data-pltdoc="x">Reynolds</a>&nbsp;[<a href="#%28autobib._.John._.C..._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference%2C._pp..._717--7401972https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F800194..805852%29" class="AutobibLink" data-pltdoc="x">1972</a>]</span>&rsquo;s devastating critique of
operational semantics&#8212;<wbr></wbr>he uses the phrase meta-interpreter, but it
equally applies to related works too&#8212;<wbr></wbr>looked like a death sentence.</p><p>In parallel, though, <span class="Autobibref"><a href="#%28autobib._.Godon._.D..._.Plotkin.Call-by-name%2C._call-by-value%2C._and._the._lambda._calculus.Theoretical._.Computer._.Science._1n%2C._pp..._125--1591977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2Fcbn_cbv_lambda..pdf%29" class="AutobibLink" data-pltdoc="x">Plotkin</a>&nbsp;[<a href="#%28autobib._.Godon._.D..._.Plotkin.Call-by-name%2C._call-by-value%2C._and._the._lambda._calculus.Theoretical._.Computer._.Science._1n%2C._pp..._125--1591977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2Fcbn_cbv_lambda..pdf%29" class="AutobibLink" data-pltdoc="x">1977<span class="AutobibLink">a</span></a>; <a href="#%28autobib._.Godon._.D..._.Plotkin.A._structural._approach._to._operational._semantics.University._of._.Aarhus%2C._.D.A.I.M.I._.F.N-191981https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2F.S.O.S..ps%29" class="AutobibLink" data-pltdoc="x">1981</a>]</span> developed two more
frameworks for operational semantics, both of which play a significant
role nowadays: lambda calculus as a semantics and so-called structural
operational semantics.  <span class="Autobibref"><a href="#%28autobib._.Dominique._.Clement%2C._.Joelle._.Despeyroux%2C._.Thierry._.Despeyroux%2C._.Laurent._.Hascoet%2C._and._.Gilles._.Kahn.Natural._semantics._on._the._computer.I.N.R.I.A._.Sophia-.Antipolis%2C._.R.R-0416._000761401985https~3a%2F%2Fhal..inria..fr%2Finria-00076140%2Fdocument%29" class="AutobibLink" data-pltdoc="x">Clement et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Dominique._.Clement%2C._.Joelle._.Despeyroux%2C._.Thierry._.Despeyroux%2C._.Laurent._.Hascoet%2C._and._.Gilles._.Kahn.Natural._semantics._on._the._computer.I.N.R.I.A._.Sophia-.Antipolis%2C._.R.R-0416._000761401985https~3a%2F%2Fhal..inria..fr%2Finria-00076140%2Fdocument%29" class="AutobibLink" data-pltdoc="x">1985</a>]</span>&rsquo;s development of the closely
related natural semantics demonstrated that this idea could be useful for
compiler-generation frameworks.</p><p><span style="font-weight: bold">Note</span> These ideas are often covered to varying degrees in iPPL
(7400). This presentation is from my perspective, recalling my own
days as a second-year PhD student.</p><h3><a name="(part._4)"></a>Defining Macros</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Jared Gentner</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="4.pdf">29 Jan 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Some language families do <span class="emph">not</span> respect the idea of fixed syntax, scope,
semantics, and so on. The Lisp family is one of them.</p><p>From almost the very beginning, Lisp languages offer programmers mechanisms
for changing almost every aspect of the language. The key mechanism is a
macro&#8212;<wbr></wbr>a function from (concrete) syntax tree to syntax tree&#8212;<wbr></wbr>which a
programmer can add to the front end of the compiler. Programmers can use those
to eliminate syntactic pattern and even finely integrated build
domain-specific languages.</p><p><div class="SIntrapara">The challenge is to write these syntax-to-syntax functions effectively.
Beginning in the 1980s, researchers paid attention to this problem and took
four significant steps:
</div><div class="SIntrapara"><ul><li><p><span class="Autobibref"><a href="#%28autobib._.Eugene._.E..._.Kohlbecker._and._.Mitch._.Wand.Macros._by._example.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._77--841987https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F41625..41632%29" class="AutobibLink" data-pltdoc="x">Kohlbecker and Wand</a>&nbsp;[<a href="#%28autobib._.Eugene._.E..._.Kohlbecker._and._.Mitch._.Wand.Macros._by._example.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._77--841987https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F41625..41632%29" class="AutobibLink" data-pltdoc="x">1987</a>]</span> recognized that normal macro definitions exhibit repeated
patterns that macros could eliminate;</p></li><li><p>the Scheme community <span class="Autobibref">&nbsp;[<a href="#%28autobib._.William._.D..._.Clinger%2C._.Jonathan._.A..._.Rees%2C._.H..._.Abelson%2C._.R._.Kent._.Dybvig%2C._.Christopher._.Thomas._.Haynes%2C._.Guillermo._.Juan._.Rozas%2C._.Norman._.I..._.Adams%2C._.Daniel._.Paul._.Friedman%2C._.Eugene._.E..._.Kohlbecker%2C._.Guy._.L..._.Steele._.Jr..%2C._.David._.H._.Bartley%2C._.Robert._.H._.Halstead%2C._.D..._.Oxley%2C._.Gerald._.Jay._.Sussman%2C._.G..._.Brooks%2C._.Chris._.Hanson%2C._.Kent._.M..._.Pitman%2C._and._.Mitch._.Wand.The._revised4._report._on._.S.C.H.E.M.E~3a._a._dialect._of._.L.I.S.P.A.C.M._.S.I.G.P.L.A.N._.Lisp._.Pointers._.I.V%283%29%2C._pp..._1--551991https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F382130..382133%29" class="AutobibLink" data-pltdoc="x">Clinger et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.William._.D..._.Clinger%2C._.Jonathan._.A..._.Rees%2C._.H..._.Abelson%2C._.R._.Kent._.Dybvig%2C._.Christopher._.Thomas._.Haynes%2C._.Guillermo._.Juan._.Rozas%2C._.Norman._.I..._.Adams%2C._.Daniel._.Paul._.Friedman%2C._.Eugene._.E..._.Kohlbecker%2C._.Guy._.L..._.Steele._.Jr..%2C._.David._.H._.Bartley%2C._.Robert._.H._.Halstead%2C._.D..._.Oxley%2C._.Gerald._.Jay._.Sussman%2C._.G..._.Brooks%2C._.Chris._.Hanson%2C._.Kent._.M..._.Pitman%2C._and._.Mitch._.Wand.The._revised4._report._on._.S.C.H.E.M.E~3a._a._dialect._of._.L.I.S.P.A.C.M._.S.I.G.P.L.A.N._.Lisp._.Pointers._.I.V%283%29%2C._pp..._1--551991https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F382130..382133%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> standardized this mechanism as
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-rules%29%29" class="RktStxLink" data-pltdoc="x">syntax-rules</a></span> but also restricted it severely;</p></li><li><p>so that <span class="Autobibref"><a href="#%28autobib._.Kent._.R..._.Dybvig.Writing._hygienic._macros._in._.Scheme._with._syntax-case.Indiana._.University%2C._.Department._of._.Computer._.Science%2C._.T.R3561992https~3a%2F%2Fhelp..luddy..indiana..edu%2Ftechreports%2F.T.R.N.N.N..cgi~3ftrnum~3d.T.R356%29" class="AutobibLink" data-pltdoc="x">Dybvig</a>&nbsp;[<a href="#%28autobib._.Kent._.R..._.Dybvig.Writing._hygienic._macros._in._.Scheme._with._syntax-case.Indiana._.University%2C._.Department._of._.Computer._.Science%2C._.T.R3561992https~3a%2F%2Fhelp..luddy..indiana..edu%2Ftechreports%2F.T.R.N.N.N..cgi~3ftrnum~3d.T.R356%29" class="AutobibLink" data-pltdoc="x">1992</a>]</span>&rsquo;s <span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax-case%29%29" class="RktStxLink" data-pltdoc="x">syntax-case</a></span>, which allows
programmers to mix declarative and procedural idioms, soon became the actual
dominant definition tool in this world;</p></li><li><p>until <span class="Autobibref"><a href="#%28autobib._.Ryan._.Culpepper._and._.Matthias._.Felleisen.Fortifying._macros.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._235--2462010https~3a%2F%2Fwww2..ccs..neu..edu%2Fracket%2Fpubs%2F~23c-jfp12%29" class="AutobibLink" data-pltdoc="x">Culpepper and Felleisen</a>&nbsp;[<a href="#%28autobib._.Ryan._.Culpepper._and._.Matthias._.Felleisen.Fortifying._macros.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._235--2462010https~3a%2F%2Fwww2..ccs..neu..edu%2Fracket%2Fpubs%2F~23c-jfp12%29" class="AutobibLink" data-pltdoc="x">2010</a>]</span> improved on it with <span class="RktSym"><a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29" class="RktStxLink" data-pltdoc="x">syntax-parse</a></span>.</p></li></ul></div></p><h3><a name="(part._5)"></a>Hygienic Macros</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Michael Ballantyne</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="http://mballantyne.net/hopl-hygiene.pdf">2 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Parallel to the development of macro-definition systems, researchers also
worked on understanding how syntax-to-syntax functions &ldquo;mess&rdquo; with the
lexical scope of a program. Concretely, using macro may inadvertently
capture identifiers in a way that violates a natural understanding of the
surface syntax and its binding rules. The resulting bugs are rather
insidious.</p><p><span class="Autobibref"><a href="#%28autobib._.Eugene._.E..._.Kohlbecker%2C._.Daniel._.P..._.Friedman%2C._.Matthias._.Felleisen%2C._and._.Bruce._.D..._.Duba.Hygienic._macro._expansion.In._.Proc..._.L.I.S.P._and._.Functional._.Programming%2C._pp..._151--1611986https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F319838..319859%29" class="AutobibLink" data-pltdoc="x">Kohlbecker et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Eugene._.E..._.Kohlbecker%2C._.Daniel._.P..._.Friedman%2C._.Matthias._.Felleisen%2C._and._.Bruce._.D..._.Duba.Hygienic._macro._expansion.In._.Proc..._.L.I.S.P._and._.Functional._.Programming%2C._pp..._151--1611986https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F319838..319859%29" class="AutobibLink" data-pltdoc="x">1986</a>]</span> pointed out the problem and offered a first, simplistic
solution, drawing on Barendregt&rsquo;s tradition of treating the lambda
calculus as a system of terms &ldquo;moded out&rdquo; under alpha equivalence (&ldquo;the
hygiene condition&rdquo;). In this context, alpha renaming&#8212;<wbr></wbr>known to
&ldquo;younglings&rdquo; as identifier-rename refactoring&#8212;<wbr></wbr>means picking a
different concrete representative for the same equivalence
class. Kohlbecker et al. describe an algorithm that properly preserves the
apparent scope uniformly for all programs: the hygienic macro expansion
algorithm.</p><p>Following this tradition, <span class="Autobibref"><a href="#%28autobib._.Kent._.R..._.Dybvig%2C._.Robert._.Hieb%2C._and._.Carl._.Bruggeman.Syntactic._abstraction._in._.Scheme.L.I.S.P._and._.Symbolic._.Computation._5%2C._pp..._295--3261993https~3a%2F%2Flink..springer..com%2Farticle%2F10..1007%2F.B.F01806308%29" class="AutobibLink" data-pltdoc="x">Dybvig et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Kent._.R..._.Dybvig%2C._.Robert._.Hieb%2C._and._.Carl._.Bruggeman.Syntactic._abstraction._in._.Scheme.L.I.S.P._and._.Symbolic._.Computation._5%2C._pp..._295--3261993https~3a%2F%2Flink..springer..com%2Farticle%2F10..1007%2F.B.F01806308%29" class="AutobibLink" data-pltdoc="x">1993</a>]</span> generalizes this expansion
algorithm and improves its performance in significant ways. Their
algorithm was the gold standard for nearly three decades.</p><p>In 2016, <span class="Autobibref"><a href="#%28autobib._.Matthew._.Flatt.Bindings._as._sets._of._scopes.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._705--7172016https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2837614..2837620%29" class="AutobibLink" data-pltdoc="x">Flatt</a>&nbsp;[<a href="#%28autobib._.Matthew._.Flatt.Bindings._as._sets._of._scopes.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._705--7172016https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2837614..2837620%29" class="AutobibLink" data-pltdoc="x">2016</a>]</span> presented an entirely different algorithm,
which he implemented for Racket. The algorithm was quickly used to
implement macros for JavaScript.</p><h3><a name="(part._6)"></a>Higher-Order Contracts </h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Cameron Moy </p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="6.pdf">5 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>In the late 1960s, software engineering researchers coined the phrase
&ldquo;software crisis.&rdquo; With computational power accelerating at an
exponential rate, everyone expected programmers&rsquo; ability to deliver
complex software to improve substantially, but alas it didn&rsquo;t.
So researchers began to ponder how to deal with this problem.</p><p><span class="Autobibref"><a href="#%28autobib._.M..._.D..._.Mc.Ilroy.Mass._.Produced._.Software._.Components.In._.Proc..._.N.A.T.O._.Software._.Engineering._.Conference..._.N.A.T.O._.Scientific._.Affairs._.Division%2C._pp..._79--871968https~3a%2F%2Fwww..scrummanager..net%2Ffiles%2Fnato1968e..pdf%29" class="AutobibLink" data-pltdoc="x">McIlroy</a>&nbsp;[<a href="#%28autobib._.M..._.D..._.Mc.Ilroy.Mass._.Produced._.Software._.Components.In._.Proc..._.N.A.T.O._.Software._.Engineering._.Conference..._.N.A.T.O._.Scientific._.Affairs._.Division%2C._pp..._79--871968https~3a%2F%2Fwww..scrummanager..net%2Ffiles%2Fnato1968e..pdf%29" class="AutobibLink" data-pltdoc="x">1968</a>]</span> is the first to propose a component marketplace
that could supply high-quality, generic&#8212;<wbr></wbr>as in interchangeable&#8212;<wbr></wbr> and
configurable modules, for use in many different
systems. <span class="Autobibref"><a href="#%28autobib._.D..._.L..._.Parnas.A._.Technique._for._.Software._.Module._.Specification._with._.Examples.Communications._of._the._.A.C.M._15%285%29%2C._pp..._330--3361972https~3a%2F%2Fdoi..org%2F10..1145%2F355602..361309%29" class="AutobibLink" data-pltdoc="x">Parnas</a>&nbsp;[<a href="#%28autobib._.D..._.L..._.Parnas.A._.Technique._for._.Software._.Module._.Specification._with._.Examples.Communications._of._the._.A.C.M._15%285%29%2C._pp..._330--3361972https~3a%2F%2Fdoi..org%2F10..1145%2F355602..361309%29" class="AutobibLink" data-pltdoc="x">1972</a>]</span> recognizes that, to be practical,
such components would need to be accompanied by a formal interface
specification.</p><p>The Eiffel programming language represents the first large-scale
attempt to realize these aspirations. <span class="Autobibref"><a href="#%28autobib._.Bernard._.Meyer.Eiffel~3a._.The._.Language.Prentice._.Hall1992%29" class="AutobibLink" data-pltdoc="x">Meyer</a>&nbsp;[<a href="#%28autobib._.Bernard._.Meyer.Eiffel~3a._.The._.Language.Prentice._.Hall1992%29" class="AutobibLink" data-pltdoc="x">1992<span class="AutobibLink">b</span></a>]</span>&rsquo;s contract
<span class="refelem"><span class="refcolumn"><span class="refcontent">From a software engineering perspective, this system
encourages programmers to replace defensive
programming&#8212;<wbr></wbr>over-burdening method definitions with extensive
checks&#8212;<wbr></wbr>with concise interface contracts, which is where such checks
belong for the client programmer.</span></span></span>  system for Eiffel allows
programmers to express pre-conditions that a caller must satisfy in a
method signature and post-conditions that the result is guaranteed to
satisfy. If a method&rsquo;s pre-condition fails, it is the caller&rsquo;s fault;
if the post-condition fails, the contract system points to the callee
as the potential source of error.  In fact, in
<span class="Autobibref"><a href="#%28autobib._.Bernard._.Meyer.Applying._.Design._by._.Contract.I.E.E.E._.Computer._25%2810%29%2C._pp..._45--511992%29" class="AutobibLink" data-pltdoc="x">Meyer</a>&nbsp;[<a href="#%28autobib._.Bernard._.Meyer.Applying._.Design._by._.Contract.I.E.E.E._.Computer._25%2810%29%2C._pp..._45--511992%29" class="AutobibLink" data-pltdoc="x">1992<span class="AutobibLink">a</span></a>]</span>&rsquo;s eyes, the contract system is
the underpinning of his entire software design philosophy: &ldquo;design by
contract.&rdquo;</p><p>Some ten years later <span class="Autobibref"><a href="#%28autobib._.Robert._.Bruce._.Findler._and._.Matthias._.Felleisen.Contract._.Soundness._for._.Object-.Oriented._.Languages.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._1--152001https~3a%2F%2Fdoi..org%2F10..1145%2F504282..504283%29" class="AutobibLink" data-pltdoc="x">Findler and Felleisen</a>&nbsp;[<a href="#%28autobib._.Robert._.Bruce._.Findler._and._.Matthias._.Felleisen.Contract._.Soundness._for._.Object-.Oriented._.Languages.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._1--152001https~3a%2F%2Fdoi..org%2F10..1145%2F504282..504283%29" class="AutobibLink" data-pltdoc="x">2001</a>]</span> point out that contracts
in Eiffel violate the Liskov substitution principle and, as a result,
occasionally point to the wrong component as the faulty one.  To
rectify this flaw, they propose a &ldquo;monitoring&rdquo; approach that goes
beyond checking just the pre and post condition.</p><p>By this time, programming languages also begin to include higher-order
elements, such as Scheme&rsquo;s lambda or Python&rsquo;s functions on classes.
Correctly handling these now-common programming language features with
the simplistic contract system of Eiffel, however, proves
impossible. In response, <span class="Autobibref"><a href="#%28autobib._.Robert._.B..._.Findler._and._.Matthias._.Felleisen.Contracts._for._.Higher-.Order._.Functions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._48--592002%29" class="AutobibLink" data-pltdoc="x">Findler and Felleisen</a>&nbsp;[<a href="#%28autobib._.Robert._.B..._.Findler._and._.Matthias._.Felleisen.Contracts._for._.Higher-.Order._.Functions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._48--592002%29" class="AutobibLink" data-pltdoc="x">2002</a>]</span> extend the contract
system to higher-order functions and develop a &ldquo;blame assignment&rdquo;
system, setting off a flurry of research into the subject.</p><p>Subsequent work turns to many aspects and applications of higher-order
contracts: semantics (what does it mean for a component to satisfy its
contracts, what is &ldquo;blame&rdquo;), pragmatics (does blame assignment help
programmers), implementation technology (how can contracts effectively
and efficiently protect mutable objects), and more..<span class="refelem"><span class="refcolumn"><span class="refcontent">The
idea also finds its way into gradual typing via the system&rsquo;s re-use in
the construction of Typed Scheme.</span></span></span> The most notable development
investigated the correctness and completeness of blame
assignment&#8212;resulting in the complete monitoring property. It demands
that a contract system assigns blame correctly and monitors all
channels of communication between
modules<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Christos._.Dimoulas%2C._.Sam._.Tobin-.Hochstadt%2C._and._.Matthias._.Felleisen.Complete._.Monitors._for._.Behavioral._.Contracts.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._214--2332012%29" class="AutobibLink" data-pltdoc="x">Dimoulas et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Christos._.Dimoulas%2C._.Sam._.Tobin-.Hochstadt%2C._and._.Matthias._.Felleisen.Complete._.Monitors._for._.Behavioral._.Contracts.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._214--2332012%29" class="AutobibLink" data-pltdoc="x">2012</a>]</span>.</p><h3><a name="(part._7)"></a>The Operational Semantics of Gradual Typing</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Olek Gierczak</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="7.pdf">9 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Gradual Typing seeks to combine static with dynamic typing, while
maintaining as many benefits as possible, such as the program analysis
benefits from static and legacy code support from dynamic. The
prehistory of Gradual Typing is work surrounding interoperability
between statically and dynamically typed languages, with one notable
example being interoperability between Java and Scheme
<span class="Autobibref"><a href="#%28autobib._.Kathryn._.E..._.Gray%2C._.Robert._.B..._.Findler%2C._and._.Matthew._.Flatt.Fine-.Grained._.Interoperability._through._.Contracts._and._.Mirrors.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._231--2452005%29" class="AutobibLink" data-pltdoc="x">Gray et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Kathryn._.E..._.Gray%2C._.Robert._.B..._.Findler%2C._and._.Matthew._.Flatt.Fine-.Grained._.Interoperability._through._.Contracts._and._.Mirrors.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._231--2452005%29" class="AutobibLink" data-pltdoc="x">2005</a>]</span>.  Similar to the emphasis on how
values flow between language boundaries in interoperability, Research
on gradually typed systems emphasizes how a value is checked at the
boundary between the statically and the dynamically typed
portion.</p><p>The original core formalizations of Gradually Typed systems introduce
the Natural semantics for checking values at boundaries
<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Jeremy._.G..._.Siek._and._.Walid._.Taha.Gradual._.Typing._for._.Functional._.Languages.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming%2C._pp..._81--922006%29" class="AutobibLink" data-pltdoc="x">Siek and Taha</a> <a href="#%28autobib._.Jeremy._.G..._.Siek._and._.Walid._.Taha.Gradual._.Typing._for._.Functional._.Languages.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming%2C._pp..._81--922006%29" class="AutobibLink" data-pltdoc="x">2006</a>; <a href="#%28autobib._.Sam._.Tobin-.Hochstadt._and._.Matthias._.Felleisen.Interlanguage._.Migration~3a._from._.Scripts._to._.Programs.In._.Proc..._.Dynamic._.Languages._.Symposium%2C._pp..._964--9742006%29" class="AutobibLink" data-pltdoc="x">Tobin-Hochstadt and Felleisen</a> <a href="#%28autobib._.Sam._.Tobin-.Hochstadt._and._.Matthias._.Felleisen.Interlanguage._.Migration~3a._from._.Scripts._to._.Programs.In._.Proc..._.Dynamic._.Languages._.Symposium%2C._pp..._964--9742006%29" class="AutobibLink" data-pltdoc="x">2006</a>]</span>. Alternatives are due to
<span class="Autobibref"><a href="#%28autobib._.Michael._.M..._.Vitousek%2C._.Andrew._.Kent%2C._.Jeremy._.G..._.Siek%2C._and._.Jim._.Baker.Design._and._.Evaluation._of._.Gradual._.Typing._for._.Python.In._.Proc..._.Dynamic._.Languages._.Symposium%2C._pp..._45--562014https~3a%2F%2Fwphomes..soic..indiana..edu%2Fjsiek%2Ffiles%2F2014%2F03%2Fretic-python..pdf%29" class="AutobibLink" data-pltdoc="x">Vitousek et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Michael._.M..._.Vitousek%2C._.Andrew._.Kent%2C._.Jeremy._.G..._.Siek%2C._and._.Jim._.Baker.Design._and._.Evaluation._of._.Gradual._.Typing._for._.Python.In._.Proc..._.Dynamic._.Languages._.Symposium%2C._pp..._45--562014https~3a%2F%2Fwphomes..soic..indiana..edu%2Fjsiek%2Ffiles%2F2014%2F03%2Fretic-python..pdf%29" class="AutobibLink" data-pltdoc="x">2014</a>]</span> (also see <span class="Autobibref">&nbsp;[<a href="#%28autobib._.Michael._.M..._.Vitousek%2C._.Cameron._.Swords%2C._and._.Jeremy._.G..._.Siek.Big._.Types._in._.Little._.Runtime~3a._.Open-.World._.Soundness._and._.Collaborative._.Blame._for._.Gradual._.Type._.Systems.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._762--7742017https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F3009837..3009849%29" class="AutobibLink" data-pltdoc="x">Vitousek et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Michael._.M..._.Vitousek%2C._.Cameron._.Swords%2C._and._.Jeremy._.G..._.Siek.Big._.Types._in._.Little._.Runtime~3a._.Open-.World._.Soundness._and._.Collaborative._.Blame._for._.Gradual._.Type._.Systems.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._762--7742017https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F3009837..3009849%29" class="AutobibLink" data-pltdoc="x">2017</a>]</span>), who
propose &ldquo;transient checks&rdquo; and industrial systems, such as
TypeScript which &ldquo;erase&rdquo; boundaries<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Gavin._.M..._.Bierman%2C._.Mart~c3~adn._.Abadi%2C._and._.Mads._.Torgersen.Understanding._.Type.Script.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._257--2812014https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1007%2F978-3-662-44202-9_11%29" class="AutobibLink" data-pltdoc="x">Bierman et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Gavin._.M..._.Bierman%2C._.Mart~c3~adn._.Abadi%2C._and._.Mads._.Torgersen.Understanding._.Type.Script.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._257--2812014https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1007%2F978-3-662-44202-9_11%29" class="AutobibLink" data-pltdoc="x">2014</a>]</span>.</p><p>For Natural, checks are inserted and propagated so that when a value
needs to have a certain type, it is either checked to be that type
fully, or wrapped in a delayed-checking monitor, similar to
higher-order contracts.  For Transient, checks are added in the
translation that only ensure first-order properties, meaning for
example when a function type is needed, transient checks the value is
a function of any type. For Erasure, as the name suggests, no checks
are added in the translation. The type is &#8220;erased&#8221;, meaning values
flow without restrictions between different regions of code.</p><p>Given these varying semantics, researchers sought to compare them and
justify their particular design choices with formal properties of the
languages. In general, Erasure either doesn&#8217;t satisfy the properties
or trivially does. The most familiar property is type soundness. In
the case of Natural, the values are exactly the expected type, but in
Transient, the value has only a matching top level constructor because
of first-order checks don&rsquo;t check in depth<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Ben._.Greenman._and._.Matthias._.Felleisen.A._.Spectrum._of._.Type._.Soundness._and._.Performance.Proceedings._of._the._.A.C.M._on._.Programming._.Languages._%28.I.C.F.P%29._2%2871%29%2C._pp..._1--322018%29" class="AutobibLink" data-pltdoc="x">Greenman and Felleisen</a> <a href="#%28autobib._.Ben._.Greenman._and._.Matthias._.Felleisen.A._.Spectrum._of._.Type._.Soundness._and._.Performance.Proceedings._of._the._.A.C.M._on._.Programming._.Languages._%28.I.C.F.P%29._2%2871%29%2C._pp..._1--322018%29" class="AutobibLink" data-pltdoc="x">2018</a>]</span>.</p><p>More recently, <span class="Autobibref"><a href="#%28autobib._.Ben._.Greenman%2C._.Matthias._.Felleisen%2C._and._.Christos._.Dimoulas.Complete._.Monitors._for._.Gradual._.Types.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications2019%29" class="AutobibLink" data-pltdoc="x">Greenman et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Ben._.Greenman%2C._.Matthias._.Felleisen%2C._and._.Christos._.Dimoulas.Complete._.Monitors._for._.Gradual._.Types.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications2019%29" class="AutobibLink" data-pltdoc="x">2019</a>]</span> show that Natural
satisfies interesting properties that Transient fails. Technically,
they present and prove a version of complete monitoring for gradually
typed languages. Originally developed for the contract world, complete
monitoring demands that whenever a value goes through a type boundary
it is possible to check it completely for all possible uses.  They
show that Natural does satisfy this property while Transient does not.</p><p>As an alternative approach to comparing these semantics of gradual
typing, <span class="Autobibref"><a href="#%28autobib._.Benjamin._.Chung%2C._.Paley._.Li%2C._.Francesco._.Zappa._.Nardelli%2C._and._.Jan._.Vitek.Kaf.Ka~3a._.Gradual._.Typing._for._.Objects...In._.Proc..._.European._.Conference._on._.Object-.Oriented._.Programming2018https~3a%2F%2Fhal..inria..fr%2Fhal-01882148%2Fdocument%29" class="AutobibLink" data-pltdoc="x">Chung et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Benjamin._.Chung%2C._.Paley._.Li%2C._.Francesco._.Zappa._.Nardelli%2C._and._.Jan._.Vitek.Kaf.Ka~3a._.Gradual._.Typing._for._.Objects...In._.Proc..._.European._.Conference._on._.Object-.Oriented._.Programming2018https~3a%2F%2Fhal..inria..fr%2Fhal-01882148%2Fdocument%29" class="AutobibLink" data-pltdoc="x">2018</a>]</span> give three example programs in a common
framework&#8212;<wbr></wbr>Kafka&#8212;<wbr></wbr>and use them to demonstrate differences between
the three semantics. These litmus tests exercise the occurrence of
unrelated types, incompatible types, and crossing through multiple
boundaries. They show all three run in Erasure, the unrelated types
example signals a problem in Transient as well as Natural, and the
crossing multiple boundaries example signals a violation in Natural
only.</p><h3><a name="(part._8)"></a>Automatic Differentiation</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Daniel Melcer</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="8.pdf">12 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Automatic differentiation allows a programmer to calculate the derivative of a
function or pieces of the Jacobian matrix when a function has several inputs or
outputs.</p><p><span class="Autobibref"><a href="#%28autobib._.R..._.E..._.Wengert.A._.Simple._.Automatic._.Derivative._.Evaluation._.Program.Communications._of._the._.A.C.M._7%2C._pp..._463--4641964https~3a%2F%2Fdoi..org%2F10..1145%2F355586..364791%29" class="AutobibLink" data-pltdoc="x">Wengert</a>&nbsp;[<a href="#%28autobib._.R..._.E..._.Wengert.A._.Simple._.Automatic._.Derivative._.Evaluation._.Program.Communications._of._the._.A.C.M._7%2C._pp..._463--4641964https~3a%2F%2Fdoi..org%2F10..1145%2F355586..364791%29" class="AutobibLink" data-pltdoc="x">1964</a>]</span> presents the first (Western<span class="refelem"><span class="refcolumn"><span class="refcontent">Before the &ldquo;iron
curtain&rdquo; came down, applied mathematicians and theoretical computer scientists
in the West were unaware of advances in the East, such as <span class="Autobibref"><a href="#%28autobib._.E..._.Beda%2C._.L..._.N..._.Korolev%2C._.N..._.V..._.Sukkikh%2C._and._.T..._.S..._.Frolova.Programs._.For._.Automatic._.Differentiation._.For._.The._.Machine._.B.E.S.M.Institute._for._.Precise._.Mechanics._and._.Computation._.Techniques%2C._.Academy._of._.Science%2C._~5b.Ostrovskii1971.Ud.B~5d1959%29" class="AutobibLink" data-pltdoc="x">Beda et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.E..._.Beda%2C._.L..._.N..._.Korolev%2C._.N..._.V..._.Sukkikh%2C._and._.T..._.S..._.Frolova.Programs._.For._.Automatic._.Differentiation._.For._.The._.Machine._.B.E.S.M.Institute._for._.Precise._.Mechanics._and._.Computation._.Techniques%2C._.Academy._of._.Science%2C._~5b.Ostrovskii1971.Ud.B~5d1959%29" class="AutobibLink" data-pltdoc="x">1959</a>]</span>&rsquo;s work
on the forward-mode automated differentiation.</span></span></span>) description of automatic
differentiation using dual numbers, that is, structures that track the value of
a function for a given value along with its derivative at that same value. This
approach is later refined to use structs instead of size-2 vectors
<span class="Autobibref"><a href="#%28autobib._.L...B..._.Rall.Differentiation._in._~7b.P.A.S.C.A.L~7d-~7b.S.C~7d.Transactions._on._.Mathematical._.Software._10%282%29%2C._pp..._161--1841984https~3a%2F%2Fdoi..org%2F10..1145%2F399..418%29" class="AutobibLink" data-pltdoc="x">Rall</a>&nbsp;[<a href="#%28autobib._.L...B..._.Rall.Differentiation._in._~7b.P.A.S.C.A.L~7d-~7b.S.C~7d.Transactions._on._.Mathematical._.Software._10%282%29%2C._pp..._161--1841984https~3a%2F%2Fdoi..org%2F10..1145%2F399..418%29" class="AutobibLink" data-pltdoc="x">1984</a>]</span>.</p><p>This dual-number approach is effective for calculation when there are many
output variables but few input parameters. But, it is run O(n) times with
respect to the number of input variables, imposing an inefficiency as the number
of inputs grows.  <span class="Autobibref"><a href="#%28autobib._.B..._.Speelpenning.Compiling._.Fast._.Partial._.Derivatives._of._.Functions._.Given._by._algorithms.Ph...D..._dissertation%2C._.University._of._.Illinois%2C._.Urbana-.Champagne1980https~3a%2F%2Fdoi..org%2F10..2172%2F5254402%29" class="AutobibLink" data-pltdoc="x">Speelpenning</a>&nbsp;[<a href="#%28autobib._.B..._.Speelpenning.Compiling._.Fast._.Partial._.Derivatives._of._.Functions._.Given._by._algorithms.Ph...D..._dissertation%2C._.University._of._.Illinois%2C._.Urbana-.Champagne1980https~3a%2F%2Fdoi..org%2F10..2172%2F5254402%29" class="AutobibLink" data-pltdoc="x">1980</a>]</span> introduces (an implementation of) the
"reverse mode," which keeps a log of computations. Using this log it is possible
to back-propagates the derivative of all intermediate values with respect to a
single output value, eventually finding the gradient of the entire
input. Speelpennig&rsquo;s tool is a precompiler, transforming FORTRAN source code to
calculate derivatives. Source-transformation AD tools continued to
improve&#8212;<wbr></wbr>covering more of the full language&#8212;<wbr></wbr>resulting in ADIFOR, as the most
popular tool for a long time<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Christian._.Bischof%2C._.Alan._.Carle%2C._.George._.Corliss%2C._.Andreas._.Griewank%2C._and._.Paul._.Hovland.A.D.I.F.O.R~e2~80~93.Generating._.Derivative._.Codes._from._.Fortran._.Programs.Scientific._.Programming._1%281%29%2C._pp..._11--291992https~3a%2F%2Fwww..hindawi..com%2Fjournals%2Fsp%2F1992%2F717832%2F%29" class="AutobibLink" data-pltdoc="x">Bischof et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Christian._.Bischof%2C._.Alan._.Carle%2C._.George._.Corliss%2C._.Andreas._.Griewank%2C._and._.Paul._.Hovland.A.D.I.F.O.R~e2~80~93.Generating._.Derivative._.Codes._from._.Fortran._.Programs.Scientific._.Programming._1%281%29%2C._pp..._11--291992https~3a%2F%2Fwww..hindawi..com%2Fjournals%2Fsp%2F1992%2F717832%2F%29" class="AutobibLink" data-pltdoc="x">1992</a>]</span>.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">In 2007, <span class="Autobibref"><a href="#%28autobib._.Jeffrey._.Mark._.Siskind._and._.Barak._.A..._.Pearlmutter.Lazy._.Multivariate._.Higher-.Order._.Forward-.Mode._~7b.A.D~7d.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._155--1602007https~3a%2F%2Fdoi..org%2F10..1145%2F1190216..1190242%29" class="AutobibLink" data-pltdoc="x">Siskind and Pearlmutter</a>&nbsp;[<a href="#%28autobib._.Jeffrey._.Mark._.Siskind._and._.Barak._.A..._.Pearlmutter.Lazy._.Multivariate._.Higher-.Order._.Forward-.Mode._~7b.A.D~7d.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._155--1602007https~3a%2F%2Fdoi..org%2F10..1145%2F1190216..1190242%29" class="AutobibLink" data-pltdoc="x">2007<span class="AutobibLink">b</span>,<span class="AutobibLink">a</span></a>]</span>
reported on a new, reification-based technique for AD in the world of
higher-order languages. But also see <span class="Autobibref"><a href="#%28autobib._.Oleksandr._.Manzyuk%2C._.Barak._.A..._.Pearlmutter%2C._.Alexey._.Andreyevich._.Radul%2C._.David._.R..._.Rush%2C._and._.Jeffrey._.Mark._.Siskind.Perturbation._.Confusion._in._.Forward._.Automatic._.Differentiation._of._.Higher-.Order._.Functions.Journal._of._.Functional._.Programming._292019https~3a%2F%2Fdoi..org%2F10..1017%2F.S095679681900008.X%29" class="AutobibLink" data-pltdoc="x">Manzyuk et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Oleksandr._.Manzyuk%2C._.Barak._.A..._.Pearlmutter%2C._.Alexey._.Andreyevich._.Radul%2C._.David._.R..._.Rush%2C._and._.Jeffrey._.Mark._.Siskind.Perturbation._.Confusion._in._.Forward._.Automatic._.Differentiation._of._.Higher-.Order._.Functions.Journal._of._.Functional._.Programming._292019https~3a%2F%2Fdoi..org%2F10..1017%2F.S095679681900008.X%29" class="AutobibLink" data-pltdoc="x">2019</a>]</span> for
unsolved problems in this contexts.</span></span></span></p><p>Reverse mode has higher memory requirements than forward mode.
<span class="Autobibref"><a href="#%28autobib._.Andreas._.Griewank.Achieving._logarithmic._growth._of._temporal._and._spatial._complexity._in._reverse._automatic._differentiation.Optimization._.Methods._and._.Software._1%281%29%2C._pp..._35--541992https~3a%2F%2Fdoi..org%2F10..1080%2F10556789208805505%29" class="AutobibLink" data-pltdoc="x">Griewank</a>&nbsp;[<a href="#%28autobib._.Andreas._.Griewank.Achieving._logarithmic._growth._of._temporal._and._spatial._complexity._in._reverse._automatic._differentiation.Optimization._.Methods._and._.Software._1%281%29%2C._pp..._35--541992https~3a%2F%2Fdoi..org%2F10..1080%2F10556789208805505%29" class="AutobibLink" data-pltdoc="x">1992</a>]</span> partially mitigates this issue through check-pointing
(while increasing the amount of required computation).  These source
transformation tools cannot handle every program, notably failing upon
encountering a recursive function. <span class="Autobibref"><a href="#%28autobib._.Andreas._.Griewank%2C._.David._.Juedes%2C._and._.Jean._.Utke.Algorithm._755~3a._~7b.A.D.O.L~7d-.C~3a._a._package._for._the._automatic._differentiation._of._algorithms._written._in._.C%2F.C%2B%2B.Transactions._on._.Mathematical._.Software._22%282%29%2C._pp..._131--1671996https~3a%2F%2Fdoi..org%2F10..1145%2F229473..229474%29" class="AutobibLink" data-pltdoc="x">Griewank et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Andreas._.Griewank%2C._.David._.Juedes%2C._and._.Jean._.Utke.Algorithm._755~3a._~7b.A.D.O.L~7d-.C~3a._a._package._for._the._automatic._differentiation._of._algorithms._written._in._.C%2F.C%2B%2B.Transactions._on._.Mathematical._.Software._22%282%29%2C._pp..._131--1671996https~3a%2F%2Fdoi..org%2F10..1145%2F229473..229474%29" class="AutobibLink" data-pltdoc="x">1996</a>]</span> finally introduces a
C++ runtime library that handles the full reverse mode, avoiding the many
pitfalls of source transformations.</p><h3><a name="(part._9)"></a>Meetings </h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 16 Feb 2021</p></blockquote></blockquote></blockquote><p>I will meet with everyone 1-1 on this day to discuss your
progress for your first topic. Here is the schedule:</p><blockquote><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>time</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace"></span></p></td><td style="border-bottom: 1px solid black;"><p>student</p></td></tr><tr><td valign="top"><p>09:50am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Helena</p></td></tr><tr><td valign="top"><p>10:00am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Josh</p></td></tr><tr><td valign="top"><p>10:10am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Ryan</p></td></tr><tr><td valign="top"><p>10:20am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Nathan</p></td></tr><tr><td valign="top"><p>10:30am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Mitch</p></td></tr><tr><td valign="top"><p>10:40am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Andrew</p></td></tr><tr><td valign="top"><p>10:50am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Donald</p></td></tr><tr><td valign="top"><p>11:00am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Emily</p></td></tr><tr><td valign="top"><p>11:10am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Lucy</p></td></tr><tr><td valign="top"><p>11:20am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Ankit</p></td></tr><tr><td valign="top"><p>11:30am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Olek</p></td></tr><tr><td valign="top"><p>11:40am</p></td><td valign="top"><p><span class="hspace"></span></p></td><td valign="top"><p> Jared</p></td></tr></table></blockquote><p>We will use the normal class link for these meetings.</p><p><div class="SIntrapara">Each meeting will discuss the following items in order:
</div><div class="SIntrapara"><ul><li><p>your reading progress</p></li><li><p>your abstract</p></li><li><p>your note taking</p></li><li><p>a &ldquo;dress rehearsal&rdquo;</p></li><li><p>if you are a PhD student, your second topic; for others; an optional second topic.</p></li></ul></div><div class="SIntrapara">MS/undergraduate students who have delivered a lecture are excused.</div></p><h3><a name="(part._10)"></a>Hindley-Milner Type Inference</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Josh Goldman</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="10.pdf">19 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>The goal of type inference is to reduce programmer&rsquo;s workload. Generally
speaking, type inference is an algorithm that restores type specification of
variables that the programmer leaves out.  Every such omitted type specification
is a variable in a system of constraints, determined by the surrounding program
context. As with ordinary mathematical equation systems, a type inference
algorithm may find no solutions, an exact solution for all variables, or an
infinite number of them. In this last case, the algorithm assigns many type to a
function, say, and this function can be used at any of these types.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">The idea was pre-discovered by an office mate of Milner, Hindley,
ten years before, which is why it is known as Hindley-Milner type inference.</span></span></span>
<span class="Autobibref"><a href="#%28autobib._.Robin._.Milner.A._.Theory._of._.Type._.Polymorphism._in._.Programming.Journal._of._.Computer._and._.System._.Sciences._17%2C._pp..._348--3751978https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fwadler%2Fpapers%2Fpapers-we-love%2Fmilner-type-polymorphism..pdf%29" class="AutobibLink" data-pltdoc="x">Milner</a>&nbsp;[<a href="#%28autobib._.Robin._.Milner.A._.Theory._of._.Type._.Polymorphism._in._.Programming.Journal._of._.Computer._and._.System._.Sciences._17%2C._pp..._348--3751978https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fwadler%2Fpapers%2Fpapers-we-love%2Fmilner-type-polymorphism..pdf%29" class="AutobibLink" data-pltdoc="x">1978</a>]</span> was the first to recognize the practical value of such an
algorithm in the context of programming languages. He simultaneously injected
the idea of a &ldquo;well-typed program,&rdquo; as characterized by Semantic and Syntactic
Soundness Theorems. With his student Luis Damas, Milner later constructed
Algorithm W to find the most general type for any expression in a functional
subset of ML <span class="Autobibref"><a href="#%28autobib._.Luis._.Damas._and._.Robin._.Milner.Principal._.Type-.Schemes._for._.Functional._.Programs.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._207--2121982https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F582153..582176%29" class="AutobibLink" data-pltdoc="x">Damas and Milner</a>&nbsp;[<a href="#%28autobib._.Luis._.Damas._and._.Robin._.Milner.Principal._.Type-.Schemes._for._.Functional._.Programs.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._207--2121982https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F582153..582176%29" class="AutobibLink" data-pltdoc="x">1982</a>]</span>. Similar algorithms had been in PL folklore for some
years.</p><p>Hindley-Milner type inference turned out less optimal than thought, both in
terms of performance and pragmatics. First, programmers initially thought of W
as a linear-time or at least polynomial-time algorithm until <span class="Autobibref"><a href="#%28autobib._.Harry._.Mairson.Deciding._.M.L._.Typability._is._.Complete._for._.Deterministic._.Exponential._.Time.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._382--4011989https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F96709..96748%29" class="AutobibLink" data-pltdoc="x">Mairson</a>&nbsp;[<a href="#%28autobib._.Harry._.Mairson.Deciding._.M.L._.Typability._is._.Complete._for._.Deterministic._.Exponential._.Time.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._382--4011989https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F96709..96748%29" class="AutobibLink" data-pltdoc="x">1989</a>]</span> took
reduced typability in ML to deterministic exponential time. Second, people
expected that the Hindley-Milner form of type inference could be extended to a
broad range of language features. In 1993, <span class="Autobibref"><a href="#%28autobib._.Fritz._.Henglein.Type._.Inference._with._.Polymorphic._.Recursion.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._15%282%29%2C._pp..._253--2891993https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F169701..169692%29" class="AutobibLink" data-pltdoc="x">Henglein</a>&nbsp;[<a href="#%28autobib._.Fritz._.Henglein.Type._.Inference._with._.Polymorphic._.Recursion.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._15%282%29%2C._pp..._253--2891993https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F169701..169692%29" class="AutobibLink" data-pltdoc="x">1993</a>]</span> reduced type inference
for the Milner-Mycroft variant to the semi-unification, a problem known to be
undecidable. Due to the nature of both limitations, researchers and programmers
have questioned the status of type inference for the past two decades.</p><h3><a name="(part._11)"></a>System F Type Systems: From Theory to Practice </h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Ryan Guo</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="11.pdf">23 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>In simply typed lambda calculus (STLC), functions such as the identity function
must be re-defined for arguments with different type, yet these functions all
share the same behavior. This duplication becomes more severe as the programs
become more complex.</p><p>An extension of the STLC, due to <span class="Autobibref"><a href="#%28autobib._.John._.C..._.Reynolds.Towards._a._.Theory._of._.Type._.Structure.In._.Proc..._.Programming._.Symposium%2C._pp..._408--4251974https~3a%2F%2Fdoi..org%2F10..1007%2F3-540-06859-7_148%29" class="AutobibLink" data-pltdoc="x">Reynolds</a>&nbsp;[<a href="#%28autobib._.John._.C..._.Reynolds.Towards._a._.Theory._of._.Type._.Structure.In._.Proc..._.Programming._.Symposium%2C._pp..._408--4251974https~3a%2F%2Fdoi..org%2F10..1007%2F3-540-06859-7_148%29" class="AutobibLink" data-pltdoc="x">1974</a>]</span>, introduces abstraction over
types, i.e., parametric polymorphic functions. This solves the aforementioned
duplication issue. Reynolds proves a Representation Theorem for this system,
which shows that different representations of primitive types will not affect
the behavior of a typed program in this extension. This extension is more known
as System F, named by Girard who independently discovered the same system in the
context of proof theory in logic.</p><p><span class="Autobibref"><a href="#%28autobib._.Luca._.Cardelli._and._.Peter._.Wegner.On._understanding._types%2C._data._abstraction%2C._and._polymorphism.A.C.M._.Computing._.Surveys._17%284%29%2C._pp..._471--5231985https~3a%2F%2Fdoi..org%2F10..1145%2F6041..6042%29" class="AutobibLink" data-pltdoc="x">Cardelli and Wegner</a>&nbsp;[<a href="#%28autobib._.Luca._.Cardelli._and._.Peter._.Wegner.On._understanding._types%2C._data._abstraction%2C._and._polymorphism.A.C.M._.Computing._.Surveys._17%284%29%2C._pp..._471--5231985https~3a%2F%2Fdoi..org%2F10..1145%2F6041..6042%29" class="AutobibLink" data-pltdoc="x">1985</a>]</span> propose to use the &ldquo;Fun&rdquo; language for studying extensions of
this system. It brings together the idea of parametric polymorphism from System
F, existential quantification, and bounded quantification. However, bounded
quantification cannot model objects that are elements of recursively-defined
types. In response, <span class="Autobibref"><a href="#%28autobib._.Peter._.Canning%2C._.William._.Cook%2C._.Walter._.Hill%2C._.Walter._.Olthoff%2C._and._.John._.C..._.Mitchell.F-bounded._.Polymorphism._for._.Object-.Oriented._.Programming.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture%2C._pp..._273--2801989https~3a%2F%2Fdoi..org%2F10..1145%2F99370..99392%29" class="AutobibLink" data-pltdoc="x">Canning et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Peter._.Canning%2C._.William._.Cook%2C._.Walter._.Hill%2C._.Walter._.Olthoff%2C._and._.John._.C..._.Mitchell.F-bounded._.Polymorphism._for._.Object-.Oriented._.Programming.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture%2C._pp..._273--2801989https~3a%2F%2Fdoi..org%2F10..1145%2F99370..99392%29" class="AutobibLink" data-pltdoc="x">1989</a>]</span> introduced F-bounded quantification.</p><p>Modern developers now rely on some of these ideas in the context
mainstream programming languages, a development that took three
steps. The first is a language dubbed Pizza, due to
<span class="Autobibref"><a href="#%28autobib._.Martin._.Odersky._and._.Philip._.Wadler.Pizza._into._.Java~3a._.Translating._.Theory._into._.Practice.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._146--1591997https~3a%2F%2Fdoi..org%2F10..1145%2F263699..263715%29" class="AutobibLink" data-pltdoc="x">Odersky and Wadler</a>&nbsp;[<a href="#%28autobib._.Martin._.Odersky._and._.Philip._.Wadler.Pizza._into._.Java~3a._.Translating._.Theory._into._.Practice.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._146--1591997https~3a%2F%2Fdoi..org%2F10..1145%2F263699..263715%29" class="AutobibLink" data-pltdoc="x">1997</a>]</span>. The language runs on the JVM and syntactically
extends Java, making use of F-bounded quantification and existential
types to implement type-sound generic classes and
methods. <span class="refelem"><span class="refcolumn"><span class="refcontent">Pizza comes with abstract data types and higher
order functions, demonstrating their compatibility with Java.</span></span></span> But,
the soundness constraints on these generics disallow linking Pizza
code with certain Java libraries&#8212;<wbr></wbr>raising a serious compatibility
issue. To fix this flaw, <span class="Autobibref"><a href="#%28autobib._.Gilad._.Bracha%2C._.Martin._.Odersky%2C._.David._.Stoutamire%2C._and._.Philip._.Wadler.Making._the._.Future._.Safe._for._the._.Past~3a._.Adding._.Genericity._to._the._.Java._.Programming._.Language.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._183--2001998https~3a%2F%2Fdoi..org%2F10..1145%2F286936..286957%29" class="AutobibLink" data-pltdoc="x">Bracha et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Gilad._.Bracha%2C._.Martin._.Odersky%2C._.David._.Stoutamire%2C._and._.Philip._.Wadler.Making._the._.Future._.Safe._for._the._.Past~3a._.Adding._.Genericity._to._the._.Java._.Programming._.Language.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._183--2001998https~3a%2F%2Fdoi..org%2F10..1145%2F286936..286957%29" class="AutobibLink" data-pltdoc="x">1998</a>]</span> propose a small change, dubbed
the GJ language. It is a conservative extension of Java that adds only
generics; GJ introduces <span class="emph">raw types</span> to handle backward
compatibility and <span class="emph">retro-fitting</span> to handle forward
compatibility.</p><h3><a name="(part._12)"></a>Ideas: From Conception to Programming <span class="strike" style="text-decoration:line-through">PER Semantics of Types</span> </h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author"><span class="strike" style="text-decoration:line-through">Nathaniel Yazdani</span></p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="12.pdf">26 Feb 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._13)"></a>The PI Calculus</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Mitch Gamburg</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="13.pdf">2 Mar 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>The PI-calculus is the most well-known and most well-developed formal
system&#8212;<wbr></wbr>among dozens&#8212;<wbr></wbr>for studying concurrent and communicating software. Its
immediate predecessor, the Calculus of Communicating Systems, describes a
software component, called an agent, as its interactions with an external
observer, which may also be an agent<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Robin._.Milner.A._.Calculus._of._.Communicating._.Systems.Lecture._.Notes._in._.Computer._.Science1980https~3a%2F%2Flink..springer..com%2Fbook%2F10..1007%2F3-540-10235-3%29" class="AutobibLink" data-pltdoc="x">Milner</a> <a href="#%28autobib._.Robin._.Milner.A._.Calculus._of._.Communicating._.Systems.Lecture._.Notes._in._.Computer._.Science1980https~3a%2F%2Flink..springer..com%2Fbook%2F10..1007%2F3-540-10235-3%29" class="AutobibLink" data-pltdoc="x">1980</a>]</span>. All interactions take
place as message exchanges via dedicated channels. Extended CCS <span class="Autobibref">&nbsp;[<a href="#%28autobib._.Uffe._.Engberg._and._.Mogens._.Nielsen.A._.Calculus._of._.Communicating._.Systems._with._.Label-.Passing.In._.Proc..._.Proof%2C._.Language%2C._and._.Interaction._~3a._.Essays._in._.Honour._of._.Robin._.Milner..._.M.I.T._.Press..%2C._pp..._599--6221986https~3a%2F%2Fpdfs..semanticscholar..org%2F802f%2Fa6e557acc721d9dc04a2fdded5bf75240e8c..pdfalso._available._as._.D.A.I.M.I._.Tech..._.Rpt..._208%2C._.University._of._.Aarhus%29" class="AutobibLink" data-pltdoc="x">Engberg and Nielsen</a> <a href="#%28autobib._.Uffe._.Engberg._and._.Mogens._.Nielsen.A._.Calculus._of._.Communicating._.Systems._with._.Label-.Passing.In._.Proc..._.Proof%2C._.Language%2C._and._.Interaction._~3a._.Essays._in._.Honour._of._.Robin._.Milner..._.M.I.T._.Press..%2C._pp..._599--6221986https~3a%2F%2Fpdfs..semanticscholar..org%2F802f%2Fa6e557acc721d9dc04a2fdded5bf75240e8c..pdfalso._available._as._.D.A.I.M.I._.Tech..._.Rpt..._208%2C._.University._of._.Aarhus%29" class="AutobibLink" data-pltdoc="x">1986</a>]</span>
allows agents to send channels over channels. As a result, agents may
dynamically change their link-based connections. The PI-calculus itself is the
result of removing all distinctions between channels and other values (such as
numbers) <span class="Autobibref">&nbsp;[<a href="#%28autobib._.Robin._.Milner%2C._.Joachim._.Parrow%2C._and._.David._.Walker.A._.Calculus._of._.Mobile._.Processes.Information._and._.Computation%2C._pp..._1--11992https~3a%2F%2Freader..elsevier..com%2Freader%2Fsd%2Fpii%2F0890540192900084~3ftoken~3d63.E.D320.E.D.F.C5.C.D8.F1.E42.C5.F3129711055.A0075.B.A0.E46092.E.F.C.F9849.E83802.A.B105792.B4.D135985.A0.E.B8.A.F7.E.F9949.E610%29" class="AutobibLink" data-pltdoc="x">Milner et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Robin._.Milner%2C._.Joachim._.Parrow%2C._and._.David._.Walker.A._.Calculus._of._.Mobile._.Processes.Information._and._.Computation%2C._pp..._1--11992https~3a%2F%2Freader..elsevier..com%2Freader%2Fsd%2Fpii%2F0890540192900084~3ftoken~3d63.E.D320.E.D.F.C5.C.D8.F1.E42.C5.F3129711055.A0075.B.A0.E46092.E.F.C.F9849.E83802.A.B105792.B4.D135985.A0.E.B8.A.F7.E.F9949.E610%29" class="AutobibLink" data-pltdoc="x">1992</a>]</span>.</p><p>While the simplification of the value universe makes the PI-calculus more
expressive than CCS and simplifies it at the same time, it also injects a sense
of chaos and confusion. As <span class="Autobibref"><a href="#%28autobib._.Robin._.Milner.The._.Polyadic._.P.I-.Calculus~3a._.A._.Tutorial.Logic._and._.Algebra._of._.Specification%2C._pp..._203--2461991https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F978-3-642-58041-3_6%29" class="AutobibLink" data-pltdoc="x">Milner</a>&nbsp;[<a href="#%28autobib._.Robin._.Milner.The._.Polyadic._.P.I-.Calculus~3a._.A._.Tutorial.Logic._and._.Algebra._of._.Specification%2C._pp..._203--2461991https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F978-3-642-58041-3_6%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> argues, the best way to inject
discipline into such a world is to add a form of type system, which results in
the polyadic PI-calculus. To facilitate communication in this context, the
calculus also comes with tuple values.</p><p>Among its many variants, <span class="Autobibref"><a href="#%28autobib._.Benjamin._.Pierce._and._.Davide._.Sangiorgi.Typing._and._.Sub-typing._of._.Mobile._.Processes.In._.Proc..._.Logic._in._.Computer._.Science%2C._pp..._376--3851994https~3a%2F%2Fieeexplore..ieee..org%2Fdocument%2F287570%29" class="AutobibLink" data-pltdoc="x">Pierce and Sangiorgi</a>&nbsp;[<a href="#%28autobib._.Benjamin._.Pierce._and._.Davide._.Sangiorgi.Typing._and._.Sub-typing._of._.Mobile._.Processes.In._.Proc..._.Logic._in._.Computer._.Science%2C._pp..._376--3851994https~3a%2F%2Fieeexplore..ieee..org%2Fdocument%2F287570%29" class="AutobibLink" data-pltdoc="x">1994</a>]</span>&rsquo;s interface-oriented PI-calculus
stands out. It extends Milner&rsquo;s sorting discipline with specification of a
channel&rsquo;s interface: a channel could be read-only, write-only, or both read and
write. By imposing a linearity constraint on such interfaces, <span class="Autobibref"><a href="#%28autobib._.Naoki._.Kobayashi%2C._.Benjamin._.Pierce%2C._and._.David._.Turner.Linearity._and._the._.P.I-.Calculus.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._21%285%29%2C._pp..._914--9471999https~3a%2F%2Fdl..acm..org%2Fdoi%2Fpdf%2F10..1145%2F330249..330251%29" class="AutobibLink" data-pltdoc="x">Kobayashi et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Naoki._.Kobayashi%2C._.Benjamin._.Pierce%2C._and._.David._.Turner.Linearity._and._the._.P.I-.Calculus.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._21%285%29%2C._pp..._914--9471999https~3a%2F%2Fdl..acm..org%2Fdoi%2Fpdf%2F10..1145%2F330249..330251%29" class="AutobibLink" data-pltdoc="x">1999</a>]</span>
lay the foundation for behavioral types&#8212;<wbr></wbr>also known as session types&#8212;<wbr></wbr>for the
agents of the PI-calculus.</p><h3><a name="(part._14)"></a>Session Types</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Andrew Wagner</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="14.pdf">5 Mar 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>The development of process calculi in the 1970s and 1980s triggered
the search for type systems to quell deadlocks and races from
process-oriented programs.</p><p>One promising approach, due to <span class="Autobibref"><a href="#%28autobib._.K..._.Honda.Types._for._.Dyadic._.Interaction.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory._volume._715%2C._pp..._509--5231993https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F3-540-57208-2_35%29" class="AutobibLink" data-pltdoc="x">Honda</a>&nbsp;[<a href="#%28autobib._.K..._.Honda.Types._for._.Dyadic._.Interaction.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory._volume._715%2C._pp..._509--5231993https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F3-540-57208-2_35%29" class="AutobibLink" data-pltdoc="x">1993</a>]</span>, identifies a core set
of types for interactions between two processes. Central to ensuring
communication safety in Honda&#8217;s theory are the properties of linearity
and duality. <span class="Autobibref"><a href="#%28autobib._.K..._.Takeuchi%2C._.K..._.Honda%2C._and._.M..._.Kubo.An._.Interaction-based._.Language._and._its._.Typing._.System.In._.Proc..._.International._.Conference._on._.Parallel._.Architectures._and._.Languages._.Europe%2C._pp..._398--4131994https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F3-540-58184-7_118%29" class="AutobibLink" data-pltdoc="x">Takeuchi et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.K..._.Takeuchi%2C._.K..._.Honda%2C._and._.M..._.Kubo.An._.Interaction-based._.Language._and._its._.Typing._.System.In._.Proc..._.International._.Conference._on._.Parallel._.Architectures._and._.Languages._.Europe%2C._pp..._398--4131994https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F3-540-58184-7_118%29" class="AutobibLink" data-pltdoc="x">1994</a>]</span> builds upon this set of types but
also introduces the notion of a session, which is analogous to a type
abstraction from ML. Rounding out the formative phase of the theory,
<span class="Autobibref"><a href="#%28autobib._.Kohei._.Honda%2C._.Vasco._.T..._.Vasconcelos%2C._and._.Makoto._.Kubo.Language._.Primitives._and._.Type._.Discipline._for._.Structured._.Communication-.Based._.Programming.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._122--1381998https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F.B.Fb0053567%29" class="AutobibLink" data-pltdoc="x">Honda et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Kohei._.Honda%2C._.Vasco._.T..._.Vasconcelos%2C._and._.Makoto._.Kubo.Language._.Primitives._and._.Type._.Discipline._for._.Structured._.Communication-.Based._.Programming.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._122--1381998https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F.B.Fb0053567%29" class="AutobibLink" data-pltdoc="x">1998</a>]</span> add recursion and also channel delegation, a
feature inspired by concurrent object-oriented programming.</p><p>Generalizing from two to many parties poses a daunting challenge,
because duality is a linchpin of the theory. To accomplish it,
<span class="Autobibref"><a href="#%28autobib._.K..._.Honda%2C._.N..._.Yoshida%2C._and._.M..._.Carbone.Multiparty._.Asynchronous._.Session._.Types.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._273--2842008https~3a%2F%2Fwww..doc..ic..ac..uk%2F~7eyoshida%2Fmultiparty%2Fmultiparty..pdf%29" class="AutobibLink" data-pltdoc="x">Honda et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.K..._.Honda%2C._.N..._.Yoshida%2C._and._.M..._.Carbone.Multiparty._.Asynchronous._.Session._.Types.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._273--2842008https~3a%2F%2Fwww..doc..ic..ac..uk%2F~7eyoshida%2Fmultiparty%2Fmultiparty..pdf%29" class="AutobibLink" data-pltdoc="x">2008</a>]</span> replaces duality with a new notion of
consistency, called coherence. It is defined over global types that
jointly describe the multiparty interaction. To prove coherence, one
projects global types onto local types, which are much like the binary
session types of old.</p><p>Session types abound in the literature, but there is hardly a canonical
system. One approach to find a canonical system equates session types with
propositions<span class="Autobibref">&nbsp;[<a href="#%28autobib._.L..._.Caires._and._.F..._.Pfenning.Session._.Types._as._.Intuitionistic._.Linear._.Propositions.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory%2C._pp..._222--2362010https~3a%2F%2Fwww..cs..cmu..edu%2F~7efp%2Fpapers%2Fconcur10..pdf%29" class="AutobibLink" data-pltdoc="x">Caires and Pfenning</a> <a href="#%28autobib._.L..._.Caires._and._.F..._.Pfenning.Session._.Types._as._.Intuitionistic._.Linear._.Propositions.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory%2C._pp..._222--2362010https~3a%2F%2Fwww..cs..cmu..edu%2F~7efp%2Fpapers%2Fconcur10..pdf%29" class="AutobibLink" data-pltdoc="x">2010</a>; <a href="#%28autobib._.P..._.Wadler.Propositions._as._.Sessions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._273--2862012https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2364527..2364568%29" class="AutobibLink" data-pltdoc="x">Wadler</a> <a href="#%28autobib._.P..._.Wadler.Propositions._as._.Sessions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._273--2862012https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2364527..2364568%29" class="AutobibLink" data-pltdoc="x">2012</a>]</span>, developing a correspondence with
logic in the spirit of Curry and Howard. Another approach encodes session-typed
processes<span class="Autobibref">&nbsp;[<a href="#%28autobib._.O..._.Dardhaa%2C._.E..._.Giachinob%2C._and._.D..._.Sangiorgib.Session._.Types._.Revisited.Information._and._.Computation._2562017https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F.S0890540117300962%29" class="AutobibLink" data-pltdoc="x">Dardhaa et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.O..._.Dardhaa%2C._.E..._.Giachinob%2C._and._.D..._.Sangiorgib.Session._.Types._.Revisited.Information._and._.Computation._2562017https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F.S0890540117300962%29" class="AutobibLink" data-pltdoc="x">2017</a>]</span>, using a variant of the linear &#960;-calculus from
the previous lecture.</p><h3><a name="(part._15)"></a>Functional Reactive Programming</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Donald Pinckney</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="15.pdf">9 Mar 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>As computer hardware shrank in size, software controlled reactive systems became
a center of focus. In response, a flurry of research in the 1980s produced a new
breed of languages, so called &ldquo;dataflow&rsquo; languages<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Albert._.Benveniste%2C._.Paul.Le._.Guernic%2C._and._.Christian._.Jacquemot.Synchronous._.Programming._with._.Events._and._.Relations~3a._the._.S.I.G.N.A.L._.Language._and._.Its._.Semantics.Science._of._.Programming._16%282%29%2C._pp..._103--1491991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F016764239190001.E%29" class="AutobibLink" data-pltdoc="x">Benveniste et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Albert._.Benveniste%2C._.Paul.Le._.Guernic%2C._and._.Christian._.Jacquemot.Synchronous._.Programming._with._.Events._and._.Relations~3a._the._.S.I.G.N.A.L._.Language._and._.Its._.Semantics.Science._of._.Programming._16%282%29%2C._pp..._103--1491991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F016764239190001.E%29" class="AutobibLink" data-pltdoc="x">1991</a>; <a href="#%28autobib._.G~c3~a9rard._.Berry._and._.Georges._.Gonthier.The._.Esterel._.Synchronous._.Programming._.Language~3a._.Design%2C._.Semantics%2C._and._.Implementation.Science._of._.Programming._19%281%29%2C._pp..._87--1521991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F016764239290005.V%29" class="AutobibLink" data-pltdoc="x">Berry and Gonthier</a> <a href="#%28autobib._.G~c3~a9rard._.Berry._and._.Georges._.Gonthier.The._.Esterel._.Synchronous._.Programming._.Language~3a._.Design%2C._.Semantics%2C._and._.Implementation.Science._of._.Programming._19%281%29%2C._pp..._87--1521991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F016764239290005.V%29" class="AutobibLink" data-pltdoc="x">1991</a>; <a href="#%28autobib._.N..._.Halbwachs%2C._.P..._.Caspi%2C._.P..._.Raymond%2C._and._.D..._.Pilaud.The._.Synchronous._.Data._.Flow._.Programming._.Language._.L.U.S.T.R.E.In._.Proc..._.Proceedings._of._the._.I.E.E.E._volume._79%2C._pp..._1305--13201991https~3a%2F%2Fieeexplore..ieee..org%2Fdocument%2F97300%29" class="AutobibLink" data-pltdoc="x">Halbwachs et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.N..._.Halbwachs%2C._.P..._.Caspi%2C._.P..._.Raymond%2C._and._.D..._.Pilaud.The._.Synchronous._.Data._.Flow._.Programming._.Language._.L.U.S.T.R.E.In._.Proc..._.Proceedings._of._the._.I.E.E.E._volume._79%2C._pp..._1305--13201991https~3a%2F%2Fieeexplore..ieee..org%2Fdocument%2F97300%29" class="AutobibLink" data-pltdoc="x">1991</a>; <a href="#%28autobib._.William._.W..._.Wadge._and._.Edward._.A..._.Ashcroft.Lucid%2C._the._.Dataflow._.Programming._.Langugage.Academic._.Press1985http~3a%2F%2Fworrydream..com%2Frefs%2F.Wadge~2520-~2520.Lucid%2C~2520the~2520.Dataflow~2520.Programming~2520.Language..pdf%29" class="AutobibLink" data-pltdoc="x">Wadge and Ashcroft</a> <a href="#%28autobib._.William._.W..._.Wadge._and._.Edward._.A..._.Ashcroft.Lucid%2C._the._.Dataflow._.Programming._.Langugage.Academic._.Press1985http~3a%2F%2Fworrydream..com%2Frefs%2F.Wadge~2520-~2520.Lucid%2C~2520the~2520.Dataflow~2520.Programming~2520.Language..pdf%29" class="AutobibLink" data-pltdoc="x">1985</a>]</span>. Behind their design was the idea of writing down equations
to specify how input signal data flows computes output&#8212;<wbr></wbr>and to generate the
program from these equations.<span class="refelem"><span class="refcolumn"><span class="refcontent">Esterel is alive and well. Airbus
uses it to design some control software for its aircraft.</span></span></span></p><p>In search of a GUI programming model for purely functional languages,
<span class="Autobibref"><a href="#%28autobib._.Conal._.Elliott._and._.Paul._.Hudak.Functional._.Reactive._.Animation.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._263--2731997https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F258948..258973%29" class="AutobibLink" data-pltdoc="x">Elliott and Hudak</a>&nbsp;[<a href="#%28autobib._.Conal._.Elliott._and._.Paul._.Hudak.Functional._.Reactive._.Animation.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._263--2731997https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F258948..258973%29" class="AutobibLink" data-pltdoc="x">1997</a>]</span> recognized the similarity of the problem to reactive control
systems.  Their adaptation of the idiom came to be known as Functional Reactive
Programming (FRP).  Since they were working with Haskell, FRP differed from the
original dataflow languages in two ways: first, they exploited Haskell&rsquo;s
call-by-need semantics, and second, they added continuous time, which allowed
for a natural expression of animations. But time is really based on sampling,
which poses a new semantic problem.</p><p><span class="Autobibref"><a href="#%28autobib._.Zhanyong._.Wan._and._.Paul._.Hudak.Functional._.Reactive._.Programming._from._.First._.Principles.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._242--2522000https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F349299..349331%29" class="AutobibLink" data-pltdoc="x">Wan and Hudak</a>&nbsp;[<a href="#%28autobib._.Zhanyong._.Wan._and._.Paul._.Hudak.Functional._.Reactive._.Programming._from._.First._.Principles.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._242--2522000https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F349299..349331%29" class="AutobibLink" data-pltdoc="x">2000</a>]</span> explored approximate sampling in FRP, specifically conditions for
getting a sampling-based semantics to agree with the continuous semantics. Their
research uncovered pathological FRP terms, including Zeno&#8217;s
paradox. <span class="Autobibref"><a href="#%28autobib._.Zhanyong._.Wan%2C._.Walid._.Taha%2C._and._.Paul._.Hudak.Real-time._.F.R.P.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._45--582001https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F507669..507654%29" class="AutobibLink" data-pltdoc="x">Wan et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Zhanyong._.Wan%2C._.Walid._.Taha%2C._and._.Paul._.Hudak.Real-time._.F.R.P.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._45--582001https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F507669..507654%29" class="AutobibLink" data-pltdoc="x">2001</a>]</span> then identified a pathological class of terms needing
unbounded space. The understanding of these classes of pathological terms
provided most of the motivations for foundational FRP research going
forward. Over the next two decades, a number of researchers<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Neelakantan._.R..._.Krishnaswami%2C._.Nick._._.Benton%2C._and._.Jan._._.Hoffmann.Higher-.Order._.Functional._.Reactive._.Programming._in._.Bounded._.Space.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._45--582012https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2103656..2103665%29" class="AutobibLink" data-pltdoc="x">Krishnaswami et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Neelakantan._.R..._.Krishnaswami%2C._.Nick._._.Benton%2C._and._.Jan._._.Hoffmann.Higher-.Order._.Functional._.Reactive._.Programming._in._.Bounded._.Space.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages%2C._pp..._45--582012https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2103656..2103665%29" class="AutobibLink" data-pltdoc="x">2012</a>; <a href="#%28autobib._.Atze._van._der._.Ploeg._and._.Koen._._.Claessen.Practical._.Principled._.F.R.P~3a._.Forget._the._.Past%2C._.Change._the._.Future%2C._.F.R.P.Now%21.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._302--3142015https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2784731..2784752%29" class="AutobibLink" data-pltdoc="x">Ploeg and Claessen</a> <a href="#%28autobib._.Atze._van._der._.Ploeg._and._.Koen._._.Claessen.Practical._.Principled._.F.R.P~3a._.Forget._the._.Past%2C._.Change._the._.Future%2C._.F.R.P.Now%21.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._302--3142015https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2784731..2784752%29" class="AutobibLink" data-pltdoc="x">2015</a>]</span> used a variety of techniques to eliminate these pathological classes of
programs from FRP.</p><p>Simultaneously to the notion of FRP, <span class="Autobibref"><a href="#%28autobib._.John._.Hughes.Generalising._.Monads._to._.Arrows.Science._of._.Programming._37%281%29%2C._pp..._67--1111991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F.S0167642399000234%29" class="AutobibLink" data-pltdoc="x">Hughes</a>&nbsp;[<a href="#%28autobib._.John._.Hughes.Generalising._.Monads._to._.Arrows.Science._of._.Programming._37%281%29%2C._pp..._67--1111991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F.S0167642399000234%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> developed the notion of
Arrows, a restricted computational model consisting of reified functions joined
together by combinators. <span class="Autobibref"><a href="#%28autobib._.Henrik._.Nilsson%2C._.Antony._.Courtney%2C._and._.John._.Peterson.Functional._.Reactive._.Programming%2C._.Continued.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._51--642002https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F581690..581695%29" class="AutobibLink" data-pltdoc="x">Nilsson et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Henrik._.Nilsson%2C._.Antony._.Courtney%2C._and._.John._.Peterson.Functional._.Reactive._.Programming%2C._.Continued.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._51--642002https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F581690..581695%29" class="AutobibLink" data-pltdoc="x">2002</a>]</span> made use of Hughes&rsquo;s Arrows to present
an &ldquo;arrowized&rdquo; version of FRP. This revised semantics allowed for dynamically
switching dataflow graph structure without losing space bounds.</p><p>Early work on FRP rested on the implicit assumption that a call-by-need
semantics was needed to program in this manner. <span class="Autobibref"><a href="#%28autobib._.Gregory._.H..._.Cooper._and._.Shriram._.Krishnamurthi.Embedding._.Dynamic._.Dataflow._in._a._.Call-by-.Value._.Language.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._294--3082006https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F11693024_20%29" class="AutobibLink" data-pltdoc="x">Cooper and Krishnamurthi</a>&nbsp;[<a href="#%28autobib._.Gregory._.H..._.Cooper._and._.Shriram._.Krishnamurthi.Embedding._.Dynamic._.Dataflow._in._a._.Call-by-.Value._.Language.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._294--3082006https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F11693024_20%29" class="AutobibLink" data-pltdoc="x">2006</a>]</span> showed the
independence of FRP from call-by-need and in the process exposed the fundamental
implementation principles of graph-based re-computation in a higher-order
world. This work inspired implementation of Flapjax<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Leo._.A..._.Meyerovich%2C._.Arjun._.Guha%2C._.Jacob._.Baskin%2C._.Gregory._.H..._.Cooper%2C._.Michael._.Greenberg%2C._.Aleks._.Bromfield%2C._and._.Shriram._.Krishnamurthi.Flapjax~3a._.A._.Programming._.Language._for._.Ajax._.Applications.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._1--122009https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F1639949..1640091%29" class="AutobibLink" data-pltdoc="x">Meyerovich et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Leo._.A..._.Meyerovich%2C._.Arjun._.Guha%2C._.Jacob._.Baskin%2C._.Gregory._.H..._.Cooper%2C._.Michael._.Greenberg%2C._.Aleks._.Bromfield%2C._and._.Shriram._.Krishnamurthi.Flapjax~3a._.A._.Programming._.Language._for._.Ajax._.Applications.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._1--122009https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F1639949..1640091%29" class="AutobibLink" data-pltdoc="x">2009</a>]</span> and
Elm<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Evan._.Czaplicki._and._.Stephen._.Chong.Asynchronous._.Functional._.Reactive._.Programming._for._.Guis.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122013https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2499370..2462161%29" class="AutobibLink" data-pltdoc="x">Czaplicki and Chong</a> <a href="#%28autobib._.Evan._.Czaplicki._and._.Stephen._.Chong.Asynchronous._.Functional._.Reactive._.Programming._for._.Guis.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122013https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F2499370..2462161%29" class="AutobibLink" data-pltdoc="x">2013</a>]</span>, a practical FRP language for building Web pages.</p><h3><a name="(part._16)"></a>Tracing JIT Compilation</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Emily Herbert</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="16.pdf">12 Mar 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Over the past two decades, the use and study of <span class="emph">just-in-time</span> (JIT)
compilers have overtaken the one of <span class="emph">ahead-of-time</span> (AOT) compilers. Within
the family of JIT compilers, the <span class="emph">tracing</span> variant has come to dominate the
field. Roughly speaking, a tracing JIT compiler identifies repeatedly executed
traces of instructions and compiles those.</p><p><span class="Autobibref"><a href="#%28autobib._.John._.Mc.Carthy.Recursive._functions._of._symbolic._expressions._and._their._computation._by._machine%2C._.Part._.I.Communications._of._the._.A.C.M._4%283%29%2C._pp..._182--2001960https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F367177..367199%29" class="AutobibLink" data-pltdoc="x">McCarthy</a>&nbsp;[<a href="#%28autobib._.John._.Mc.Carthy.Recursive._functions._of._symbolic._expressions._and._their._computation._by._machine%2C._.Part._.I.Communications._of._the._.A.C.M._4%283%29%2C._pp..._182--2001960https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F367177..367199%29" class="AutobibLink" data-pltdoc="x">1960</a>]</span> hinted at the basic idea of JIT compilation in the context
of LISP, which came with an implementation that allowed programmers to
selectively compile certain functions to machine language and stored in
core memory.  Ungar&rsquo;s Self project&#8212;<wbr></wbr>a prototype-oriented language, with strong
influences on JavaScript&#8212;<wbr></wbr>pushed JIT compilation in the late
1980&#8217;s<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Craig._.Chambers._and._.David._.Ungar.Customization~3a._.Optimizing._compiler._technology._for._.S.E.L.F%2C._a._dynamically-typed._object-oriented._programming._language.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._146--1601989https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F74818..74831~3fcasa_token~3d.Wh.Au8y.Q4.Uac.A.A.A.A.A~3ao.I.G.Vyvk.Q1.S.J.Ap.Njzq.R6l.Nl9.Hi.P.T.B3bmqgc80hwh.A75.Ql.H.Ue.Kxv.Qa8h6.K.F.A.Aork2n3.U.Sbv.M1e.Dq.Qk%29" class="AutobibLink" data-pltdoc="x">Chambers and Ungar</a> <a href="#%28autobib._.Craig._.Chambers._and._.David._.Ungar.Customization~3a._.Optimizing._compiler._technology._for._.S.E.L.F%2C._a._dynamically-typed._object-oriented._programming._language.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._146--1601989https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F74818..74831~3fcasa_token~3d.Wh.Au8y.Q4.Uac.A.A.A.A.A~3ao.I.G.Vyvk.Q1.S.J.Ap.Njzq.R6l.Nl9.Hi.P.T.B3bmqgc80hwh.A75.Ql.H.Ue.Kxv.Qa8h6.K.F.A.Aork2n3.U.Sbv.M1e.Dq.Qk%29" class="AutobibLink" data-pltdoc="x">1989</a>]</span>. This Self compiler generated machine code on demand and
cached it for later use. While the work on Self came to a halt in 1998 when Sun
abandoned the language in favor of Java, <span class="Autobibref"><a href="#%28autobib._.T..._.Cramer%2C._.R..._.Friedman%2C._.T..._.Miller%2C._.D..._.Seberger%2C._.R..._.Wilson%2C._and._.M..._.Wolczko.Compiling._.Java._just._in._time.I.E.E.E._.Micro._17%283%29%2C._pp..._36--431997https~3a%2F%2Fieeexplore..ieee..org%2Fabstract%2Fdocument%2F591653~3fcasa_token~3dtm.R9a1.F.E.Uag.A.A.A.A.A~3a.R.B.Iu.T.B.P.C.W.Zbr3.Z.Njn.Q9ae7m.Q4.V96awrawfn.Xgmx.I_.U.Bc.X.Li.Q.T.Ea.T.Wq.Y5.Y4p5.X.B.T580.J.W4rn.Z.Zw%29" class="AutobibLink" data-pltdoc="x">Cramer et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.T..._.Cramer%2C._.R..._.Friedman%2C._.T..._.Miller%2C._.D..._.Seberger%2C._.R..._.Wilson%2C._and._.M..._.Wolczko.Compiling._.Java._just._in._time.I.E.E.E._.Micro._17%283%29%2C._pp..._36--431997https~3a%2F%2Fieeexplore..ieee..org%2Fabstract%2Fdocument%2F591653~3fcasa_token~3dtm.R9a1.F.E.Uag.A.A.A.A.A~3a.R.B.Iu.T.B.P.C.W.Zbr3.Z.Njn.Q9ae7m.Q4.V96awrawfn.Xgmx.I_.U.Bc.X.Li.Q.T.Ea.T.Wq.Y5.Y4p5.X.B.T580.J.W4rn.Z.Zw%29" class="AutobibLink" data-pltdoc="x">1997</a>]</span> transferred the
JIT compilation technology to a compiler for the new language.</p><p>Tracing JIT&#8217;s began to take shape a little bit later when <span class="Autobibref"><a href="#%28autobib._.V..._.Bala%2C._.E..._.Duesterwald%2C._and._.S..._.Banerjia.Dynamo~3a._.A._transparent._dynamic._optimization._system.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122000https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F349299..349303~3fcasa_token~3db.Z1.C.V.J8l.M14.A.A.A.A.A~3a.G.Ly.Sa.D-.V.Hi81rfdm5.Lm.M.Gn4b.Zu.Xd.Bm.F.N.J.L.Eaw.Y.Dmkx3.Z8z.X.V5.G-d.Yya.H.Bh_.Qul3o70xha9kcjkb.O%29" class="AutobibLink" data-pltdoc="x">Bala et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.V..._.Bala%2C._.E..._.Duesterwald%2C._and._.S..._.Banerjia.Dynamo~3a._.A._transparent._dynamic._optimization._system.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122000https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F349299..349303~3fcasa_token~3db.Z1.C.V.J8l.M14.A.A.A.A.A~3a.G.Ly.Sa.D-.V.Hi81rfdm5.Lm.M.Gn4b.Zu.Xd.Bm.F.N.J.L.Eaw.Y.Dmkx3.Z8z.X.V5.G-d.Yya.H.Bh_.Qul3o70xha9kcjkb.O%29" class="AutobibLink" data-pltdoc="x">2000</a>]</span>
developed Dynamo, a system that applied JIT optimizations to machine code. To
this end, they borrowed the concept of an &ldquo;execution trace&rdquo; from systems
work. Inspired by Dynamo, <span class="Autobibref"><a href="#%28autobib._.A..._.Gal%2C._.C...W..._.Probst%2C._and._.M..._.Franz._.Hotpath.V.M~3a._.An._effective._.J.I.T._compiler._for._resource-constrained._devices.In._.Proc..._.International._.Conference._on._.Virtual._.Execution._.Environments%2C._pp..._144--1532006https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1134760..1134780~3fcasa_token~3d.Td.T.Xla.S.K.Y.Og.A.A.A.A.A~3a.Xm7.Y.U.Lv.S.Zsv.Wuzlyn.Ko.Dm8_.Kbno.Q2kndd.X.Nuy-9p.U.Hvpm.X.Wfe0.E5vt.Pd.Xn.Rx.Tgal.U.I.D.L.R.Siq.M.Am.Y%29" class="AutobibLink" data-pltdoc="x">Gal et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.A..._.Gal%2C._.C...W..._.Probst%2C._and._.M..._.Franz._.Hotpath.V.M~3a._.An._effective._.J.I.T._compiler._for._resource-constrained._devices.In._.Proc..._.International._.Conference._on._.Virtual._.Execution._.Environments%2C._pp..._144--1532006https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1134760..1134780~3fcasa_token~3d.Td.T.Xla.S.K.Y.Og.A.A.A.A.A~3a.Xm7.Y.U.Lv.S.Zsv.Wuzlyn.Ko.Dm8_.Kbno.Q2kndd.X.Nuy-9p.U.Hvpm.X.Wfe0.E5vt.Pd.Xn.Rx.Tgal.U.I.D.L.R.Siq.M.Am.Y%29" class="AutobibLink" data-pltdoc="x">2006</a>]</span> introduced the &ldquo;trace tree&rdquo; concept
for a Java compiler. This work became the gateway to modern systems such as the
TraceMonkey JavaScript engine<span class="Autobibref">&nbsp;[<a href="#%28autobib._.A..._.Gal%2C._.B..._.Eich%2C._.M..._.Shaver%2C._.D..._.Mandelin%2C._.D..._.Anderson%2C._.M..._.R..._.Haghighat%2C._.B..._.Kaplan%2C._.G..._.Hoare%2C._.B..._.Zbarsky%2C._.J..._.Orendorff%2C._and._.J..._.Ruderman.Trace-based._just-in-time._type._specialization._for._dynamic._languages.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._465--4782009https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1543135..1542528~3fcasa_token~3dt.Zl.Pv.Nce.V.D.Y.A.A.A.A.A~3a.C.B5.H.Kjaq.A1v.K.Ji.V0j.Ac.A8r.Gz.Z2.Jb_p.Lgh.Il.Fwqht.Neb-.Jp.Qu.A0-.K0fd_1.Ypbtpy.Oc.X.Fr.Qki.D.Rlsh%29" class="AutobibLink" data-pltdoc="x">Gal et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.A..._.Gal%2C._.B..._.Eich%2C._.M..._.Shaver%2C._.D..._.Mandelin%2C._.D..._.Anderson%2C._.M..._.R..._.Haghighat%2C._.B..._.Kaplan%2C._.G..._.Hoare%2C._.B..._.Zbarsky%2C._.J..._.Orendorff%2C._and._.J..._.Ruderman.Trace-based._just-in-time._type._specialization._for._dynamic._languages.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._465--4782009https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1543135..1542528~3fcasa_token~3dt.Zl.Pv.Nce.V.D.Y.A.A.A.A.A~3a.C.B5.H.Kjaq.A1v.K.Ji.V0j.Ac.A8r.Gz.Z2.Jb_p.Lgh.Il.Fwqht.Neb-.Jp.Qu.A0-.K0fd_1.Ypbtpy.Oc.X.Fr.Qki.D.Rlsh%29" class="AutobibLink" data-pltdoc="x">2009</a>]</span>, PyPy for Python<span class="Autobibref">&nbsp;[<a href="#%28autobib._.C...F..._.Bolz%2C._.A..._.Cuni%2C._.M..._.Fijalkowski%2C._and._.A..._.Rigo.Tracing._the._meta-level~3a._.Py.Py%27s._tracing._.J.I.T._compiler.In._.Proc..._.Workshop._on._the._.Implementation%2C._.Compilation%2C._.Optimization._of._.Object-.Oriented._.Languages~0a._._and._.Programming._.Systems%2C._pp..._18--252009https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1565824..1565827~3fcasa_token~3d9.N.F.Fn.O.M4.Ip.I.A.A.A.A.A~3agm.T.Z6_.Sj.K.X.R.Y.Bqyz.Qqr.A.O.R2.X.Nx.Y.F.N.Szj9.T.T.Js.E.R.Bj.Q.Y.H.Q9.R.Wd.N.Ih-8w-8.Rjix.An.F.O.B.Td.Mj.E.S_.E.K.B%29" class="AutobibLink" data-pltdoc="x">Bolz et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.C...F..._.Bolz%2C._.A..._.Cuni%2C._.M..._.Fijalkowski%2C._and._.A..._.Rigo.Tracing._the._meta-level~3a._.Py.Py%27s._tracing._.J.I.T._compiler.In._.Proc..._.Workshop._on._the._.Implementation%2C._.Compilation%2C._.Optimization._of._.Object-.Oriented._.Languages~0a._._and._.Programming._.Systems%2C._pp..._18--252009https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1565824..1565827~3fcasa_token~3d9.N.F.Fn.O.M4.Ip.I.A.A.A.A.A~3agm.T.Z6_.Sj.K.X.R.Y.Bqyz.Qqr.A.O.R2.X.Nx.Y.F.N.Szj9.T.T.Js.E.R.Bj.Q.Y.H.Q9.R.Wd.N.Ih-8w-8.Rjix.An.F.O.B.Td.Mj.E.S_.E.K.B%29" class="AutobibLink" data-pltdoc="x">2009</a>]</span>, SPUR
for CIL<span class="Autobibref">&nbsp;[<a href="#%28autobib._.M..._.Bebenita%2C._.F..._.Brandner%2C._.M..._.Fahndrich%2C._.F..._.Logozzo%2C._.W..._.Schulte%2C._.N..._.Tillmann%2C._and._.H..._.Venter.S.P.U.R~3a._a._trace-based._.J.I.T._compiler._for._.C.I.L.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._708--7252010https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1869459..1869517~3fcasa_token~3dkeltm8w.Z.O7.Y.A.A.A.A.A~3alozbw.S5.H2o.F.Z_.Zm.X9xno.F1i.J.J3.Whu.J.H.Pi-v.Sc3.Vxwye.Y.Ftk2g.Mvyd.Xw1a.Knjt28.N.Xgc6pxyt.X.T07%29" class="AutobibLink" data-pltdoc="x">Bebenita et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.M..._.Bebenita%2C._.F..._.Brandner%2C._.M..._.Fahndrich%2C._.F..._.Logozzo%2C._.W..._.Schulte%2C._.N..._.Tillmann%2C._and._.H..._.Venter.S.P.U.R~3a._a._trace-based._.J.I.T._compiler._for._.C.I.L.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages._and._.Applications%2C._pp..._708--7252010https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1869459..1869517~3fcasa_token~3dkeltm8w.Z.O7.Y.A.A.A.A.A~3alozbw.S5.H2o.F.Z_.Zm.X9xno.F1i.J.J3.Whu.J.H.Pi-v.Sc3.Vxwye.Y.Ftk2g.Mvyd.Xw1a.Knjt28.N.Xgc6pxyt.X.T07%29" class="AutobibLink" data-pltdoc="x">2010</a>]</span>, and more recently a PHP 8 JIT compiler.</p><h3><a name="(part._17)"></a>Meetings</h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 16 Mar 2021</p></blockquote></blockquote></blockquote><p>I will meet with every PhD student 1-1 to discuss the submitted reading list for the
second topic. Here is the schedule:</p><blockquote><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>time</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>student</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>topic</p></td></tr><tr><td valign="top"><p>09:50am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Olek</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Logical Relations</p></td></tr><tr><td valign="top"><p>10:05am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Jared</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Compiler Intermediate Forms</p></td></tr><tr><td valign="top"><p>10:20am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Andrew</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Designing Multi-Language Systems</p></td></tr><tr><td valign="top"><p>10:35am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Donald</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>ML Modules</p></td></tr><tr><td valign="top"><p>10:50am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Emily</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Visual Teaching Languages</p></td></tr><tr><td valign="top"><p>11:05am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Lucy</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>The Evolution of Dependent Types</p></td></tr><tr><td valign="top"><p>11:20am</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p> Ankit</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>The Implementation of Depdenent-Type Proof Systems</p></td></tr></table></blockquote><p>The primary goal of this meeting is to asses the reading list and theme within
the topic, and to prune the list where possible.</p><h3><a name="(part._18)"></a>Programming Languages and Operating Systems</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Lucy Amidon</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 19 Mar 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>In 2021, three similar operating systems dominate the general-purpose
market. They imply a common set of abstractions that an operating system
supplies in order to allow convenient and multiplexed access to hardware.  On
top of these abstractions, programming language runtimes implement their own
abstractions. Throughout the history of languages and operating systems,
however, there have been many attempts to unify these two layers, reducing the
friction sometimes caused by the impedance mismatches between them.</p><p>The LISP Machine<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Alan._.Bawden%2C._.Richard._.Greenblatt%2C._.Jack._.Holloway%2C._.Thomas._.Knight%2C._.David._.Moon%2C._and._.Daniel._.Weinreb.Lisp._.Machine._.Progress._.Report.Massachusetts._.Institute._of._.Technology..%2C._.A.I._.Memo._.No..._4441977http~3a%2F%2Fdspace..mit..edu%2Fbitstream%2Fhandle%2F1721..1%2F5751%2F.A.I.M-444..pdf~3fsequence~3d2~26is.Allowed~3dy%29" class="AutobibLink" data-pltdoc="x">Bawden et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Alan._.Bawden%2C._.Richard._.Greenblatt%2C._.Jack._.Holloway%2C._.Thomas._.Knight%2C._.David._.Moon%2C._and._.Daniel._.Weinreb.Lisp._.Machine._.Progress._.Report.Massachusetts._.Institute._of._.Technology..%2C._.A.I._.Memo._.No..._4441977http~3a%2F%2Fdspace..mit..edu%2Fbitstream%2Fhandle%2F1721..1%2F5751%2F.A.I.M-444..pdf~3fsequence~3d2~26is.Allowed~3dy%29" class="AutobibLink" data-pltdoc="x">1977</a>]</span> is one of the earliest and most famous
examples of a system that unified language and &ldquo;operating-system&rdquo;
abstractions. As the name said, LISP machines famously used special-purpose
hardware optimized for executing LISP, which, at the time, was a necessity to
enable reasonable performance. At the same time, two alternative projects with
similar goals emerged at the Xerox Palo Alto Research Center:
Smalltalk<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Daniel._.H..._.H..._.Ingalls.Design._.Principles._.Behind._.Smalltalk.University._of._.Virginia..%2C._.C.S655~3a._.Programming._.Languages2001https~3a%2F%2Fwww..cs..virginia..edu%2F~7eevans%2Fcs655%2Freadings%2Fsmalltalk..html%29" class="AutobibLink" data-pltdoc="x">Ingalls</a> <a href="#%28autobib._.Daniel._.H..._.H..._.Ingalls.Design._.Principles._.Behind._.Smalltalk.University._of._.Virginia..%2C._.C.S655~3a._.Programming._.Languages2001https~3a%2F%2Fwww..cs..virginia..edu%2F~7eevans%2Fcs655%2Freadings%2Fsmalltalk..html%29" class="AutobibLink" data-pltdoc="x">2001</a>, <a href="#%28autobib._.Daniel._.H..._.H..._.Ingalls.The._evolution._of._.Smalltalk~3a._from._.Smalltalk-72._through._.Squeak.In._.Proc..._.History._of._.Programming._.Languages._.I.V2021https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F3386335%29" class="AutobibLink" data-pltdoc="x">2021</a>]</span>, created by language designers, and
Pilot<span class="Autobibref">&nbsp;[<a href="#%28autobib._.David._.D..._.Redell%2C._.Dalal%2C._.Yogen._.K..%2C._.Horsley%2C._.Thomas._.R..%2C._.Lauer%2C._.Hugh._.C..%2C._.Lynch%2C._.William._.C..%2C._.Mc.Jones%2C._.Paul._.R..%2C._.Murray%2C._.Hal._.G..%2C._and._.Purcell%2C._.Stephen._.C...Pilot~3a._.An._.Operating._.System._for._a._.Personal._.Computer.Communications._of._the._.A.C.M._23%282%29%2C._pp..._81--921980https~3a%2F%2Fdoi..org%2F10..1145%2F358818..358822%29" class="AutobibLink" data-pltdoc="x">Redell et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.David._.D..._.Redell%2C._.Dalal%2C._.Yogen._.K..%2C._.Horsley%2C._.Thomas._.R..%2C._.Lauer%2C._.Hugh._.C..%2C._.Lynch%2C._.William._.C..%2C._.Mc.Jones%2C._.Paul._.R..%2C._.Murray%2C._.Hal._.G..%2C._and._.Purcell%2C._.Stephen._.C...Pilot~3a._.An._.Operating._.System._for._a._.Personal._.Computer.Communications._of._the._.A.C.M._23%282%29%2C._pp..._81--921980https~3a%2F%2Fdoi..org%2F10..1145%2F358818..358822%29" class="AutobibLink" data-pltdoc="x">1980</a>]</span>, created by systems designers.  Pilot introduced the idea of
providing modularized, standardized, interfaces to the &ldquo;operating-system&rdquo;
components of the runtime, as well as using the properties of the language for
some process protection<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Butler._.W..._.Lampson.Protection.Oper..._.Syst..._.Rev..%2C._pp..._18--241974~7bhttps~3a%2F%2Fdoi..org%2F10..1145%2F775265..775268~7d%29" class="AutobibLink" data-pltdoc="x">Lampson</a> <a href="#%28autobib._.Butler._.W..._.Lampson.Protection.Oper..._.Syst..._.Rev..%2C._pp..._18--241974~7bhttps~3a%2F%2Fdoi..org%2F10..1145%2F775265..775268~7d%29" class="AutobibLink" data-pltdoc="x">1974</a>]</span>. Oberon is yet another &ldquo;languages as
operating systems&rdquo; project from this era<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Niklaus._.Wirth._and._.Ju~cc~88rg._.Gutknecht.Project._.Oberon~3a._.The._.Design._of._an._.Operating._.System._and._.Compiler.A.C.M._.Press1991https~3a%2F%2Fpeople..inf..ethz..ch%2Fwirth%2F.Project.Oberon%2F.P.O...System..pdf%29" class="AutobibLink" data-pltdoc="x">Wirth and Gutknecht</a> <a href="#%28autobib._.Niklaus._.Wirth._and._.Ju~cc~88rg._.Gutknecht.Project._.Oberon~3a._.The._.Design._of._an._.Operating._.System._and._.Compiler.A.C.M._.Press1991https~3a%2F%2Fpeople..inf..ethz..ch%2Fwirth%2F.Project.Oberon%2F.P.O...System..pdf%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> that focused on
language-level protection and component boundaries.</p><p><div class="SIntrapara">While the research area went dormant for almost two decades, its resurrection in
the late 1990s caused system researchers to think of their area as
&ldquo;irrelevant&rdquo; as Rob Pike so memorably wrote in a widely discussed blog
post<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Rob._.Pike.Systems._.Software._.Research._is._.Irrelevant.Bell._.Labs%2C._.Lucent._.Technologies..%2C._.A._.Plan._9._.Polemic2000https~3a%2F%2Ftianyin..github..io%2Fmisc%2Firrelevant..pdf%29" class="AutobibLink" data-pltdoc="x">Pike</a> <a href="#%28autobib._.Rob._.Pike.Systems._.Software._.Research._is._.Irrelevant.Bell._.Labs%2C._.Lucent._.Technologies..%2C._.A._.Plan._9._.Polemic2000https~3a%2F%2Ftianyin..github..io%2Fmisc%2Firrelevant..pdf%29" class="AutobibLink" data-pltdoc="x">2000</a>]</span>. The focus of these new language-based projects was
mostly linguistically-enforced <span class="emph">safety</span>:
</div><div class="SIntrapara"><ul><li><p><span class="Autobibref"><a href="#%28autobib._.Brian._.Bershad%2C._.Savage%2C._.S..%2C._.Pardyak%2C._.P..%2C._.Sirer%2C._.E..._.G..%2C._.Fiuczynski%2C._.M..._.E..%2C._.Becker%2C._.D..%2C._.Chambers%2C._.C..%2C._and._.Eggers%2C._.S...Extensibility._.Safety._and._.Performance._in._the._.S.P.I.N._.Operating._.System.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles%2C._pp..._267--2831995https~3a%2F%2Fdoi..org%2F10..1145%2F224056..224077%29" class="AutobibLink" data-pltdoc="x">Bershad et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Brian._.Bershad%2C._.Savage%2C._.S..%2C._.Pardyak%2C._.P..%2C._.Sirer%2C._.E..._.G..%2C._.Fiuczynski%2C._.M..._.E..%2C._.Becker%2C._.D..%2C._.Chambers%2C._.C..%2C._and._.Eggers%2C._.S...Extensibility._.Safety._and._.Performance._in._the._.S.P.I.N._.Operating._.System.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles%2C._pp..._267--2831995https~3a%2F%2Fdoi..org%2F10..1145%2F224056..224077%29" class="AutobibLink" data-pltdoc="x">1995</a>]</span> used the the properties of the Modula-3 compiler and
runtime system to enable loading &ldquo;untrusted&rdquo; kernel extensions.  Active
research on this idea continues to tihs day, with a focus of using
language-based systems for a purpose akin to kernel extensions in very small
computers discussed<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Amit._.Levy%2C._.Campbell%2C._.Bradford%2C._.Ghena%2C._.Branden%2C._.Giffin%2C._.Daniel._.B..%2C._.Pannuto%2C._.Pat%2C._.Dutta%2C._.Prabal%2C._and._.Levis%2C._.Philip.Multiprogramming._a._64k.B._.Computer._.Safely._and._.Efficiently.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles%2C._pp..._234--2512017https~3a%2F%2Fdoi..org%2F10..1145%2F3132747..3132786%29" class="AutobibLink" data-pltdoc="x">Levy et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Amit._.Levy%2C._.Campbell%2C._.Bradford%2C._.Ghena%2C._.Branden%2C._.Giffin%2C._.Daniel._.B..%2C._.Pannuto%2C._.Pat%2C._.Dutta%2C._.Prabal%2C._and._.Levis%2C._.Philip.Multiprogramming._a._64k.B._.Computer._.Safely._and._.Efficiently.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles%2C._pp..._234--2512017https~3a%2F%2Fdoi..org%2F10..1145%2F3132747..3132786%29" class="AutobibLink" data-pltdoc="x">2017</a>]</span>. </p></li><li><p><span class="Autobibref"><a href="#%28autobib._.Matthew._.Flatt%2C._.Robert._.Bruce._.Findler%2C._.Shriram._.Krishnamurthi%2C._and._.Matthias._.Felleisen.Programming._.Languages._as._.Operating._.Systems._%28or._.Revenge._of._the._.Son._of._the._.Lisp._.Machine%29.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._138--1471999https~3a%2F%2Fdoi..org%2F10..1145%2F317636..317793%29" class="AutobibLink" data-pltdoc="x">Flatt et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Matthew._.Flatt%2C._.Robert._.Bruce._.Findler%2C._.Shriram._.Krishnamurthi%2C._and._.Matthias._.Felleisen.Programming._.Languages._as._.Operating._.Systems._%28or._.Revenge._of._the._.Son._of._the._.Lisp._.Machine%29.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._138--1471999https~3a%2F%2Fdoi..org%2F10..1145%2F317636..317793%29" class="AutobibLink" data-pltdoc="x">1999</a>]</span> introduced concepts surrounding scheduling and protection
to the world of LISP, allowing safety mechanisms for resource sharing&#8212;<wbr></wbr>traditionally the
domain of &ldquo;real operating systems&rdquo;&#8212;<wbr></wbr>to be expressed inside a language,
expressing the last major operating system abstraction
intralinguistically.</p></li><li><p><span class="Autobibref"><a href="#%28autobib._.Galen._.Hunt._and._.James._.Larus.Singularity~3a._.Rethinking._the._.Software._.Stack.Oper..._.Syst..._.Rev..%2C._pp..._37--492007https~3a%2F%2Fdoi..org%2F10..1145%2F1243418..1243424%29" class="AutobibLink" data-pltdoc="x">Hunt and Larus</a>&nbsp;[<a href="#%28autobib._.Galen._.Hunt._and._.James._.Larus.Singularity~3a._.Rethinking._the._.Software._.Stack.Oper..._.Syst..._.Rev..%2C._pp..._37--492007https~3a%2F%2Fdoi..org%2F10..1145%2F1243418..1243424%29" class="AutobibLink" data-pltdoc="x">2007</a>]</span> developed a prototype of a complete general-purpose
operating system that used linguistic mechanisms and static analysis to enforce
safety and safe communication.</p></li></ul></div></p><h3><a name="(part._19)"></a>Array Programming Languages</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Ankit Kumar</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><a href="19.pdf">23 Mar 2021</a></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>In 1957, Kenneth E. Iverson developed a mathematical notation to describe
numerical processing for his courses at Harvard. The notation was implemented as
the APL language during his time at IBM in 1965<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Kenneth._.E..._.Iverson.A._.Programming._.Language.John._.Wiley._~26._.Sons1962https~3a%2F%2Fwww..jsoftware..com%2Fpapers%2F.A.P.L..htm%29" class="AutobibLink" data-pltdoc="x">Iverson</a> <a href="#%28autobib._.Kenneth._.E..._.Iverson.A._.Programming._.Language.John._.Wiley._~26._.Sons1962https~3a%2F%2Fwww..jsoftware..com%2Fpapers%2F.A.P.L..htm%29" class="AutobibLink" data-pltdoc="x">1962</a>]</span>.</p><p>APL, mostly known now for its distinct character set for mathematical
operations, supports primitives for manipulating matrices of any rank, so-called
rank polymorphism, also known as &ldquo;implicit scaling.&rdquo; APL operators deal with
large multi-dimensional data as a unit, which allows the language to get rid of
explicit control flow structures such as iteration or recursion (for many
classes of programs). They also eliminate the conventional von Neunmann view of
processing one word of data at a time.</p><p><div class="SIntrapara">Rank polymorphism relies on an ad-hoc semantics and a complex implementation. To
eliminate some of this complexity, only APL&rsquo;s built-in operators scale. But,
with the introduction of nested arrays, it becomes difficult to control the
grain of scaling. Two research projects address this problem in two
different ways:
</div><div class="SIntrapara"><ul><li><p><span class="Autobibref"><a href="#%28autobib._.Satish._.Thatte.A._.Type._.System._for._.Implicit._.Scaling.Science._of._.Computer._.Programming._17%281%29%2C._pp..._217--2451991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0167642391900405%29" class="AutobibLink" data-pltdoc="x">Thatte</a>&nbsp;[<a href="#%28autobib._.Satish._.Thatte.A._.Type._.System._for._.Implicit._.Scaling.Science._of._.Computer._.Programming._17%281%29%2C._pp..._217--2451991https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0167642391900405%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> introduces a coercion-based semantics for implicit
scaling, based on simple structural subtyping rules. This approach pragmatically
eliminates ambiguities in a large class of programs.</p></li><li><p><span class="Autobibref"><a href="#%28autobib._.C..._.Barry._.Jay.A._.Semantics._for._.Shape.Science._of._.Computer._.Programming._25%282%29%2C._pp..._251--2831995https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0167642395000151%2F%29" class="AutobibLink" data-pltdoc="x">Jay</a>&nbsp;[<a href="#%28autobib._.C..._.Barry._.Jay.A._.Semantics._for._.Shape.Science._of._.Computer._.Programming._25%282%29%2C._pp..._251--2831995https~3a%2F%2Fwww..sciencedirect..com%2Fscience%2Farticle%2Fpii%2F0167642395000151%2F%29" class="AutobibLink" data-pltdoc="x">1995</a>]</span> develops shape polymorphism and its semantics. This
framework allows the parameterization of user-defined functions over &ldquo;shapes,&rdquo;
but the shape of the result may depend only on the shape of the input(s) not
their element type. While this framework supports the detection of shape errors
at compile time, the class of programs benefitting from this technique is rather
limited.</p></li></ul></div><div class="SIntrapara">Modern Haskell accommodates various forms of shape polymorphism for arrays
through the use of type classes and type
families<span class="Autobibref">&nbsp;[<a href="#%28autobib._.G..._.Keller%2C._.M..._.Chakravarty%2C._.R..._.Leshchinskiy%2C._.S..._.Peyton._.Jones%2C._and._.B..._.Lippmeier.Regular%2C._.Shape-.Polymorphic%2C._.Parallel._.Arrays._in._.Haskell.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._261--2722010https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1863543..1863582%29" class="AutobibLink" data-pltdoc="x">Keller et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.G..._.Keller%2C._.M..._.Chakravarty%2C._.R..._.Leshchinskiy%2C._.S..._.Peyton._.Jones%2C._and._.B..._.Lippmeier.Regular%2C._.Shape-.Polymorphic%2C._.Parallel._.Arrays._in._.Haskell.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming%2C._pp..._261--2722010https~3a%2F%2Fdl..acm..org%2Fdoi%2Fabs%2F10..1145%2F1863543..1863582%29" class="AutobibLink" data-pltdoc="x">2010</a>]</span>. However, this
implementation retains Barry&rsquo;s restriction on shape polymorphism.</div></p><p>Remora<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Justin._.Slepak%2C._.Olin._.Shivers%2C._and._.Panagiotis._.Manolios.An._.Array-.Oriented._.Language._with._.Static._.Rank._.Polymorphism.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._27--462014https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F978-3-642-54833-8_3%29" class="AutobibLink" data-pltdoc="x">Slepak et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Justin._.Slepak%2C._.Olin._.Shivers%2C._and._.Panagiotis._.Manolios.An._.Array-.Oriented._.Language._with._.Static._.Rank._.Polymorphism.In._.Proc..._.European._.Symposium._on._on._.Programming%2C._pp..._27--462014https~3a%2F%2Flink..springer..com%2Fchapter%2F10..1007%2F978-3-642-54833-8_3%29" class="AutobibLink" data-pltdoc="x">2014</a>]</span> is the first theoretical framework to overcome some of
these limitations. In particular, it is expressive enough to describe array
computations whose dimensions cannot be determined statically.</p><h3><a name="(part._20)"></a>Relational Programming</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Helena Dworak</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 26 Mar 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>Relational programming seeks to remedy the un-logical, or the coined-term
"extralogical", features that plague logic programming. Relational programming
languages, such as miniKanren, evolved from the unresolved guarantees of logic
languages or, more specifically, Prolog.</p><p>Like many language developments outside the mainstream, classical AI,
specifically natural-language, inspired the creation of the first logic
programming languages. More generally, though, logic programming promised an
intriguing new method of solving computational problems: describe the problem,
and let the &ldquo;computer&rdquo; figure out how to find the
solution<span class="Autobibref">&nbsp;[<a href="#%28autobib._.M..._.H..._.Van._.Emden._and._.R..._.A..._.Kowalski.The._.Semantics._of._.Predicate._.Logic._as._a._.Programming._.Language.Journal._of._the._.A.C.M._23%284%29%2C._pp..._733--7421976https~3a%2F%2Fdoi..org%2F10..1145%2F321978..321991%29" class="AutobibLink" data-pltdoc="x">Emden and Kowalski</a> <a href="#%28autobib._.M..._.H..._.Van._.Emden._and._.R..._.A..._.Kowalski.The._.Semantics._of._.Predicate._.Logic._as._a._.Programming._.Language.Journal._of._the._.A.C.M._23%284%29%2C._pp..._733--7421976https~3a%2F%2Fdoi..org%2F10..1145%2F321978..321991%29" class="AutobibLink" data-pltdoc="x">1976</a>; <a href="#%28autobib._.Robert._.A..._.Kowalski.Predicate._.Logic._as._.Programming._.Language.In._.Proc..._.Information._.Processing%2C._.Proceedings._of._the._6th._~7b.I.F.I.P~7d._.Congress%2C._pp..._569--5741974http~3a%2F%2Fwww-public..imtbs-tsp..eu%2F~7egibson%2F.Teaching%2F.Teaching-.Reading.Material%2F.Kowalski74..pdf%29" class="AutobibLink" data-pltdoc="x">Kowalski</a> <a href="#%28autobib._.Robert._.A..._.Kowalski.Predicate._.Logic._as._.Programming._.Language.In._.Proc..._.Information._.Processing%2C._.Proceedings._of._the._6th._~7b.I.F.I.P~7d._.Congress%2C._pp..._569--5741974http~3a%2F%2Fwww-public..imtbs-tsp..eu%2F~7egibson%2F.Teaching%2F.Teaching-.Reading.Material%2F.Kowalski74..pdf%29" class="AutobibLink" data-pltdoc="x">1974</a>]</span>.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">The passive voice of this sentence is the implicit acknowledgment
of Franco-phone researchers that the Brits might just have had something to do
with this story too.</span></span></span></p><p>Prolog, the most well-known logic programming language, was developed in 1971 as
a means to express traditional logic as a grammar. Prolog leverages unification,
a powerful tool that can be thought of as an advanced pattern-matcher, to answer
queries bilaterally<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Alain._.Colmerauer._and._.Philippe._.Roussel.The._.Birth._of._.Prolog.In._.Proc..._.History._of._.Programming._.Languages._.I.I%2C._pp..._331--3671996https~3a%2F%2Fdoi..org%2F10..1145%2F234286..1057820%29" class="AutobibLink" data-pltdoc="x">Colmerauer and Roussel</a> <a href="#%28autobib._.Alain._.Colmerauer._and._.Philippe._.Roussel.The._.Birth._of._.Prolog.In._.Proc..._.History._of._.Programming._.Languages._.I.I%2C._pp..._331--3671996https~3a%2F%2Fdoi..org%2F10..1145%2F234286..1057820%29" class="AutobibLink" data-pltdoc="x">1996</a>]</span>.</p><p>In the early 1980s, Japan launched the Fifth Generation Computer System with the
goal of solving all problems for good. The research team chose Prolog as the
means to accomplish this goal and also as a goal, because they realized that the
existing Prolog language was too weak. The overly ambitious project failed, and
the AI research involving Prolog rapidly began to diminish<span class="Autobibref">&nbsp;[<a href="#%28autobib._.M..._.H..._.Van._.Emden.Who._killed._.Prolog~3f.Van._.Emden%2C._.A._.Programmer%27s._.Place%2C._.Word.Press._.Blog2010https~3a%2F%2Fvanemden..wordpress..com%2F2010%2F08%2F21%2Fwho-killed-prolog%2F%29" class="AutobibLink" data-pltdoc="x">Emden</a> <a href="#%28autobib._.M..._.H..._.Van._.Emden.Who._killed._.Prolog~3f.Van._.Emden%2C._.A._.Programmer%27s._.Place%2C._.Word.Press._.Blog2010https~3a%2F%2Fvanemden..wordpress..com%2F2010%2F08%2F21%2Fwho-killed-prolog%2F%29" class="AutobibLink" data-pltdoc="x">2010</a>]</span>.</p><p>Prolog did not &ldquo;die&rdquo; for its association with a failed project alone. Its
numerous extra-logical facilities&#8212;<wbr></wbr>cut, assert, retract&#8212;<wbr></wbr>caused a deep rift
between theoreticians and practitioners of logic programming<span class="Autobibref">&nbsp;[<a href="#%28autobib._.William._.Byrd.Logic._and._.Relational._.Programming%2C._mini.Kanren.Info.Q%2C._.An._.Interview2014https~3a%2F%2Fwww..infoq..com%2Finterviews%2Fbyrd-relational-programming-minikanren%2F%29" class="AutobibLink" data-pltdoc="x">Byrd</a> <a href="#%28autobib._.William._.Byrd.Logic._and._.Relational._.Programming%2C._mini.Kanren.Info.Q%2C._.An._.Interview2014https~3a%2F%2Fwww..infoq..com%2Finterviews%2Fbyrd-relational-programming-minikanren%2F%29" class="AutobibLink" data-pltdoc="x">2014</a>]</span>.</p><p>The goal of relational programming is the original goal of logic
programming. It restricts any extralogical features abiding strictly to
relations and their conjunctions and disjunctions. Additionally, relational
programming improves upon both the implementation of unification and the
search-and-resolution algorithm found in Prolog. As a result, relational
programming as materialized in miniKanren, allows for powerful and easy
creation of intriguing programming tools: program generation or the generation
of quines and twines<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Daniel._.P..._.Friedman%2C._.William._.E..._.Byrd%2C._.Oleg._.Kiselyov%2C._and._.Jason._.Hemann.The._.Reasoned._.Schemer%2C._2nd._.Edition.M.I.T._.Press2018https~3a%2F%2Fmitpress..mit..edu%2Fbooks%2Freasoned-schemer-second-edition%29" class="AutobibLink" data-pltdoc="x">Friedman et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Daniel._.P..._.Friedman%2C._.William._.E..._.Byrd%2C._.Oleg._.Kiselyov%2C._and._.Jason._.Hemann.The._.Reasoned._.Schemer%2C._2nd._.Edition.M.I.T._.Press2018https~3a%2F%2Fmitpress..mit..edu%2Fbooks%2Freasoned-schemer-second-edition%29" class="AutobibLink" data-pltdoc="x">2018</a>]</span>.</p><h3><a name="(part._21)"></a>How (Not) to Benchmark</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Cameron Moy </p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 30 Mar 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>The history of performance evaluation is the history of doing it
wrong. We developed benchmarks to compare new run-time systems and
compiler optimizations. Those benchmarks were wrong [1,2]. We measured
whether a new technique or technology had a positive impact on
performance. Those measurements were wrong [3]. We developed a
standard set of metrics to report when conducting an experiment. Those
metrics were wrong [4]. We made fundamental assumptions about the
properties of run-time systems and baked those into our
experiments. Those assumptions were wrong [5]. The first step toward
accurate performance evaluation is understanding and rectifying past
mistakes, with an understanding that there are surely more to correct
in the future.</p><p>[1]: Stephen M. Blackburn, Robin Garner, Chris Hoffmann, Asjad M. Khang, Kathryn S. McKinley, Rotem Bentzur, Amer Diwan, Daniel Feinberg, Daniel Frampton, Samuel Z. Guyer, Martin Hirzel, Antony Hosking, Maria Jump, Han Lee, J. Eliot B. Moss, Aashish Phansalkar, Darko Stefanovi&#263;, Thomas VanDrunen, Daniel von Dincklage, and Ben Wiedermann. 2006. The DaCapo benchmarks: java benchmarking development and analysis. In Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications (OOPSLA &rsquo;06). Association for Computing Machinery, New York, NY, USA, 169&#8211;190. DOI:https://doi.org/10.1145/1167473.1167488</p><p>[2]: Gregor Richards, Andreas Gal, Brendan Eich, and Jan Vitek. 2011. Automated construction of JavaScript benchmarks. In Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications (OOPSLA &rsquo;11). Association for Computing Machinery, New York, NY, USA, 677&#8211;694. DOI:https://doi.org/10.1145/2048066.2048119</p><p>[3]: Todd Mytkowicz, Amer Diwan, Matthias Hauswirth, and Peter F. Sweeney. 2009. Producing wrong data without doing anything obviously wrong! In Proceedings of the 14th international conference on Architectural support for programming languages and operating systems (ASPLOS XIV). Association for Computing Machinery, New York, NY, USA, 265&#8211;276. DOI:https://doi.org/10.1145/1508244.1508275</p><p>[4]: Andy Georges, Dries Buytaert, and Lieven Eeckhout. 2007. Statistically rigorous java performance evaluation. In Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems, languages and applications (OOPSLA &rsquo;07). Association for Computing Machinery, New York, NY, USA, 57&#8211;76. DOI:https://doi.org/10.1145/1297027.1297033</p><p>[5]: Edd Barrett, Carl Friedrich Bolz-Tereick, Rebecca Killick, Sarah Mount, and Laurence Tratt. 2017. Virtual machine warmup blows hot and cold. Proc. ACM Program. Lang. 1, OOPSLA, Article 52 (October 2017), 27 pages. DOI:https://doi.org/10.1145/3133876</p><h3><a name="(part._22)"></a>Logical Relations</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Olek Gierczak		</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 2 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._23)"></a>Designing Multi-Language Systems</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Andrew Wagner</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 6 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._24)"></a>Intermediate Compiler Forms for Functional Languages </h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Jared Gentner</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 9 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Recall that this is not true for the equational theory of
<span class="emph">truth</span>.</span></span></span>  In the 1980s, compiler writers thought call-by-value functional
languages were at a disadvantage because the by-value <span class="emph">proof</span> system (&#955;v)
is weaker than the by-name one (&#955;n) on the same syntax.  For programs in
continuation passing style (CPS), the two proof theories coincide<span class="Autobibref">&nbsp;[<a href="#%28autobib._.Godon._.D..._.Plotkin.Call-by-name%2C._call-by-value%2C._and._the._lambda._calculus.Theoretical._.Computer._.Science._1n%2C._pp..._125--1591977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2Fcbn_cbv_lambda..pdf%29" class="AutobibLink" data-pltdoc="x">Plotkin</a> <a href="#%28autobib._.Godon._.D..._.Plotkin.Call-by-name%2C._call-by-value%2C._and._the._lambda._calculus.Theoretical._.Computer._.Science._1n%2C._pp..._125--1591977https~3a%2F%2Fhomepages..inf..ed..ac..uk%2Fgdp%2Fpublications%2Fcbn_cbv_lambda..pdf%29" class="AutobibLink" data-pltdoc="x">1977<span class="AutobibLink">a</span></a>]</span>, and
such a program makes control flow explicit&#8212;<wbr></wbr>a property that makes CPS forms
well suited as intermediate compiler representation.</p><p>In Compiling with Continuations, <span class="Autobibref"><a href="#%28autobib._.Andrew._.Appel.Compiling._with._.Continuations.Cambridge._.Press1991%29" class="AutobibLink" data-pltdoc="x">Appel</a>&nbsp;[<a href="#%28autobib._.Andrew._.Appel.Compiling._with._.Continuations.Cambridge._.Press1991%29" class="AutobibLink" data-pltdoc="x">1991</a>]</span> argues along these lines for
the superiority of CPS representation and justifies its use in the SML
implementation of Bell Labs in New Jerset.<span class="refelem"><span class="refcolumn"><span class="refcontent">The use of CPS is
inherited from T Scheme&rsquo;s
<a href="https://people.csail.mit.edu/riastradh/t/adams86orbit.pdf">Orbit
compiler</a>.</span></span></span></p><p><div class="SIntrapara">In response, <span class="Autobibref"><a href="#%28autobib._.Amr._.Sabry._and._.Matthias._.Fellisen.Reasoning._about._.Programs._in._.Continuation._.Passing._.Style.In._.Proc..._.L.I.S.P._and._.Functional._.Programming%2C._pp..._288--2981992https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F141471..141563%29" class="AutobibLink" data-pltdoc="x">Sabry and Fellisen</a>&nbsp;[<a href="#%28autobib._.Amr._.Sabry._and._.Matthias._.Fellisen.Reasoning._about._.Programs._in._.Continuation._.Passing._.Style.In._.Proc..._.L.I.S.P._and._.Functional._.Programming%2C._pp..._288--2981992https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F141471..141563%29" class="AutobibLink" data-pltdoc="x">1992</a>]</span> investigate what is missing from &#955;v compared to
&#955;n. They discover a small set of additional axioms that when added to &#955;v makes
the theory equivalent to &#955;n:
</div><div class="SIntrapara"><blockquote class="SCentered"><p>for all <span style="font-style: italic">e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic">, e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>:
<span style="font-style: italic">&#955;v, A |- e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> = e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>
if and only if
<span style="font-style: italic">&#955;n |- cps</span>(<span style="font-style: italic">e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> = cps</span>(<span style="font-style: italic">e</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p></blockquote></div><div class="SIntrapara">They also notice that, when oriented properly as reductions, the equations in A
satisfy the strong normalization theorem. <span class="Autobibref"><a href="#%28autobib._.Cormac._.Flanagan%2C._.Amr._.Sabry%2C._.Bruce._.Duba%2C._and._.Matthias._.Fellisen.The._.Essence._of._.Compiling._with._.Continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--121993https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F173262..155113%29" class="AutobibLink" data-pltdoc="x">Flanagan et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Cormac._.Flanagan%2C._.Amr._.Sabry%2C._.Bruce._.Duba%2C._and._.Matthias._.Fellisen.The._.Essence._of._.Compiling._with._.Continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--121993https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F173262..155113%29" class="AutobibLink" data-pltdoc="x">1993</a>]</span> exploit strong
normalization to show that practical compilers actually "undo" the CPS
transformation, in a way that yields programs A nf rather than just CPS.</div></p><p>Fifteen years later, <span class="Autobibref"><a href="#%28autobib._.Andrew._.Kennedy.Compiling._with._continuations%2C._continued.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122007https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F1291220..1291179%29" class="AutobibLink" data-pltdoc="x">Kennedy</a>&nbsp;[<a href="#%28autobib._.Andrew._.Kennedy.Compiling._with._continuations%2C._continued.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122007https~3a%2F%2Fdl..acm..org%2Fdoi%2F10..1145%2F1291220..1291179%29" class="AutobibLink" data-pltdoc="x">2007</a>]</span> renews the case for CPS, revisiting issues
with ANF that come up during optimization.  One of these is that conditionals
seem to pose a challenge to A nf because control flow branches.  In response,
<span class="Autobibref"><a href="#%28autobib._.Luke._.Maurer%2C._.Paul._.Downen%2C._.Zena._.Ariola%2C._and._.Simon._.Peyton._.Jones.Compiling._without._continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122017https~3a%2F%2Fix..cs..uoregon..edu%2F~7epdownen%2Fpublications%2Fpldi17_appendix..pdf%29" class="AutobibLink" data-pltdoc="x">Maurer et al<span class="Sendabbrev">.</span></a>&nbsp;[<a href="#%28autobib._.Luke._.Maurer%2C._.Paul._.Downen%2C._.Zena._.Ariola%2C._and._.Simon._.Peyton._.Jones.Compiling._without._continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation%2C._pp..._1--122017https~3a%2F%2Fix..cs..uoregon..edu%2F~7epdownen%2Fpublications%2Fpldi17_appendix..pdf%29" class="AutobibLink" data-pltdoc="x">2017</a>]</span> turn ANF into a graph representation with join points for
conditionals. This simple extension to ANF re-enables the standard optimizations
for conditionals.</p><p>To this day, it remains an open question as to what extent ANF can replace CPS
as an intermediate compiler representation or whether compilers can benefit from
a mix.</p><h3><a name="(part._26)"></a>The ML Module System <span class="strike" style="text-decoration:line-through">Refinement Types</span></h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Donald Pinckney</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 13 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._27)"></a>The Evolution of Dependent Types</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Lucy Amidon</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 16 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._28)"></a>The Implementation of Depdenent-Type Proof Assistants</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Ankit Kumar</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 20 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._29)"></a>Image-Based Programming Systems</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Michael Ballantyne </p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 23 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._30)"></a>Visual Teaching Languages</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Emily Herbert</p></span></div><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> 27 Apr 2021</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"></div></p><p>abstract and citations needed</p><h3><a name="(part._doc-bibliography)"></a>Bibliography</h3><p><table cellspacing="0" cellpadding="0" class="AutoBibliography"><tr><td><p><a name="(autobib._.Andrew._.Appel.Compiling._with._.Continuations.Cambridge._.Press1991)"></a><span class="Autobibentry">Andrew Appel. Compiling with Continuations. Cambridge Press, 1991.</span></p></td></tr><tr><td><p><a name="(autobib._.V..._.Bala,._.E..._.Duesterwald,._and._.S..._.Banerjia.Dynamo~3a._.A._transparent._dynamic._optimization._system.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._1--122000https~3a//dl..acm..org/doi/abs/10..1145/349299..349303~3fcasa_token~3db.Z1.C.V.J8l.M14.A.A.A.A.A~3a.G.Ly.Sa.D-.V.Hi81rfdm5.Lm.M.Gn4b.Zu.Xd.Bm.F.N.J.L.Eaw.Y.Dmkx3.Z8z.X.V5.G-d.Yya.H.Bh_.Qul3o70xha9kcjkb.O)"></a><span class="Autobibentry">V. Bala, E. Duesterwald, and S. Banerjia. Dynamo: A transparent dynamic optimization system. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 1&ndash;12, 2000. <a href="https://dl.acm.org/doi/abs/10.1145/349299.349303?casa_token=bZ1CVJ8lM14AAAAA:GLySaD-VHi81rfdm5LmMGn4bZuXdBmFNJLEawYDmkx3Z8zXV5G-dYyaHBh_Qul3o70xha9kcjkbO"><span class="url">https://dl.acm.org/doi/abs/10.1145/349299.349303?casa_token=bZ1CVJ8lM14AAAAA:GLySaD-VHi81rfdm5LmMGn4bZuXdBmFNJLEawYDmkx3Z8zXV5G-dYyaHBh_Qul3o70xha9kcjkbO</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Alan._.Bawden,._.Richard._.Greenblatt,._.Jack._.Holloway,._.Thomas._.Knight,._.David._.Moon,._and._.Daniel._.Weinreb.Lisp._.Machine._.Progress._.Report.Massachusetts._.Institute._of._.Technology..,._.A.I._.Memo._.No..._4441977http~3a//dspace..mit..edu/bitstream/handle/1721..1/5751/.A.I.M-444..pdf~3fsequence~3d2~26is.Allowed~3dy)"></a><span class="Autobibentry">Alan Bawden, Richard Greenblatt, Jack Holloway, Thomas Knight, David Moon, and Daniel Weinreb. Lisp Machine Progress Report. Massachusetts Institute of Technology., AI Memo No. 444, 1977. <a href="http://dspace.mit.edu/bitstream/handle/1721.1/5751/AIM-444.pdf?sequence=2&amp;isAllowed=y"><span class="url">http://dspace.mit.edu/bitstream/handle/1721.1/5751/AIM-444.pdf?sequence=2&amp;isAllowed=y</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.M..._.Bebenita,._.F..._.Brandner,._.M..._.Fahndrich,._.F..._.Logozzo,._.W..._.Schulte,._.N..._.Tillmann,._and._.H..._.Venter.S.P.U.R~3a._a._trace-based._.J.I.T._compiler._for._.C.I.L.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications,._pp..._708--7252010https~3a//dl..acm..org/doi/abs/10..1145/1869459..1869517~3fcasa_token~3dkeltm8w.Z.O7.Y.A.A.A.A.A~3alozbw.S5.H2o.F.Z_.Zm.X9xno.F1i.J.J3.Whu.J.H.Pi-v.Sc3.Vxwye.Y.Ftk2g.Mvyd.Xw1a.Knjt28.N.Xgc6pxyt.X.T07)"></a><span class="Autobibentry">M. Bebenita, F. Brandner, M. Fahndrich, F. Logozzo, W. Schulte, N. Tillmann, and H. Venter. SPUR: a trace-based JIT compiler for CIL. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, pp. 708&ndash;725, 2010. <a href="https://dl.acm.org/doi/abs/10.1145/1869459.1869517?casa_token=keltm8wZO7YAAAAA:lozbwS5H2oFZ_ZmX9xnoF1iJJ3WhuJHPi-vSc3VxwyeYFtk2gMvydXw1aKnjt28NXgc6pxytXT07"><span class="url">https://dl.acm.org/doi/abs/10.1145/1869459.1869517?casa_token=keltm8wZO7YAAAAA:lozbwS5H2oFZ_ZmX9xnoF1iJJ3WhuJHPi-vSc3VxwyeYFtk2gMvydXw1aKnjt28NXgc6pxytXT07</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.E..._.Beda,._.L..._.N..._.Korolev,._.N..._.V..._.Sukkikh,._and._.T..._.S..._.Frolova.Programs._.For._.Automatic._.Differentiation._.For._.The._.Machine._.B.E.S.M.Institute._for._.Precise._.Mechanics._and._.Computation._.Techniques,._.Academy._of._.Science,._~5b.Ostrovskii1971.Ud.B~5d1959)"></a><span class="Autobibentry">E. Beda, L. N. Korolev, N. V. Sukkikh, and T. S. Frolova. Programs For Automatic Differentiation For The Machine BESM. Institute for Precise Mechanics and Computation Techniques, Academy of Science, [Ostrovskii1971UdB], 1959.</span></p></td></tr><tr><td><p><a name="(autobib._.Albert._.Benveniste,._.Paul.Le._.Guernic,._and._.Christian._.Jacquemot.Synchronous._.Programming._with._.Events._and._.Relations~3a._the._.S.I.G.N.A.L._.Language._and._.Its._.Semantics.Science._of._.Programming._16(2),._pp..._103--1491991https~3a//www..sciencedirect..com/science/article/pii/016764239190001.E)"></a><span class="Autobibentry">Albert Benveniste, PaulLe Guernic, and Christian Jacquemot. Synchronous Programming with Events and Relations: the SIGNAL Language and Its Semantics. <span style="font-style: italic">Science of Programming</span> 16(2), pp. 103&ndash;149, 1991. <a href="https://www.sciencedirect.com/science/article/pii/016764239190001E"><span class="url">https://www.sciencedirect.com/science/article/pii/016764239190001E</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.G~c3~a9rard._.Berry._and._.Georges._.Gonthier.The._.Esterel._.Synchronous._.Programming._.Language~3a._.Design,._.Semantics,._and._.Implementation.Science._of._.Programming._19(1),._pp..._87--1521991https~3a//www..sciencedirect..com/science/article/pii/016764239290005.V)"></a><span class="Autobibentry">G&#233;rard Berry and Georges Gonthier. The Esterel Synchronous Programming Language: Design, Semantics, and Implementation. <span style="font-style: italic">Science of Programming</span> 19(1), pp. 87&ndash;152, 1991. <a href="https://www.sciencedirect.com/science/article/pii/016764239290005V"><span class="url">https://www.sciencedirect.com/science/article/pii/016764239290005V</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Brian._.Bershad,._.Savage,._.S..,._.Pardyak,._.P..,._.Sirer,._.E..._.G..,._.Fiuczynski,._.M..._.E..,._.Becker,._.D..,._.Chambers,._.C..,._and._.Eggers,._.S...Extensibility._.Safety._and._.Performance._in._the._.S.P.I.N._.Operating._.System.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles,._pp..._267--2831995https~3a//doi..org/10..1145/224056..224077)"></a><span class="Autobibentry">Brian Bershad, Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M. E., Becker, D., Chambers, C., and Eggers, S. Extensibility Safety and Performance in the SPIN Operating System. In <span style="font-style: italic">Proc. ACM Symposium on Operating Systems Principles</span>, pp. 267&ndash;283, 1995. <a href="https://doi.org/10.1145/224056.224077"><span class="url">https://doi.org/10.1145/224056.224077</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Gavin._.M..._.Bierman,._.Mart~c3~adn._.Abadi,._and._.Mads._.Torgersen.Understanding._.Type.Script.In._.Proc..._.European._.Symposium._on._on._.Programming,._pp..._257--2812014https~3a//dl..acm..org/doi/10..1007/978-3-662-44202-9_11)"></a><span class="Autobibentry">Gavin M. Bierman, Mart&#237;n Abadi, and Mads Torgersen. Understanding TypeScript. In <span style="font-style: italic">Proc. European Symposium on on Programming</span>, pp. 257&ndash;281, 2014. <a href="https://dl.acm.org/doi/10.1007/978-3-662-44202-9_11"><span class="url">https://dl.acm.org/doi/10.1007/978-3-662-44202-9_11</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Christian._.Bischof,._.Alan._.Carle,._.George._.Corliss,._.Andreas._.Griewank,._and._.Paul._.Hovland.A.D.I.F.O.R~e2~80~93.Generating._.Derivative._.Codes._from._.Fortran._.Programs.Scientific._.Programming._1(1),._pp..._11--291992https~3a//www..hindawi..com/journals/sp/1992/717832/)"></a><span class="Autobibentry">Christian Bischof, Alan Carle, George Corliss, Andreas Griewank, and Paul Hovland. ADIFOR&#8211;Generating Derivative Codes from Fortran Programs. <span style="font-style: italic">Scientific Programming</span> 1(1), pp. 11&ndash;29, 1992. <a href="https://www.hindawi.com/journals/sp/1992/717832/"><span class="url">https://www.hindawi.com/journals/sp/1992/717832/</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.C...F..._.Bolz,._.A..._.Cuni,._.M..._.Fijalkowski,._and._.A..._.Rigo.Tracing._the._meta-level~3a._.Py.Py's._tracing._.J.I.T._compiler.In._.Proc..._.Workshop._on._the._.Implementation,._.Compilation,._.Optimization._of._.Object-.Oriented._.Languages~0a._._and._.Programming._.Systems,._pp..._18--252009https~3a//dl..acm..org/doi/abs/10..1145/1565824..1565827~3fcasa_token~3d9.N.F.Fn.O.M4.Ip.I.A.A.A.A.A~3agm.T.Z6_.Sj.K.X.R.Y.Bqyz.Qqr.A.O.R2.X.Nx.Y.F.N.Szj9.T.T.Js.E.R.Bj.Q.Y.H.Q9.R.Wd.N.Ih-8w-8.Rjix.An.F.O.B.Td.Mj.E.S_.E.K.B)"></a><span class="Autobibentry">C.F. Bolz, A. Cuni, M. Fijalkowski, and A. Rigo. Tracing the meta-level: PyPy&rsquo;s tracing JIT compiler. In <span style="font-style: italic">Proc. Workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages
  and Programming Systems</span>, pp. 18&ndash;25, 2009. <a href="https://dl.acm.org/doi/abs/10.1145/1565824.1565827?casa_token=9NFFnOM4IpIAAAAA:gmTZ6_SjKXRYBqyzQqrAOR2XNxYFNSzj9TTJsERBjQYHQ9RWdNIh-8w-8RjixAnFOBTdMjES_EKB"><span class="url">https://dl.acm.org/doi/abs/10.1145/1565824.1565827?casa_token=9NFFnOM4IpIAAAAA:gmTZ6_SjKXRYBqyzQqrAOR2XNxYFNSzj9TTJsERBjQYHQ9RWdNIh-8w-8RjixAnFOBTdMjES_EKB</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Gilad._.Bracha,._.Martin._.Odersky,._.David._.Stoutamire,._and._.Philip._.Wadler.Making._the._.Future._.Safe._for._the._.Past~3a._.Adding._.Genericity._to._the._.Java._.Programming._.Language.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications,._pp..._183--2001998https~3a//doi..org/10..1145/286936..286957)"></a><span class="Autobibentry">Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. Making the Future Safe for the Past: Adding Genericity to the Java Programming Language. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, pp. 183&ndash;200, 1998. <a href="https://doi.org/10.1145/286936.286957"><span class="url">https://doi.org/10.1145/286936.286957</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.William._.Byrd.Logic._and._.Relational._.Programming,._mini.Kanren.Info.Q,._.An._.Interview2014https~3a//www..infoq..com/interviews/byrd-relational-programming-minikanren/)"></a><span class="Autobibentry">William Byrd. Logic and Relational Programming, miniKanren. InfoQ, An Interview, 2014. <a href="https://www.infoq.com/interviews/byrd-relational-programming-minikanren/"><span class="url">https://www.infoq.com/interviews/byrd-relational-programming-minikanren/</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.L..._.Caires._and._.F..._.Pfenning.Session._.Types._as._.Intuitionistic._.Linear._.Propositions.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory,._pp..._222--2362010https~3a//www..cs..cmu..edu/~7efp/papers/concur10..pdf)"></a><span class="Autobibentry">L. Caires and F. Pfenning. Session Types as Intuitionistic Linear Propositions. In <span style="font-style: italic">Proc. International Conference on Concurrency Theory</span>, pp. 222&ndash;236, 2010. <a href="https://www.cs.cmu.edu/~fp/papers/concur10.pdf"><span class="url">https://www.cs.cmu.edu/~fp/papers/concur10.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Peter._.Canning,._.William._.Cook,._.Walter._.Hill,._.Walter._.Olthoff,._and._.John._.C..._.Mitchell.F-bounded._.Polymorphism._for._.Object-.Oriented._.Programming.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture,._pp..._273--2801989https~3a//doi..org/10..1145/99370..99392)"></a><span class="Autobibentry">Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded Polymorphism for Object-Oriented Programming. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming Languages and Computer Architecture</span>, pp. 273&ndash;280, 1989. <a href="https://doi.org/10.1145/99370.99392"><span class="url">https://doi.org/10.1145/99370.99392</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Luca._.Cardelli._and._.Peter._.Wegner.On._understanding._types,._data._abstraction,._and._polymorphism.A.C.M._.Computing._.Surveys._17(4),._pp..._471--5231985https~3a//doi..org/10..1145/6041..6042)"></a><span class="Autobibentry">Luca Cardelli and Peter Wegner. On understanding types, data abstraction, and polymorphism. <span style="font-style: italic">ACM Computing Surveys</span> 17(4), pp. 471&ndash;523, 1985. <a href="https://doi.org/10.1145/6041.6042"><span class="url">https://doi.org/10.1145/6041.6042</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Craig._.Chambers._and._.David._.Ungar.Customization~3a._.Optimizing._compiler._technology._for._.S.E.L.F,._a._dynamically-typed._object-oriented._programming._language.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._146--1601989https~3a//dl..acm..org/doi/abs/10..1145/74818..74831~3fcasa_token~3d.Wh.Au8y.Q4.Uac.A.A.A.A.A~3ao.I.G.Vyvk.Q1.S.J.Ap.Njzq.R6l.Nl9.Hi.P.T.B3bmqgc80hwh.A75.Ql.H.Ue.Kxv.Qa8h6.K.F.A.Aork2n3.U.Sbv.M1e.Dq.Qk)"></a><span class="Autobibentry">Craig Chambers and David Ungar. Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 146&ndash;160, 1989. <a href="https://dl.acm.org/doi/abs/10.1145/74818.74831?casa_token=WhAu8yQ4UacAAAAA:oIGVyvkQ1SJApNjzqR6lNl9HiPTB3bmqgc80hwhA75QlHUeKxvQa8h6KFAAork2n3USbvM1eDqQk"><span class="url">https://dl.acm.org/doi/abs/10.1145/74818.74831?casa_token=WhAu8yQ4UacAAAAA:oIGVyvkQ1SJApNjzqR6lNl9HiPTB3bmqgc80hwhA75QlHUeKxvQa8h6KFAAork2n3USbvM1eDqQk</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Benjamin._.Chung,._.Paley._.Li,._.Francesco._.Zappa._.Nardelli,._and._.Jan._.Vitek.Kaf.Ka~3a._.Gradual._.Typing._for._.Objects...In._.Proc..._.European._.Conference._on._.Object-.Oriented._.Programming2018https~3a//hal..inria..fr/hal-01882148/document)"></a><span class="Autobibentry">Benjamin Chung, Paley Li, Francesco Zappa Nardelli, and Jan Vitek. KafKa: Gradual Typing for Objects. In <span style="font-style: italic">Proc. European Conference on Object-Oriented Programming</span>, 2018. <a href="https://hal.inria.fr/hal-01882148/document"><span class="url">https://hal.inria.fr/hal-01882148/document</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Dominique._.Clement,._.Joelle._.Despeyroux,._.Thierry._.Despeyroux,._.Laurent._.Hascoet,._and._.Gilles._.Kahn.Natural._semantics._on._the._computer.I.N.R.I.A._.Sophia-.Antipolis,._.R.R-0416._000761401985https~3a//hal..inria..fr/inria-00076140/document)"></a><span class="Autobibentry">Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Laurent Hascoet, and Gilles Kahn. Natural semantics on the computer. INRIA Sophia-Antipolis, RR-0416 00076140, 1985. <a href="https://hal.inria.fr/inria-00076140/document"><span class="url">https://hal.inria.fr/inria-00076140/document</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.William._.D..._.Clinger,._.Jonathan._.A..._.Rees,._.H..._.Abelson,._.R._.Kent._.Dybvig,._.Christopher._.Thomas._.Haynes,._.Guillermo._.Juan._.Rozas,._.Norman._.I..._.Adams,._.Daniel._.Paul._.Friedman,._.Eugene._.E..._.Kohlbecker,._.Guy._.L..._.Steele._.Jr..,._.David._.H._.Bartley,._.Robert._.H._.Halstead,._.D..._.Oxley,._.Gerald._.Jay._.Sussman,._.G..._.Brooks,._.Chris._.Hanson,._.Kent._.M..._.Pitman,._and._.Mitch._.Wand.The._revised4._report._on._.S.C.H.E.M.E~3a._a._dialect._of._.L.I.S.P.A.C.M._.S.I.G.P.L.A.N._.Lisp._.Pointers._.I.V(3),._pp..._1--551991https~3a//dl..acm..org/doi/10..1145/382130..382133)"></a><span class="Autobibentry">William D. Clinger, Jonathan A. Rees, H. Abelson, R Kent Dybvig, Christopher Thomas Haynes, Guillermo Juan Rozas, Norman I. Adams, Daniel Paul Friedman, Eugene E. Kohlbecker, Guy L. Steele Jr., David H Bartley, Robert H Halstead, D. Oxley, Gerald Jay Sussman, G. Brooks, Chris Hanson, Kent M. Pitman, and Mitch Wand. The revised<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span> report on SCHEME: a dialect of LISP. <span style="font-style: italic">ACM SIGPLAN Lisp Pointers</span> IV(3), pp. 1&ndash;55, 1991. <a href="https://dl.acm.org/doi/10.1145/382130.382133"><span class="url">https://dl.acm.org/doi/10.1145/382130.382133</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Alain._.Colmerauer._and._.Philippe._.Roussel.The._.Birth._of._.Prolog.In._.Proc..._.History._of._.Programming._.Languages._.I.I,._pp..._331--3671996https~3a//doi..org/10..1145/234286..1057820)"></a><span class="Autobibentry">Alain Colmerauer and Philippe Roussel. The Birth of Prolog. In <span style="font-style: italic">Proc. History of Programming Languages II</span>, pp. 331&ndash;367, 1996. <a href="https://doi.org/10.1145/234286.1057820"><span class="url">https://doi.org/10.1145/234286.1057820</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Gregory._.H..._.Cooper._and._.Shriram._.Krishnamurthi.Embedding._.Dynamic._.Dataflow._in._a._.Call-by-.Value._.Language.In._.Proc..._.European._.Symposium._on._on._.Programming,._pp..._294--3082006https~3a//link..springer..com/chapter/10..1007/11693024_20)"></a><span class="Autobibentry">Gregory H. Cooper and Shriram Krishnamurthi. Embedding Dynamic Dataflow in a Call-by-Value Language. In <span style="font-style: italic">Proc. European Symposium on on Programming</span>, pp. 294&ndash;308, 2006. <a href="https://link.springer.com/chapter/10.1007/11693024_20"><span class="url">https://link.springer.com/chapter/10.1007/11693024_20</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.T..._.Cramer,._.R..._.Friedman,._.T..._.Miller,._.D..._.Seberger,._.R..._.Wilson,._and._.M..._.Wolczko.Compiling._.Java._just._in._time.I.E.E.E._.Micro._17(3),._pp..._36--431997https~3a//ieeexplore..ieee..org/abstract/document/591653~3fcasa_token~3dtm.R9a1.F.E.Uag.A.A.A.A.A~3a.R.B.Iu.T.B.P.C.W.Zbr3.Z.Njn.Q9ae7m.Q4.V96awrawfn.Xgmx.I_.U.Bc.X.Li.Q.T.Ea.T.Wq.Y5.Y4p5.X.B.T580.J.W4rn.Z.Zw)"></a><span class="Autobibentry">T. Cramer, R. Friedman, T. Miller, D. Seberger, R. Wilson, and M. Wolczko. Compiling Java just in time. <span style="font-style: italic">IEEE Micro</span> 17(3), pp. 36&ndash;43, 1997. <a href="https://ieeexplore.ieee.org/abstract/document/591653?casa_token=tmR9a1FEUagAAAAA:RBIuTBPCWZbr3ZNjnQ9ae7mQ4V96awrawfnXgmxI_UBcXLiQTEaTWqY5Y4p5XBT580JW4rnZZw"><span class="url">https://ieeexplore.ieee.org/abstract/document/591653?casa_token=tmR9a1FEUagAAAAA:RBIuTBPCWZbr3ZNjnQ9ae7mQ4V96awrawfnXgmxI_UBcXLiQTEaTWqY5Y4p5XBT580JW4rnZZw</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Ryan._.Culpepper._and._.Matthias._.Felleisen.Fortifying._macros.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._235--2462010https~3a//www2..ccs..neu..edu/racket/pubs/~23c-jfp12)"></a><span class="Autobibentry">Ryan Culpepper and Matthias Felleisen. Fortifying macros. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 235&ndash;246, 2010. <a href="https://www2.ccs.neu.edu/racket/pubs/#c-jfp12"><span class="url">https://www2.ccs.neu.edu/racket/pubs/#c-jfp12</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Evan._.Czaplicki._and._.Stephen._.Chong.Asynchronous._.Functional._.Reactive._.Programming._for._.Guis.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._1--122013https~3a//dl..acm..org/doi/10..1145/2499370..2462161)"></a><span class="Autobibentry">Evan Czaplicki and Stephen Chong. Asynchronous Functional Reactive Programming for Guis. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 1&ndash;12, 2013. <a href="https://dl.acm.org/doi/10.1145/2499370.2462161"><span class="url">https://dl.acm.org/doi/10.1145/2499370.2462161</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Luis._.Damas._and._.Robin._.Milner.Principal._.Type-.Schemes._for._.Functional._.Programs.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._207--2121982https~3a//dl..acm..org/doi/10..1145/582153..582176)"></a><span class="Autobibentry">Luis Damas and Robin Milner. Principal Type-Schemes for Functional Programs. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 207&ndash;212, 1982. <a href="https://dl.acm.org/doi/10.1145/582153.582176"><span class="url">https://dl.acm.org/doi/10.1145/582153.582176</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.O..._.Dardhaa,._.E..._.Giachinob,._and._.D..._.Sangiorgib.Session._.Types._.Revisited.Information._and._.Computation._2562017https~3a//www..sciencedirect..com/science/article/pii/.S0890540117300962)"></a><span class="Autobibentry">O. Dardhaa, E. Giachinob, and D. Sangiorgib. Session Types Revisited. <span style="font-style: italic">Information and Computation</span> 256, 2017. <a href="https://www.sciencedirect.com/science/article/pii/S0890540117300962"><span class="url">https://www.sciencedirect.com/science/article/pii/S0890540117300962</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Christos._.Dimoulas,._.Sam._.Tobin-.Hochstadt,._and._.Matthias._.Felleisen.Complete._.Monitors._for._.Behavioral._.Contracts.In._.Proc..._.European._.Symposium._on._on._.Programming,._pp..._214--2332012)"></a><span class="Autobibentry">Christos Dimoulas, Sam Tobin-Hochstadt, and Matthias Felleisen. Complete Monitors for Behavioral Contracts. In <span style="font-style: italic">Proc. European Symposium on on Programming</span>, pp. 214&ndash;233, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Kent._.R..._.Dybvig.Writing._hygienic._macros._in._.Scheme._with._syntax-case.Indiana._.University,._.Department._of._.Computer._.Science,._.T.R3561992https~3a//help..luddy..indiana..edu/techreports/.T.R.N.N.N..cgi~3ftrnum~3d.T.R356)"></a><span class="Autobibentry">Kent R. Dybvig. Writing hygienic macros in Scheme with syntax-case. Indiana University, Department of Computer Science, TR356, 1992. <a href="https://help.luddy.indiana.edu/techreports/TRNNN.cgi?trnum=TR356"><span class="url">https://help.luddy.indiana.edu/techreports/TRNNN.cgi?trnum=TR356</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Kent._.R..._.Dybvig,._.Robert._.Hieb,._and._.Carl._.Bruggeman.Syntactic._abstraction._in._.Scheme.L.I.S.P._and._.Symbolic._.Computation._5,._pp..._295--3261993https~3a//link..springer..com/article/10..1007/.B.F01806308)"></a><span class="Autobibentry">Kent R. Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. <span style="font-style: italic">LISP and Symbolic Computation</span> 5, pp. 295&ndash;326, 1993. <a href="https://link.springer.com/article/10.1007/BF01806308"><span class="url">https://link.springer.com/article/10.1007/BF01806308</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Conal._.Elliott._and._.Paul._.Hudak.Functional._.Reactive._.Animation.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._263--2731997https~3a//dl..acm..org/doi/10..1145/258948..258973)"></a><span class="Autobibentry">Conal Elliott and Paul Hudak. Functional Reactive Animation. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 263&ndash;273, 1997. <a href="https://dl.acm.org/doi/10.1145/258948.258973"><span class="url">https://dl.acm.org/doi/10.1145/258948.258973</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.M..._.H..._.Van._.Emden.Who._killed._.Prolog~3f.Van._.Emden,._.A._.Programmer's._.Place,._.Word.Press._.Blog2010https~3a//vanemden..wordpress..com/2010/08/21/who-killed-prolog/)"></a><span class="Autobibentry">M. H. Van Emden. Who killed Prolog? Van Emden, A Programmer&rsquo;s Place, WordPress Blog, 2010. <a href="https://vanemden.wordpress.com/2010/08/21/who-killed-prolog/"><span class="url">https://vanemden.wordpress.com/2010/08/21/who-killed-prolog/</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.M..._.H..._.Van._.Emden._and._.R..._.A..._.Kowalski.The._.Semantics._of._.Predicate._.Logic._as._a._.Programming._.Language.Journal._of._the._.A.C.M._23(4),._pp..._733--7421976https~3a//doi..org/10..1145/321978..321991)"></a><span class="Autobibentry">M. H. Van Emden and R. A. Kowalski. The Semantics of Predicate Logic as a Programming Language. <span style="font-style: italic">Journal of the ACM</span> 23(4), pp. 733&ndash;742, 1976. <a href="https://doi.org/10.1145/321978.321991"><span class="url">https://doi.org/10.1145/321978.321991</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Uffe._.Engberg._and._.Mogens._.Nielsen.A._.Calculus._of._.Communicating._.Systems._with._.Label-.Passing.In._.Proc..._.Proof,._.Language,._and._.Interaction._~3a._.Essays._in._.Honour._of._.Robin._.Milner..._.M.I.T._.Press..,._pp..._599--6221986https~3a//pdfs..semanticscholar..org/802f/a6e557acc721d9dc04a2fdded5bf75240e8c..pdfalso._available._as._.D.A.I.M.I._.Tech..._.Rpt..._208,._.University._of._.Aarhus)"></a><span class="Autobibentry">Uffe Engberg and Mogens Nielsen. A Calculus of Communicating Systems with Label-Passing. In <span style="font-style: italic">Proc. Proof, Language, and Interaction : Essays in Honour of Robin Milner. MIT Press.</span>, pp. 599&ndash;622, 1986. <a href="https://pdfs.semanticscholar.org/802f/a6e557acc721d9dc04a2fdded5bf75240e8c.pdf"><span class="url">https://pdfs.semanticscholar.org/802f/a6e557acc721d9dc04a2fdded5bf75240e8c.pdf</span></a> also available as DAIMI Tech. Rpt. 208, University of Aarhus</span></p></td></tr><tr><td><p><a name="(autobib._.Robert._.B..._.Findler._and._.Matthias._.Felleisen.Contracts._for._.Higher-.Order._.Functions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._48--592002)"></a><span class="Autobibentry">Robert B. Findler and Matthias Felleisen. Contracts for Higher-Order Functions. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 48&ndash;59, 2002.</span></p></td></tr><tr><td><p><a name="(autobib._.Robert._.Bruce._.Findler._and._.Matthias._.Felleisen.Contract._.Soundness._for._.Object-.Oriented._.Languages.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications,._pp..._1--152001https~3a//doi..org/10..1145/504282..504283)"></a><span class="Autobibentry">Robert Bruce Findler and Matthias Felleisen. Contract Soundness for Object-Oriented Languages. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, pp. 1&ndash;15, 2001. <a href="https://doi.org/10.1145/504282.504283"><span class="url">https://doi.org/10.1145/504282.504283</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Cormac._.Flanagan,._.Amr._.Sabry,._.Bruce._.Duba,._and._.Matthias._.Fellisen.The._.Essence._of._.Compiling._with._.Continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._1--121993https~3a//dl..acm..org/doi/10..1145/173262..155113)"></a><span class="Autobibentry">Cormac Flanagan, Amr Sabry, Bruce Duba, and Matthias Fellisen. The Essence of Compiling with Continuations. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 1&ndash;12, 1993. <a href="https://dl.acm.org/doi/10.1145/173262.155113"><span class="url">https://dl.acm.org/doi/10.1145/173262.155113</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Matthew._.Flatt.Bindings._as._sets._of._scopes.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._705--7172016https~3a//dl..acm..org/doi/10..1145/2837614..2837620)"></a><span class="Autobibentry">Matthew Flatt. Bindings as sets of scopes. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 705&ndash;717, 2016. <a href="https://dl.acm.org/doi/10.1145/2837614.2837620"><span class="url">https://dl.acm.org/doi/10.1145/2837614.2837620</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Matthew._.Flatt,._.Robert._.Bruce._.Findler,._.Shriram._.Krishnamurthi,._and._.Matthias._.Felleisen.Programming._.Languages._as._.Operating._.Systems._(or._.Revenge._of._the._.Son._of._the._.Lisp._.Machine).In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._138--1471999https~3a//doi..org/10..1145/317636..317793)"></a><span class="Autobibentry">Matthew Flatt, Robert Bruce Findler, Shriram Krishnamurthi, and Matthias Felleisen. Programming Languages as Operating Systems (or Revenge of the Son of the Lisp Machine). In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 138&ndash;147, 1999. <a href="https://doi.org/10.1145/317636.317793"><span class="url">https://doi.org/10.1145/317636.317793</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Daniel._.P..._.Friedman,._.William._.E..._.Byrd,._.Oleg._.Kiselyov,._and._.Jason._.Hemann.The._.Reasoned._.Schemer,._2nd._.Edition.M.I.T._.Press2018https~3a//mitpress..mit..edu/books/reasoned-schemer-second-edition)"></a><span class="Autobibentry">Daniel P. Friedman, William E. Byrd, Oleg Kiselyov, and Jason Hemann. The Reasoned Schemer, 2nd Edition. MIT Press, 2018. <a href="https://mitpress.mit.edu/books/reasoned-schemer-second-edition"><span class="url">https://mitpress.mit.edu/books/reasoned-schemer-second-edition</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.A..._.Gal,._.B..._.Eich,._.M..._.Shaver,._.D..._.Mandelin,._.D..._.Anderson,._.M..._.R..._.Haghighat,._.B..._.Kaplan,._.G..._.Hoare,._.B..._.Zbarsky,._.J..._.Orendorff,._and._.J..._.Ruderman.Trace-based._just-in-time._type._specialization._for._dynamic._languages.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._465--4782009https~3a//dl..acm..org/doi/abs/10..1145/1543135..1542528~3fcasa_token~3dt.Zl.Pv.Nce.V.D.Y.A.A.A.A.A~3a.C.B5.H.Kjaq.A1v.K.Ji.V0j.Ac.A8r.Gz.Z2.Jb_p.Lgh.Il.Fwqht.Neb-.Jp.Qu.A0-.K0fd_1.Ypbtpy.Oc.X.Fr.Qki.D.Rlsh)"></a><span class="Autobibentry">A. Gal, B. Eich, M. Shaver, D. Mandelin, D. Anderson, M. R. Haghighat, B. Kaplan, G. Hoare, B. Zbarsky, J. Orendorff, and J. Ruderman. Trace-based just-in-time type specialization for dynamic languages. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 465&ndash;478, 2009. <a href="https://dl.acm.org/doi/abs/10.1145/1543135.1542528?casa_token=tZlPvNceVDYAAAAA:CB5HKjaqA1vKJiV0jAcA8rGzZ2Jb_pLghIlFwqhtNeb-JpQuA0-K0fd_1YpbtpyOcXFrQkiDRlsh"><span class="url">https://dl.acm.org/doi/abs/10.1145/1543135.1542528?casa_token=tZlPvNceVDYAAAAA:CB5HKjaqA1vKJiV0jAcA8rGzZ2Jb_pLghIlFwqhtNeb-JpQuA0-K0fd_1YpbtpyOcXFrQkiDRlsh</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.A..._.Gal,._.C...W..._.Probst,._and._.M..._.Franz._.Hotpath.V.M~3a._.An._effective._.J.I.T._compiler._for._resource-constrained._devices.In._.Proc..._.International._.Conference._on._.Virtual._.Execution._.Environments,._pp..._144--1532006https~3a//dl..acm..org/doi/abs/10..1145/1134760..1134780~3fcasa_token~3d.Td.T.Xla.S.K.Y.Og.A.A.A.A.A~3a.Xm7.Y.U.Lv.S.Zsv.Wuzlyn.Ko.Dm8_.Kbno.Q2kndd.X.Nuy-9p.U.Hvpm.X.Wfe0.E5vt.Pd.Xn.Rx.Tgal.U.I.D.L.R.Siq.M.Am.Y)"></a><span class="Autobibentry">A. Gal, C.W. Probst, and M. Franz.  HotpathVM: An effective JIT compiler for resource-constrained devices. In <span style="font-style: italic">Proc. International Conference on Virtual Execution Environments</span>, pp. 144&ndash;153, 2006. <a href="https://dl.acm.org/doi/abs/10.1145/1134760.1134780?casa_token=TdTXlaSKYOgAAAAA:Xm7YULvSZsvWuzlynKoDm8_KbnoQ2knddXNuy-9pUHvpmXWfe0E5vtPdXnRxTgalUIDLRSiqMAmY"><span class="url">https://dl.acm.org/doi/abs/10.1145/1134760.1134780?casa_token=TdTXlaSKYOgAAAAA:Xm7YULvSZsvWuzlynKoDm8_KbnoQ2knddXNuy-9pUHvpmXWfe0E5vtPdXnRxTgalUIDLRSiqMAmY</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Kathryn._.E..._.Gray,._.Robert._.B..._.Findler,._and._.Matthew._.Flatt.Fine-.Grained._.Interoperability._through._.Contracts._and._.Mirrors.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications,._pp..._231--2452005)"></a><span class="Autobibentry">Kathryn E. Gray, Robert B. Findler, and Matthew Flatt. Fine-Grained Interoperability through Contracts and Mirrors. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, pp. 231&ndash;245, 2005.</span></p></td></tr><tr><td><p><a name="(autobib._.Ben._.Greenman._and._.Matthias._.Felleisen.A._.Spectrum._of._.Type._.Soundness._and._.Performance.Proceedings._of._the._.A.C.M._on._.Programming._.Languages._(.I.C.F.P)._2(71),._pp..._1--322018)"></a><span class="Autobibentry">Ben Greenman and Matthias Felleisen. A Spectrum of Type Soundness and Performance. <span style="font-style: italic">Proceedings of the ACM on Programming Languages (ICFP)</span> 2(71), pp. 1&ndash;32, 2018.</span></p></td></tr><tr><td><p><a name="(autobib._.Ben._.Greenman,._.Matthias._.Felleisen,._and._.Christos._.Dimoulas.Complete._.Monitors._for._.Gradual._.Types.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications2019)"></a><span class="Autobibentry">Ben Greenman, Matthias Felleisen, and Christos Dimoulas. Complete Monitors for Gradual Types. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, 2019.</span></p></td></tr><tr><td><p><a name="(autobib._.Andreas._.Griewank.Achieving._logarithmic._growth._of._temporal._and._spatial._complexity._in._reverse._automatic._differentiation.Optimization._.Methods._and._.Software._1(1),._pp..._35--541992https~3a//doi..org/10..1080/10556789208805505)"></a><span class="Autobibentry">Andreas Griewank. Achieving logarithmic growth of temporal and spatial complexity in reverse automatic differentiation. <span style="font-style: italic">Optimization Methods and Software</span> 1(1), pp. 35&ndash;54, 1992. <a href="https://doi.org/10.1080/10556789208805505"><span class="url">https://doi.org/10.1080/10556789208805505</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Andreas._.Griewank,._.David._.Juedes,._and._.Jean._.Utke.Algorithm._755~3a._~7b.A.D.O.L~7d-.C~3a._a._package._for._the._automatic._differentiation._of._algorithms._written._in._.C/.C++.Transactions._on._.Mathematical._.Software._22(2),._pp..._131--1671996https~3a//doi..org/10..1145/229473..229474)"></a><span class="Autobibentry">Andreas Griewank, David Juedes, and Jean Utke. Algorithm 755: {ADOL}-C: a package for the automatic differentiation of algorithms written in C/C++. <span style="font-style: italic">Transactions on Mathematical Software</span> 22(2), pp. 131&ndash;167, 1996. <a href="https://doi.org/10.1145/229473.229474"><span class="url">https://doi.org/10.1145/229473.229474</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.N..._.Halbwachs,._.P..._.Caspi,._.P..._.Raymond,._and._.D..._.Pilaud.The._.Synchronous._.Data._.Flow._.Programming._.Language._.L.U.S.T.R.E.In._.Proc..._.Proceedings._of._the._.I.E.E.E._volume._79,._pp..._1305--13201991https~3a//ieeexplore..ieee..org/document/97300)"></a><span class="Autobibentry">N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. The Synchronous Data Flow Programming Language LUSTRE. In <span style="font-style: italic">Proc. Proceedings of the IEEE</span> volume 79, pp. 1305&ndash;1320, 1991. <a href="https://ieeexplore.ieee.org/document/97300"><span class="url">https://ieeexplore.ieee.org/document/97300</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Fritz._.Henglein.Type._.Inference._with._.Polymorphic._.Recursion.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._15(2),._pp..._253--2891993https~3a//dl..acm..org/doi/10..1145/169701..169692)"></a><span class="Autobibentry">Fritz Henglein. Type Inference with Polymorphic Recursion. <span style="font-style: italic">ACM Transactions on Programming Languages and Systems</span> 15(2), pp. 253&ndash;289, 1993. <a href="https://dl.acm.org/doi/10.1145/169701.169692"><span class="url">https://dl.acm.org/doi/10.1145/169701.169692</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.K..._.Honda.Types._for._.Dyadic._.Interaction.In._.Proc..._.International._.Conference._on._.Concurrency._.Theory._volume._715,._pp..._509--5231993https~3a//link..springer..com/chapter/10..1007/3-540-57208-2_35)"></a><span class="Autobibentry">K. Honda. Types for Dyadic Interaction. In <span style="font-style: italic">Proc. International Conference on Concurrency Theory</span> volume 715, pp. 509&ndash;523, 1993. <a href="https://link.springer.com/chapter/10.1007/3-540-57208-2_35"><span class="url">https://link.springer.com/chapter/10.1007/3-540-57208-2_35</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.K..._.Honda,._.N..._.Yoshida,._and._.M..._.Carbone.Multiparty._.Asynchronous._.Session._.Types.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._273--2842008https~3a//www..doc..ic..ac..uk/~7eyoshida/multiparty/multiparty..pdf)"></a><span class="Autobibentry">K. Honda, N. Yoshida, and M. Carbone. Multiparty Asynchronous Session Types. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 273&ndash;284, 2008. <a href="https://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf"><span class="url">https://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Kohei._.Honda,._.Vasco._.T..._.Vasconcelos,._and._.Makoto._.Kubo.Language._.Primitives._and._.Type._.Discipline._for._.Structured._.Communication-.Based._.Programming.In._.Proc..._.European._.Symposium._on._on._.Programming,._pp..._122--1381998https~3a//link..springer..com/chapter/10..1007/.B.Fb0053567)"></a><span class="Autobibentry">Kohei Honda, Vasco T. Vasconcelos, and Makoto Kubo. Language Primitives and Type Discipline for Structured Communication-Based Programming. In <span style="font-style: italic">Proc. European Symposium on on Programming</span>, pp. 122&ndash;138, 1998. <a href="https://link.springer.com/chapter/10.1007/BFb0053567"><span class="url">https://link.springer.com/chapter/10.1007/BFb0053567</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.John._.Hughes.Generalising._.Monads._to._.Arrows.Science._of._.Programming._37(1),._pp..._67--1111991https~3a//www..sciencedirect..com/science/article/pii/.S0167642399000234)"></a><span class="Autobibentry">John Hughes. Generalising Monads to Arrows. <span style="font-style: italic">Science of Programming</span> 37(1), pp. 67&ndash;111, 1991. <a href="https://www.sciencedirect.com/science/article/pii/S0167642399000234"><span class="url">https://www.sciencedirect.com/science/article/pii/S0167642399000234</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Galen._.Hunt._and._.James._.Larus.Singularity~3a._.Rethinking._the._.Software._.Stack.Oper..._.Syst..._.Rev..,._pp..._37--492007https~3a//doi..org/10..1145/1243418..1243424)"></a><span class="Autobibentry">Galen Hunt and James Larus. Singularity: Rethinking the Software Stack. <span style="font-style: italic">Oper. Syst. Rev.</span>, pp. 37&ndash;49, 2007. <a href="https://doi.org/10.1145/1243418.1243424"><span class="url">https://doi.org/10.1145/1243418.1243424</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Daniel._.H..._.H..._.Ingalls.Design._.Principles._.Behind._.Smalltalk.University._of._.Virginia..,._.C.S655~3a._.Programming._.Languages2001https~3a//www..cs..virginia..edu/~7eevans/cs655/readings/smalltalk..html)"></a><span class="Autobibentry">Daniel H. H. Ingalls. Design Principles Behind Smalltalk. University of Virginia., CS655: Programming Languages, 2001. <a href="https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html"><span class="url">https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Daniel._.H..._.H..._.Ingalls.The._evolution._of._.Smalltalk~3a._from._.Smalltalk-72._through._.Squeak.In._.Proc..._.History._of._.Programming._.Languages._.I.V2021https~3a//dl..acm..org/doi/10..1145/3386335)"></a><span class="Autobibentry">Daniel H. H. Ingalls. The evolution of Smalltalk: from Smalltalk-72 through Squeak. In <span style="font-style: italic">Proc. History of Programming Languages IV</span>, 2021. <a href="https://dl.acm.org/doi/10.1145/3386335"><span class="url">https://dl.acm.org/doi/10.1145/3386335</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Kenneth._.E..._.Iverson.A._.Programming._.Language.John._.Wiley._~26._.Sons1962https~3a//www..jsoftware..com/papers/.A.P.L..htm)"></a><span class="Autobibentry">Kenneth E. Iverson. A Programming Language. John Wiley &amp; Sons, 1962. <a href="https://www.jsoftware.com/papers/APL.htm"><span class="url">https://www.jsoftware.com/papers/APL.htm</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.C..._.Barry._.Jay.A._.Semantics._for._.Shape.Science._of._.Computer._.Programming._25(2),._pp..._251--2831995https~3a//www..sciencedirect..com/science/article/pii/0167642395000151/)"></a><span class="Autobibentry">C. Barry Jay. A Semantics for Shape. <span style="font-style: italic">Science of Computer Programming</span> 25(2), pp. 251&ndash;283, 1995. <a href="https://www.sciencedirect.com/science/article/pii/0167642395000151/"><span class="url">https://www.sciencedirect.com/science/article/pii/0167642395000151/</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.G..._.Keller,._.M..._.Chakravarty,._.R..._.Leshchinskiy,._.S..._.Peyton._.Jones,._and._.B..._.Lippmeier.Regular,._.Shape-.Polymorphic,._.Parallel._.Arrays._in._.Haskell.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._261--2722010https~3a//dl..acm..org/doi/abs/10..1145/1863543..1863582)"></a><span class="Autobibentry">G. Keller, M. Chakravarty, R. Leshchinskiy, S. Peyton Jones, and B. Lippmeier. Regular, Shape-Polymorphic, Parallel Arrays in Haskell. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 261&ndash;272, 2010. <a href="https://dl.acm.org/doi/abs/10.1145/1863543.1863582"><span class="url">https://dl.acm.org/doi/abs/10.1145/1863543.1863582</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Andrew._.Kennedy.Compiling._with._continuations,._continued.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._1--122007https~3a//dl..acm..org/doi/10..1145/1291220..1291179)"></a><span class="Autobibentry">Andrew Kennedy. Compiling with continuations, continued. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 1&ndash;12, 2007. <a href="https://dl.acm.org/doi/10.1145/1291220.1291179"><span class="url">https://dl.acm.org/doi/10.1145/1291220.1291179</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Naoki._.Kobayashi,._.Benjamin._.Pierce,._and._.David._.Turner.Linearity._and._the._.P.I-.Calculus.A.C.M._.Transactions._on._.Programming._.Languages._and._.Systems._21(5),._pp..._914--9471999https~3a//dl..acm..org/doi/pdf/10..1145/330249..330251)"></a><span class="Autobibentry">Naoki Kobayashi, Benjamin Pierce, and David Turner. Linearity and the PI-Calculus. <span style="font-style: italic">ACM Transactions on Programming Languages and Systems</span> 21(5), pp. 914&ndash;947, 1999. <a href="https://dl.acm.org/doi/pdf/10.1145/330249.330251"><span class="url">https://dl.acm.org/doi/pdf/10.1145/330249.330251</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Eugene._.E..._.Kohlbecker,._.Daniel._.P..._.Friedman,._.Matthias._.Felleisen,._and._.Bruce._.D..._.Duba.Hygienic._macro._expansion.In._.Proc..._.L.I.S.P._and._.Functional._.Programming,._pp..._151--1611986https~3a//dl..acm..org/doi/10..1145/319838..319859)"></a><span class="Autobibentry">Eugene E. Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce D. Duba. Hygienic macro expansion. In <span style="font-style: italic">Proc. LISP and Functional Programming</span>, pp. 151&ndash;161, 1986. <a href="https://dl.acm.org/doi/10.1145/319838.319859"><span class="url">https://dl.acm.org/doi/10.1145/319838.319859</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Eugene._.E..._.Kohlbecker._and._.Mitch._.Wand.Macros._by._example.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._77--841987https~3a//dl..acm..org/doi/10..1145/41625..41632)"></a><span class="Autobibentry">Eugene E. Kohlbecker and Mitch Wand. Macros by example. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 77&ndash;84, 1987. <a href="https://dl.acm.org/doi/10.1145/41625.41632"><span class="url">https://dl.acm.org/doi/10.1145/41625.41632</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robert._.A..._.Kowalski.Predicate._.Logic._as._.Programming._.Language.In._.Proc..._.Information._.Processing,._.Proceedings._of._the._6th._~7b.I.F.I.P~7d._.Congress,._pp..._569--5741974http~3a//www-public..imtbs-tsp..eu/~7egibson/.Teaching/.Teaching-.Reading.Material/.Kowalski74..pdf)"></a><span class="Autobibentry">Robert A. Kowalski. Predicate Logic as Programming Language. In <span style="font-style: italic">Proc. Information Processing, Proceedings of the 6th {IFIP} Congress</span>, pp. 569&ndash;574, 1974. <a href="http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf"><span class="url">http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Neelakantan._.R..._.Krishnaswami,._.Nick._._.Benton,._and._.Jan._._.Hoffmann.Higher-.Order._.Functional._.Reactive._.Programming._in._.Bounded._.Space.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._45--582012https~3a//dl..acm..org/doi/10..1145/2103656..2103665)"></a><span class="Autobibentry">Neelakantan R. Krishnaswami, Nick  Benton, and Jan  Hoffmann. Higher-Order Functional Reactive Programming in Bounded Space. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 45&ndash;58, 2012. <a href="https://dl.acm.org/doi/10.1145/2103656.2103665"><span class="url">https://dl.acm.org/doi/10.1145/2103656.2103665</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Butler._.W..._.Lampson.Protection.Oper..._.Syst..._.Rev..,._pp..._18--241974~7bhttps~3a//doi..org/10..1145/775265..775268~7d)"></a><span class="Autobibentry">Butler W. Lampson. Protection. <span style="font-style: italic">Oper. Syst. Rev.</span>, pp. 18&ndash;24, 1974. <a href="{https://doi.org/10.1145/775265.775268}"><span class="url">{https://doi.org/10.1145/775265.775268}</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Peter._.J..._.Landin.The._mechanical._evaluation._of._expressions.The._.Computer._.Journal._6(4),._pp..._308--3201964https~3a//academic..oup..com/comjnl/article/6/4/308/375725)"></a><span class="Autobibentry">Peter J. Landin. The mechanical evaluation of expressions. <span style="font-style: italic">The Computer Journal</span> 6(4), pp. 308&ndash;320, 1964. <a href="https://academic.oup.com/comjnl/article/6/4/308/375725"><span class="url">https://academic.oup.com/comjnl/article/6/4/308/375725</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Amit._.Levy,._.Campbell,._.Bradford,._.Ghena,._.Branden,._.Giffin,._.Daniel._.B..,._.Pannuto,._.Pat,._.Dutta,._.Prabal,._and._.Levis,._.Philip.Multiprogramming._a._64k.B._.Computer._.Safely._and._.Efficiently.In._.Proc..._.A.C.M._.Symposium._on._.Operating._.Systems._.Principles,._pp..._234--2512017https~3a//doi..org/10..1145/3132747..3132786)"></a><span class="Autobibentry">Amit Levy, Campbell, Bradford, Ghena, Branden, Giffin, Daniel B., Pannuto, Pat, Dutta, Prabal, and Levis, Philip. Multiprogramming a 64kB Computer Safely and Efficiently. In <span style="font-style: italic">Proc. ACM Symposium on Operating Systems Principles</span>, pp. 234&ndash;251, 2017. <a href="https://doi.org/10.1145/3132747.3132786"><span class="url">https://doi.org/10.1145/3132747.3132786</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Harry._.Mairson.Deciding._.M.L._.Typability._is._.Complete._for._.Deterministic._.Exponential._.Time.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._382--4011989https~3a//dl..acm..org/doi/10..1145/96709..96748)"></a><span class="Autobibentry">Harry Mairson. Deciding ML Typability is Complete for Deterministic Exponential Time. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 382&ndash;401, 1989. <a href="https://dl.acm.org/doi/10.1145/96709.96748"><span class="url">https://dl.acm.org/doi/10.1145/96709.96748</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Oleksandr._.Manzyuk,._.Barak._.A..._.Pearlmutter,._.Alexey._.Andreyevich._.Radul,._.David._.R..._.Rush,._and._.Jeffrey._.Mark._.Siskind.Perturbation._.Confusion._in._.Forward._.Automatic._.Differentiation._of._.Higher-.Order._.Functions.Journal._of._.Functional._.Programming._292019https~3a//doi..org/10..1017/.S095679681900008.X)"></a><span class="Autobibentry">Oleksandr Manzyuk, Barak A. Pearlmutter, Alexey Andreyevich Radul, David R. Rush, and Jeffrey Mark Siskind. Perturbation Confusion in Forward Automatic Differentiation of Higher-Order Functions. <span style="font-style: italic">Journal of Functional Programming</span> 29, 2019. <a href="https://doi.org/10.1017/S095679681900008X"><span class="url">https://doi.org/10.1017/S095679681900008X</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Luke._.Maurer,._.Paul._.Downen,._.Zena._.Ariola,._and._.Simon._.Peyton._.Jones.Compiling._without._continuations.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._1--122017https~3a//ix..cs..uoregon..edu/~7epdownen/publications/pldi17_appendix..pdf)"></a><span class="Autobibentry">Luke Maurer, Paul Downen, Zena Ariola, and Simon Peyton Jones. Compiling without continuations. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 1&ndash;12, 2017. <a href="https://ix.cs.uoregon.edu/~pdownen/publications/pldi17_appendix.pdf"><span class="url">https://ix.cs.uoregon.edu/~pdownen/publications/pldi17_appendix.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.John._.Mc.Carthy.Recursive._functions._of._symbolic._expressions._and._their._computation._by._machine,._.Part._.I.Communications._of._the._.A.C.M._4(3),._pp..._182--2001960https~3a//dl..acm..org/doi/10..1145/367177..367199)"></a><span class="Autobibentry">John McCarthy. Recursive functions of symbolic expressions and their computation by machine, Part I. <span style="font-style: italic">Communications of the ACM</span> 4(3), pp. 182&ndash;200, 1960. <a href="https://dl.acm.org/doi/10.1145/367177.367199"><span class="url">https://dl.acm.org/doi/10.1145/367177.367199</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.M..._.D..._.Mc.Ilroy.Mass._.Produced._.Software._.Components.In._.Proc..._.N.A.T.O._.Software._.Engineering._.Conference..._.N.A.T.O._.Scientific._.Affairs._.Division,._pp..._79--871968https~3a//www..scrummanager..net/files/nato1968e..pdf)"></a><span class="Autobibentry">M. D. McIlroy. Mass Produced Software Components. In <span style="font-style: italic">Proc. NATO Software Engineering Conference. NATO Scientific Affairs Division</span>, pp. 79&ndash;87, 1968. <a href="https://www.scrummanager.net/files/nato1968e.pdf"><span class="url">https://www.scrummanager.net/files/nato1968e.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Bernard._.Meyer.Applying._.Design._by._.Contract.I.E.E.E._.Computer._25(10),._pp..._45--511992)"></a><span class="Autobibentry">Bernard Meyer. Applying Design by Contract. <span style="font-style: italic">IEEE Computer</span> 25(10), pp. 45&ndash;51, 1992a.</span></p></td></tr><tr><td><p><a name="(autobib._.Bernard._.Meyer.Eiffel~3a._.The._.Language.Prentice._.Hall1992)"></a><span class="Autobibentry">Bernard Meyer. <span style="font-style: italic">Eiffel: The Language</span>. Prentice Hall, 1992b.</span></p></td></tr><tr><td><p><a name="(autobib._.Leo._.A..._.Meyerovich,._.Arjun._.Guha,._.Jacob._.Baskin,._.Gregory._.H..._.Cooper,._.Michael._.Greenberg,._.Aleks._.Bromfield,._and._.Shriram._.Krishnamurthi.Flapjax~3a._.A._.Programming._.Language._for._.Ajax._.Applications.In._.Proc..._.A.C.M._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages._and._.Applications,._pp..._1--122009https~3a//dl..acm..org/doi/10..1145/1639949..1640091)"></a><span class="Autobibentry">Leo A. Meyerovich, Arjun Guha, Jacob Baskin, Gregory H. Cooper, Michael Greenberg, Aleks Bromfield, and Shriram Krishnamurthi. Flapjax: A Programming Language for Ajax Applications. In <span style="font-style: italic">Proc. ACM Conference on Object-Oriented Programming, Systems, Languages and Applications</span>, pp. 1&ndash;12, 2009. <a href="https://dl.acm.org/doi/10.1145/1639949.1640091"><span class="url">https://dl.acm.org/doi/10.1145/1639949.1640091</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robin._.Milner.Fully._abstract._models._of._typed._~ce~bb-calculi.Theoretical._.Computer._.Science._4(1),._pp..._1--221977https~3a//www..sciencedirect..com/science/article/pii/0304397577900536)"></a><span class="Autobibentry">Robin Milner. Fully abstract models of typed &#955;-calculi. <span style="font-style: italic">Theoretical Computer Science</span> 4(1), pp. 1&ndash;22, 1977. <a href="https://www.sciencedirect.com/science/article/pii/0304397577900536"><span class="url">https://www.sciencedirect.com/science/article/pii/0304397577900536</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robin._.Milner.A._.Theory._of._.Type._.Polymorphism._in._.Programming.Journal._of._.Computer._and._.System._.Sciences._17,._pp..._348--3751978https~3a//homepages..inf..ed..ac..uk/wadler/papers/papers-we-love/milner-type-polymorphism..pdf)"></a><span class="Autobibentry">Robin Milner. A Theory of Type Polymorphism in Programming. <span style="font-style: italic">Journal of Computer and System Sciences</span> 17, pp. 348&ndash;375, 1978. <a href="https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf"><span class="url">https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robin._.Milner.A._.Calculus._of._.Communicating._.Systems.Lecture._.Notes._in._.Computer._.Science1980https~3a//link..springer..com/book/10..1007/3-540-10235-3)"></a><span class="Autobibentry">Robin Milner. A Calculus of Communicating Systems. Lecture Notes in Computer Science, 1980. <a href="https://link.springer.com/book/10.1007/3-540-10235-3"><span class="url">https://link.springer.com/book/10.1007/3-540-10235-3</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robin._.Milner.The._.Polyadic._.P.I-.Calculus~3a._.A._.Tutorial.Logic._and._.Algebra._of._.Specification,._pp..._203--2461991https~3a//link..springer..com/chapter/10..1007/978-3-642-58041-3_6)"></a><span class="Autobibentry">Robin Milner. The Polyadic PI-Calculus: A Tutorial. <span style="font-style: italic">Logic and Algebra of Specification</span>, pp. 203&ndash;246, 1991. <a href="https://link.springer.com/chapter/10.1007/978-3-642-58041-3_6"><span class="url">https://link.springer.com/chapter/10.1007/978-3-642-58041-3_6</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Robin._.Milner,._.Joachim._.Parrow,._and._.David._.Walker.A._.Calculus._of._.Mobile._.Processes.Information._and._.Computation,._pp..._1--11992https~3a//reader..elsevier..com/reader/sd/pii/0890540192900084~3ftoken~3d63.E.D320.E.D.F.C5.C.D8.F1.E42.C5.F3129711055.A0075.B.A0.E46092.E.F.C.F9849.E83802.A.B105792.B4.D135985.A0.E.B8.A.F7.E.F9949.E610)"></a><span class="Autobibentry">Robin Milner, Joachim Parrow, and David Walker. A Calculus of Mobile Processes. <span style="font-style: italic">Information and Computation</span>, pp. 1&ndash;1, 1992. <a href="https://reader.elsevier.com/reader/sd/pii/0890540192900084?token=63ED320EDFC5CD8F1E42C5F3129711055A0075BA0E46092EFCF9849E83802AB105792B4D135985A0EB8AF7EF9949E610"><span class="url">https://reader.elsevier.com/reader/sd/pii/0890540192900084?token=63ED320EDFC5CD8F1E42C5F3129711055A0075BA0E46092EFCF9849E83802AB105792B4D135985A0EB8AF7EF9949E610</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.James._.Hiram._.Morris.Lambda-.Calculus._.Models._of._.Programming._.Languages.Ph...D..._dissertation,._.Massachusetts._.Institute._of._.Technology1968)"></a><span class="Autobibentry">James Hiram Morris. Lambda-Calculus Models of Programming Languages. Ph.D. dissertation, Massachusetts Institute of Technology, 1968.</span></p></td></tr><tr><td><p><a name="(autobib._.Henrik._.Nilsson,._.Antony._.Courtney,._and._.John._.Peterson.Functional._.Reactive._.Programming,._.Continued.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._51--642002https~3a//dl..acm..org/doi/10..1145/581690..581695)"></a><span class="Autobibentry">Henrik Nilsson, Antony Courtney, and John Peterson. Functional Reactive Programming, Continued. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 51&ndash;64, 2002. <a href="https://dl.acm.org/doi/10.1145/581690.581695"><span class="url">https://dl.acm.org/doi/10.1145/581690.581695</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Martin._.Odersky._and._.Philip._.Wadler.Pizza._into._.Java~3a._.Translating._.Theory._into._.Practice.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._146--1591997https~3a//doi..org/10..1145/263699..263715)"></a><span class="Autobibentry">Martin Odersky and Philip Wadler. Pizza into Java: Translating Theory into Practice. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 146&ndash;159, 1997. <a href="https://doi.org/10.1145/263699.263715"><span class="url">https://doi.org/10.1145/263699.263715</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.D..._.L..._.Parnas.A._.Technique._for._.Software._.Module._.Specification._with._.Examples.Communications._of._the._.A.C.M._15(5),._pp..._330--3361972https~3a//doi..org/10..1145/355602..361309)"></a><span class="Autobibentry">D. L. Parnas. A Technique for Software Module Specification with Examples. <span style="font-style: italic">Communications of the ACM</span> 15(5), pp. 330&ndash;336, 1972. <a href="https://doi.org/10.1145/355602.361309"><span class="url">https://doi.org/10.1145/355602.361309</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Benjamin._.Pierce._and._.Davide._.Sangiorgi.Typing._and._.Sub-typing._of._.Mobile._.Processes.In._.Proc..._.Logic._in._.Computer._.Science,._pp..._376--3851994https~3a//ieeexplore..ieee..org/document/287570)"></a><span class="Autobibentry">Benjamin Pierce and Davide Sangiorgi. Typing and Sub-typing of Mobile Processes. In <span style="font-style: italic">Proc. Logic in Computer Science</span>, pp. 376&ndash;385, 1994. <a href="https://ieeexplore.ieee.org/document/287570"><span class="url">https://ieeexplore.ieee.org/document/287570</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Rob._.Pike.Systems._.Software._.Research._is._.Irrelevant.Bell._.Labs,._.Lucent._.Technologies..,._.A._.Plan._9._.Polemic2000https~3a//tianyin..github..io/misc/irrelevant..pdf)"></a><span class="Autobibentry">Rob Pike. Systems Software Research is Irrelevant. Bell Labs, Lucent Technologies., A Plan 9 Polemic, 2000. <a href="https://tianyin.github.io/misc/irrelevant.pdf"><span class="url">https://tianyin.github.io/misc/irrelevant.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Atze._van._der._.Ploeg._and._.Koen._._.Claessen.Practical._.Principled._.F.R.P~3a._.Forget._the._.Past,._.Change._the._.Future,._.F.R.P.Now!.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._302--3142015https~3a//dl..acm..org/doi/10..1145/2784731..2784752)"></a><span class="Autobibentry">Atze van der Ploeg and Koen  Claessen. Practical Principled FRP: Forget the Past, Change the Future, FRPNow! In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 302&ndash;314, 2015. <a href="https://dl.acm.org/doi/10.1145/2784731.2784752"><span class="url">https://dl.acm.org/doi/10.1145/2784731.2784752</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Godon._.D..._.Plotkin.Call-by-name,._call-by-value,._and._the._lambda._calculus.Theoretical._.Computer._.Science._1n,._pp..._125--1591977https~3a//homepages..inf..ed..ac..uk/gdp/publications/cbn_cbv_lambda..pdf)"></a><span class="Autobibentry">Godon D. Plotkin. Call-by-name, call-by-value, and the lambda calculus. <span style="font-style: italic">Theoretical Computer Science</span> 1n, pp. 125&ndash;159, 1977a. <a href="https://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf"><span class="url">https://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Godon._.D..._.Plotkin.L.C.F._considered._as._a._programming._language.Theoretical._.Computer._.Science._3(5),._pp..._223--2551977https~3a//homepages..inf..ed..ac..uk/gdp/publications/.L.C.F..pdf)"></a><span class="Autobibentry">Godon D. Plotkin. LCF considered as a programming language. <span style="font-style: italic">Theoretical Computer Science</span> 3(5), pp. 223&ndash;255, 1977b. <a href="https://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf"><span class="url">https://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Godon._.D..._.Plotkin.A._structural._approach._to._operational._semantics.University._of._.Aarhus,._.D.A.I.M.I._.F.N-191981https~3a//homepages..inf..ed..ac..uk/gdp/publications/.S.O.S..ps)"></a><span class="Autobibentry">Godon D. Plotkin. A structural approach to operational semantics. University of Aarhus, DAIMI FN-19, 1981. <a href="https://homepages.inf.ed.ac.uk/gdp/publications/SOS.ps"><span class="url">https://homepages.inf.ed.ac.uk/gdp/publications/SOS.ps</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.L...B..._.Rall.Differentiation._in._~7b.P.A.S.C.A.L~7d-~7b.S.C~7d.Transactions._on._.Mathematical._.Software._10(2),._pp..._161--1841984https~3a//doi..org/10..1145/399..418)"></a><span class="Autobibentry">L.B. Rall. Differentiation in {PASCAL}-{SC}. <span style="font-style: italic">Transactions on Mathematical Software</span> 10(2), pp. 161&ndash;184, 1984. <a href="https://doi.org/10.1145/399.418"><span class="url">https://doi.org/10.1145/399.418</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.David._.D..._.Redell,._.Dalal,._.Yogen._.K..,._.Horsley,._.Thomas._.R..,._.Lauer,._.Hugh._.C..,._.Lynch,._.William._.C..,._.Mc.Jones,._.Paul._.R..,._.Murray,._.Hal._.G..,._and._.Purcell,._.Stephen._.C...Pilot~3a._.An._.Operating._.System._for._a._.Personal._.Computer.Communications._of._the._.A.C.M._23(2),._pp..._81--921980https~3a//doi..org/10..1145/358818..358822)"></a><span class="Autobibentry">David D. Redell, Dalal, Yogen K., Horsley, Thomas R., Lauer, Hugh C., Lynch, William C., McJones, Paul R., Murray, Hal G., and Purcell, Stephen C. Pilot: An Operating System for a Personal Computer. <span style="font-style: italic">Communications of the ACM</span> 23(2), pp. 81&ndash;92, 1980. <a href="https://doi.org/10.1145/358818.358822"><span class="url">https://doi.org/10.1145/358818.358822</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.John._.C..._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference,._pp..._717--7401972https~3a//dl..acm..org/doi/10..1145/800194..805852)"></a><span class="Autobibentry">John C. Reynolds. Definitional interpreters for higher-order programming languages. In <span style="font-style: italic">Proc. ACM Annual Conference</span>, pp. 717&ndash;740, 1972. <a href="https://dl.acm.org/doi/10.1145/800194.805852"><span class="url">https://dl.acm.org/doi/10.1145/800194.805852</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.John._.C..._.Reynolds.Towards._a._.Theory._of._.Type._.Structure.In._.Proc..._.Programming._.Symposium,._pp..._408--4251974https~3a//doi..org/10..1007/3-540-06859-7_148)"></a><span class="Autobibentry">John C. Reynolds. Towards a Theory of Type Structure. In <span style="font-style: italic">Proc. Programming Symposium</span>, pp. 408&ndash;425, 1974. <a href="https://doi.org/10.1007/3-540-06859-7_148"><span class="url">https://doi.org/10.1007/3-540-06859-7_148</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Amr._.Sabry._and._.Matthias._.Fellisen.Reasoning._about._.Programs._in._.Continuation._.Passing._.Style.In._.Proc..._.L.I.S.P._and._.Functional._.Programming,._pp..._288--2981992https~3a//dl..acm..org/doi/10..1145/141471..141563)"></a><span class="Autobibentry">Amr Sabry and Matthias Fellisen. Reasoning about Programs in Continuation Passing Style. In <span style="font-style: italic">Proc. LISP and Functional Programming</span>, pp. 288&ndash;298, 1992. <a href="https://dl.acm.org/doi/10.1145/141471.141563"><span class="url">https://dl.acm.org/doi/10.1145/141471.141563</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Jeremy._.G..._.Siek._and._.Walid._.Taha.Gradual._.Typing._for._.Functional._.Languages.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming,._pp..._81--922006)"></a><span class="Autobibentry">Jeremy G. Siek and Walid Taha. Gradual Typing for Functional Languages. In <span style="font-style: italic">Proc. Workshop on Scheme and Functional Programming</span>, pp. 81&ndash;92, 2006.</span></p></td></tr><tr><td><p><a name="(autobib._.Jeffrey._.Mark._.Siskind._and._.Barak._.A..._.Pearlmutter.First-.Class._.Nonstandard._.Interpretations._by._.Opening._.Closures.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._71--762007https~3a//doi..org/10..1145/1190216..1190230)"></a><span class="Autobibentry">Jeffrey Mark Siskind and Barak A. Pearlmutter. First-Class Nonstandard Interpretations by Opening Closures. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 71&ndash;76, 2007a. <a href="https://doi.org/10.1145/1190216.1190230"><span class="url">https://doi.org/10.1145/1190216.1190230</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Jeffrey._.Mark._.Siskind._and._.Barak._.A..._.Pearlmutter.Lazy._.Multivariate._.Higher-.Order._.Forward-.Mode._~7b.A.D~7d.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._155--1602007https~3a//doi..org/10..1145/1190216..1190242)"></a><span class="Autobibentry">Jeffrey Mark Siskind and Barak A. Pearlmutter. Lazy Multivariate Higher-Order Forward-Mode {AD}. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 155&ndash;160, 2007b. <a href="https://doi.org/10.1145/1190216.1190242"><span class="url">https://doi.org/10.1145/1190216.1190242</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Justin._.Slepak,._.Olin._.Shivers,._and._.Panagiotis._.Manolios.An._.Array-.Oriented._.Language._with._.Static._.Rank._.Polymorphism.In._.Proc..._.European._.Symposium._on._on._.Programming,._pp..._27--462014https~3a//link..springer..com/chapter/10..1007/978-3-642-54833-8_3)"></a><span class="Autobibentry">Justin Slepak, Olin Shivers, and Panagiotis Manolios. An Array-Oriented Language with Static Rank Polymorphism. In <span style="font-style: italic">Proc. European Symposium on on Programming</span>, pp. 27&ndash;46, 2014. <a href="https://link.springer.com/chapter/10.1007/978-3-642-54833-8_3"><span class="url">https://link.springer.com/chapter/10.1007/978-3-642-54833-8_3</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.B..._.Speelpenning.Compiling._.Fast._.Partial._.Derivatives._of._.Functions._.Given._by._algorithms.Ph...D..._dissertation,._.University._of._.Illinois,._.Urbana-.Champagne1980https~3a//doi..org/10..2172/5254402)"></a><span class="Autobibentry">B. Speelpenning. Compiling Fast Partial Derivatives of Functions Given by algorithms. Ph.D. dissertation, University of Illinois, Urbana-Champagne, 1980. <a href="https://doi.org/10.2172/5254402"><span class="url">https://doi.org/10.2172/5254402</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Joe._.Stoy.Denotational._.Semantics~3a._.The._.Scott-.Strachey._.Approach._to._.Programming._.Language._.Theory.M.I.T._.Press1977https~3a//dl..acm..org/doi/book/10..5555/540155)"></a><span class="Autobibentry">Joe Stoy. <span style="font-style: italic">Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory</span>. MIT Press, 1977. <a href="https://dl.acm.org/doi/book/10.5555/540155"><span class="url">https://dl.acm.org/doi/book/10.5555/540155</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.K..._.Takeuchi,._.K..._.Honda,._and._.M..._.Kubo.An._.Interaction-based._.Language._and._its._.Typing._.System.In._.Proc..._.International._.Conference._on._.Parallel._.Architectures._and._.Languages._.Europe,._pp..._398--4131994https~3a//link..springer..com/chapter/10..1007/3-540-58184-7_118)"></a><span class="Autobibentry">K. Takeuchi, K. Honda, and M. Kubo. An Interaction-based Language and its Typing System. In <span style="font-style: italic">Proc. International Conference on Parallel Architectures and Languages Europe</span>, pp. 398&ndash;413, 1994. <a href="https://link.springer.com/chapter/10.1007/3-540-58184-7_118"><span class="url">https://link.springer.com/chapter/10.1007/3-540-58184-7_118</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Satish._.Thatte.A._.Type._.System._for._.Implicit._.Scaling.Science._of._.Computer._.Programming._17(1),._pp..._217--2451991https~3a//www..sciencedirect..com/science/article/pii/0167642391900405)"></a><span class="Autobibentry">Satish Thatte. A Type System for Implicit Scaling. <span style="font-style: italic">Science of Computer Programming</span> 17(1), pp. 217&ndash;245, 1991. <a href="https://www.sciencedirect.com/science/article/pii/0167642391900405"><span class="url">https://www.sciencedirect.com/science/article/pii/0167642391900405</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Sam._.Tobin-.Hochstadt._and._.Matthias._.Felleisen.Interlanguage._.Migration~3a._from._.Scripts._to._.Programs.In._.Proc..._.Dynamic._.Languages._.Symposium,._pp..._964--9742006)"></a><span class="Autobibentry">Sam Tobin-Hochstadt and Matthias Felleisen. Interlanguage Migration: from Scripts to Programs. In <span style="font-style: italic">Proc. Dynamic Languages Symposium</span>, pp. 964&ndash;974, 2006.</span></p></td></tr><tr><td><p><a name="(autobib._.Michael._.M..._.Vitousek,._.Andrew._.Kent,._.Jeremy._.G..._.Siek,._and._.Jim._.Baker.Design._and._.Evaluation._of._.Gradual._.Typing._for._.Python.In._.Proc..._.Dynamic._.Languages._.Symposium,._pp..._45--562014https~3a//wphomes..soic..indiana..edu/jsiek/files/2014/03/retic-python..pdf)"></a><span class="Autobibentry">Michael M. Vitousek, Andrew Kent, Jeremy G. Siek, and Jim Baker. Design and Evaluation of Gradual Typing for Python. In <span style="font-style: italic">Proc. Dynamic Languages Symposium</span>, pp. 45&ndash;56, 2014. <a href="https://wphomes.soic.indiana.edu/jsiek/files/2014/03/retic-python.pdf"><span class="url">https://wphomes.soic.indiana.edu/jsiek/files/2014/03/retic-python.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Michael._.M..._.Vitousek,._.Cameron._.Swords,._and._.Jeremy._.G..._.Siek.Big._.Types._in._.Little._.Runtime~3a._.Open-.World._.Soundness._and._.Collaborative._.Blame._for._.Gradual._.Type._.Systems.In._.Proc..._.A.C.M._.Symposium._on._.Principles._of._.Programming._.Languages,._pp..._762--7742017https~3a//dl..acm..org/doi/10..1145/3009837..3009849)"></a><span class="Autobibentry">Michael M. Vitousek, Cameron Swords, and Jeremy G. Siek. Big Types in Little Runtime: Open-World Soundness and Collaborative Blame for Gradual Type Systems. In <span style="font-style: italic">Proc. ACM Symposium on Principles of Programming Languages</span>, pp. 762&ndash;774, 2017. <a href="https://dl.acm.org/doi/10.1145/3009837.3009849"><span class="url">https://dl.acm.org/doi/10.1145/3009837.3009849</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.William._.W..._.Wadge._and._.Edward._.A..._.Ashcroft.Lucid,._the._.Dataflow._.Programming._.Langugage.Academic._.Press1985http~3a//worrydream..com/refs/.Wadge~2520-~2520.Lucid,~2520the~2520.Dataflow~2520.Programming~2520.Language..pdf)"></a><span class="Autobibentry">William W. Wadge and Edward A. Ashcroft. Lucid, the Dataflow Programming Langugage. Academic Press, 1985. <a href="http://worrydream.com/refs/Wadge%20-%20Lucid,%20the%20Dataflow%20Programming%20Language.pdf"><span class="url">http://worrydream.com/refs/Wadge%20-%20Lucid,%20the%20Dataflow%20Programming%20Language.pdf</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.P..._.Wadler.Propositions._as._.Sessions.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._273--2862012https~3a//dl..acm..org/doi/10..1145/2364527..2364568)"></a><span class="Autobibentry">P. Wadler. Propositions as Sessions. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 273&ndash;286, 2012. <a href="https://dl.acm.org/doi/10.1145/2364527.2364568"><span class="url">https://dl.acm.org/doi/10.1145/2364527.2364568</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Zhanyong._.Wan._and._.Paul._.Hudak.Functional._.Reactive._.Programming._from._.First._.Principles.In._.Proc..._.A.C.M._.Conference._on._.Programming._.Language._.Design._and._.Implementation,._pp..._242--2522000https~3a//dl..acm..org/doi/10..1145/349299..349331)"></a><span class="Autobibentry">Zhanyong Wan and Paul Hudak. Functional Reactive Programming from First Principles. In <span style="font-style: italic">Proc. ACM Conference on Programming Language Design and Implementation</span>, pp. 242&ndash;252, 2000. <a href="https://dl.acm.org/doi/10.1145/349299.349331"><span class="url">https://dl.acm.org/doi/10.1145/349299.349331</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Zhanyong._.Wan,._.Walid._.Taha,._and._.Paul._.Hudak.Real-time._.F.R.P.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming,._pp..._45--582001https~3a//dl..acm..org/doi/10..1145/507669..507654)"></a><span class="Autobibentry">Zhanyong Wan, Walid Taha, and Paul Hudak. Real-time FRP. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, pp. 45&ndash;58, 2001. <a href="https://dl.acm.org/doi/10.1145/507669.507654"><span class="url">https://dl.acm.org/doi/10.1145/507669.507654</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.R..._.E..._.Wengert.A._.Simple._.Automatic._.Derivative._.Evaluation._.Program.Communications._of._the._.A.C.M._7,._pp..._463--4641964https~3a//doi..org/10..1145/355586..364791)"></a><span class="Autobibentry">R. E. Wengert. A Simple Automatic Derivative Evaluation Program. <span style="font-style: italic">Communications of the ACM</span> 7, pp. 463&ndash;464, 1964. <a href="https://doi.org/10.1145/355586.364791"><span class="url">https://doi.org/10.1145/355586.364791</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Niklaus._.Wirth._and._.Ju~cc~88rg._.Gutknecht.Project._.Oberon~3a._.The._.Design._of._an._.Operating._.System._and._.Compiler.A.C.M._.Press1991https~3a//people..inf..ethz..ch/wirth/.Project.Oberon/.P.O...System..pdf)"></a><span class="Autobibentry">Niklaus Wirth and Ju&#776;rg Gutknecht. Project Oberon: The Design of an Operating System and Compiler. ACM Press, 1991. <a href="https://people.inf.ethz.ch/wirth/ProjectOberon/PO.System.pdf"><span class="url">https://people.inf.ethz.ch/wirth/ProjectOberon/PO.System.pdf</span></a></span></p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="form.html" title="backward to &quot;Assessment&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;History of Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
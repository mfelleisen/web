<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>4&nbsp;First-Class Functions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Machines and Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="ch_pl.html" class="tocviewlink" data-pltdoc="x">Programming Languages</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ch_arith.html" class="tocviewlink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="ch_algebra.html" class="tocviewlink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ch_mutation.html" class="tocviewlink" data-pltdoc="x">Mutable Objects</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="ch_cc.html" class="tocviewlink" data-pltdoc="x">Full Control</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="ch_express.html" class="tocviewlink" data-pltdoc="x">The Dimensions</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="ch_space.html" class="tocviewlink" data-pltdoc="x">Space</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="ch_types.html" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="ch_futures.html" class="tocviewlink" data-pltdoc="x">Futures</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._sec~3alambda%29" class="tocviewlink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._sec~3arec%29" class="tocviewlink" data-pltdoc="x">What is Recursion</a></td></tr><tr><td align="right">4.3&nbsp;</td><td><a href="#%28part._sec~3acek%29" class="tocviewlink" data-pltdoc="x">The CEK Machine</a></td></tr><tr><td align="right">4.4&nbsp;</td><td><a href="#%28part._sec~3atheorems3%29" class="tocviewlink" data-pltdoc="x">The Type Soundness Theorem</a></td></tr><tr><td align="right">4.5&nbsp;</td><td><a href="#%28part._sec~3a4sum%29" class="tocviewlink" data-pltdoc="x">Summary</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8.0.1</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_algebra.html" title="backward to &quot;3 Algebra, Your Second Programming
Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_mutation.html" title="forward to &quot;5 Mutable Objects&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._ch~3alambda)"></a>First-Class Functions</h3><p>If you are a student reading this text, you are likely to have encouuntered the
idea of &ldquo;first class&rdquo; functions, which do not show up in your ordinary algebra
course.<span class="refelem"><span class="refcolumn"><span class="refcontent">But if you took calculus courses and paid close attention,
you might have noticed your teacher sneaking them in right below your eyes.</span></span></span>
.The phrase &ldquo;first class&rdquo; means that a function can consume functions, return
functions, place functions in data structures (say arrays, hash maps, or
lists). In short, functions are values just like numbers, characters, strings,
etc.</p><p>While almost any widely-used, contemporary programming language comes with
first-class functions, the designers of mainstream programming languages
embraced little more than the algebra-based idea of programming for four
decades. It was programming language researchers who started exploring functions
as values by 1960. Theoretically inclined researchers pointed to Church&rsquo;s lambda
calculus as a motivation; practical designers ones recognized the expressive
power of first-class functions.</p><p>Intuitively, adding such powers to &ldquo;algebra&rdquo; seems to suggest great gains and
On one hand, the uniformity of treating functions as regular values lowers the
syntactic complexity of a language and reduces the number of transition rules in
the CEK machine. This kind of simplification is what researchers imply with
&ldquo;uniformity.&rdquo; On the other hand, these simplifications hide that, for example,
it is no longer possible to combine the environment and the control stack into a
single stack-like data structure. Dynamically allocating and managing the
environment becomes mandatory.</p><p>This chapter presents these trade-offs. It starts with two section that simplify
the syntax of the Algebra language and show that nothing is lost. The third
section investigates the revision of the CEK machine, both in terms of its
simplified transition rules and the increased complexity of environments. The
section on theorems introduces the most widely investigated form of theorems in
programming languages: type soundness.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3alambda%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>First-Class Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3arec%29" class="toclink" data-pltdoc="x">4.2<span class="hspace">&nbsp;</span>What is Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Crazy_.Combinators%29" class="toclink" data-pltdoc="x">4.2.1<span class="hspace">&nbsp;</span>Crazy Combinators</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3acek%29" class="toclink" data-pltdoc="x">4.3<span class="hspace">&nbsp;</span>The CEK Machine</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3atheorems3%29" class="toclink" data-pltdoc="x">4.4<span class="hspace">&nbsp;</span>The Type Soundness Theorem</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3a4sum%29" class="toclink" data-pltdoc="x">4.5<span class="hspace">&nbsp;</span>Summary</a></p></td></tr></table><h4>4.1<tt>&nbsp;</tt><a name="(part._sec~3alambda)"></a>First-Class Functions</h4><p><div class="SIntrapara"><span style="font-weight: bold">Nameless Functions</span> A programming language like <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> merges
two different ideas into one when it forces programmers to define functions like
this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">fun["f","z",add[x,9]]</span></p></blockquote></div><div class="SIntrapara">This definition simultaneously <span class="emph">names</span> the function ("f") and
<span class="emph">specifies</span> how it works (it adds <span class="RktVal">9</span> to x). In a way, the CEK
machine for the functional part of <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> makes this merger explicit
by sticking the entire function definition into the environment and retrieving
it from there by name (see the first two rules in <a href="ch_algebra.html#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a>).</div></p><p><div class="SIntrapara">By contrast, <span class="RktSym">let</span> merely names (the value of) an expression. For
example, in the context of the above <span class="RktSym">fun</span> definition, the following
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">let["z",call["f",1]]</span></p></blockquote></div><div class="SIntrapara">would assign "z" to the result of <span class="RktPn">call["f",1]</span>. Hence any reference to
"z" in its scope will yield <span class="RktVal">10</span>.</div></p><p><div class="SIntrapara">So imagine for a moment a language feature that just creates functions without
naming them:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">parameter</span><span class="RktRdr">,</span><span class="RktSym">body</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">For example,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">lam["z",add["z",9]]</span></p></blockquote></div><div class="SIntrapara">would create the same function that is named "f" in the above definition, but it
would not assign any name to it. Instead we might use <span class="RktSym">let</span> to do so:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">let["f",lam["z",add["z",9]]]</span></p></blockquote></div><div class="SIntrapara">Now, if we could replace the <span class="RktSym">fun</span> definition with this <span class="RktSym">let</span>
definition, then any reference to "f" in its scope would still call result in the
same calculation as before, namely, adding <span class="RktVal">9</span> to the given argument.</div></p><p><div class="SIntrapara">Once we separate the act of naming functions from the act of creating them, it
is short step to argue that functions are values just like numbers. In
particular, it is no longer necessary for the names of functions to show up only
in the name position of <span class="RktSym">call</span> nodes. Conversely, it also isn&rsquo;t necessary
to restrict this position in <span class="RktSym">call</span> to names. So, this program
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="highlighted"><span class="RktPn">call[lam["f","f"],lam["z",add["z",9]]]</span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">first computes the function with the inner <span class="RktSym">call</span> and then applies this
function to <span class="RktVal">1</span>. In other words, this program is equivalent to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">block[fun["f","z",add["z",9]],call["f",1]]</span></p></blockquote></div><div class="SIntrapara">As a matter of fact, the nested <span class="RktSym">call</span> even temporarily assigns the name
"f" to the function <span class="RktPn">lam["z",add["z",9]]</span> with this inner call.</div></p><p><div class="SIntrapara">In summary, it seems possible to replace <span class="RktSym">block</span>, <span class="RktSym">let</span>, and
<span class="RktSym">fun</span> with just <span class="RktSym">lam</span>. Here is an abstract syntax definition that
succinctly summarizes the proposal:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._lambda)"></a><span style="font-style: italic">AST-lambda</span><span class="stt">:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">e = n | </span><span class="RktPn">add[e,e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><span class="RktPn">mul[e,e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">|</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">x | </span><span class="RktPn">call[e,e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><span class="RktPn">lam[x,e]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x = </span><a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">n = Number</span></p></td></tr></table></div><div class="SIntrapara">The second line of the grammar production of <span class="stt">e</span> is often referred to as the
&ldquo;lambda calculus,&rdquo; because it resembles the syntax of a system of calculation
that Church proposed in the late 1920s in response to Goedel&rsquo;s algebra-like
language for proving theorems about the foundations of mathematics.</div></p><p><span style="font-weight: bold">Scope</span> Whenever you approach a new programming language, it is imperative
to understand the scoping rules. As the preceding chapter explains, every
definition of some name&#8212;<wbr></wbr>whether it is a <span class="RktSym">let</span>-style definition or a
function parameter&#8212;<wbr></wbr>comes with a scope in which it is valid; and in turn, it is
irrelevant for all pieces of program text outside this scope.</p><p><div class="SIntrapara">For <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>, there is only one scoping rule:
</div><div class="SIntrapara"><blockquote><p><span class="RktPn">lam[x,e]</span> defines x and its scope is e except for all nested
<span class="RktSym">lam</span> trees that define the same name.</p></blockquote></div></p><p><span style="font-weight: bold">Substitution Explains It All</span> The programming language <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>
generalizes <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> and its function-call mechanism. While the
extended language still uses call-by-value to invoke functions, the notion of
value has changed and so has the shape of function calls. So, explaining its
meaning requires two steps.</p><p><div class="SIntrapara">First we expand the set of arguments that functions may consume:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._value)"></a><span style="font-style: italic">AST-value</span><span class="stt">:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">v = n | </span><span class="RktPn">lam[x,e]</span></p></td></tr></table></div><div class="SIntrapara">Functions in <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> may consume numbers <span class="emph">and</span> functions, which
are written as <span class="RktSym">lam</span> expressions.</div></p><p><div class="SIntrapara">Second, we need a rule that says how function application works. But, we
actually know that we just need to substitute the argument for the parameter
into the body of the function. And this yields the three fundamental transition
rules for <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">current state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">next state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">call[lam[x,e],v]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">e [x &lt;- v]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>beta value</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">add[k,l]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">n</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">mul[k,l]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">n</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Just like for <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> and <a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>, these rules may be
used at <span class="emph">any</span> point in the program to simplify the
expression. <a href="ch_arith.html#%28part._sec~3astepper-1%29" data-pltdoc="x">A State Machine for Arithmetic: Non-Determinism</a> expresses the notion of &ldquo;point in a program&rdquo;
with contexts. <a href="#%28counter._%28exercise._ex~3actxt-lc%29%29" data-pltdoc="x">Exercise&nbsp;48</a> asks you to develop contexts for
<a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>.</div></p><p><span style="font-weight: bold">Substitution Is Hard</span> The <span class="refelem"><span class="refcolumn"><span class="refcontent">This problem would also be present
for the <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> language, if it came with calculation rules like
those presented here.</span></span></span> description of the semantics glosses over the details of
substitution. While the basics of substitution are straightforward&#8212;<wbr></wbr>replace all
occurrences of the variable with the value&#8212;<wbr></wbr>it is subtle when it may be used at
any point in a program.</p><p><div class="SIntrapara">Consider this sample program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">w</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call[lam["y","w"],1]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["z","y"]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Three sub-expressions are redexes, namely, all three <span class="RktSym">call</span> nodes. Reducing
the outer one replaces "y" with <span class="RktVal">0</span>; to reduce the second one it is
necessary to replace "w" with <span class="RktPn">lam["z","y"]</span>; and for the third one, (a
different) "y" becomes <span class="RktVal">1</span>.</div></p><p>Figure-ref{fig:lc-homework} shows the resulting graph of possibilities if
variable substitution is insensitive to scope. The bottom of the figure shows
two distinct results: <span class="RktPn">lam["z",1]</span> and <span class="RktPn">lam["z",0]</span>. It is
impossible for both of them to be the correct answer.</p><p>Stop! Which one is the correct answer?</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_12.png" alt="image" width="657.83203125" height="503.328125"/></p></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3alc-homework))" x-target-lift="Figure"></a>Figure&nbsp;27: </span>An Arithmetic expression and the possible ways of arriving at an answer</span></p></blockquote><p>A close look at the graph reveals that the middle reduction breaks a part of the
substitution rule. By blithely replacing "w" with <span class="RktPn">lam["z","y"]</span> the "y" in
this second term is moved from the scope of the outermost <span class="RktPn">lam["y",{--}]</span>
to the innermost one <span class="RktPn">lam["y",{--}]</span>. The scoping rule explicitly
states, however, that the scope of a <span class="RktSym">lam</span> variable does <span class="emph">not</span>
include nested <span class="RktSym">lam</span> expressions that define the same name.</p><p><div class="SIntrapara">This problem explains why we define
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">substitution</span> as the process of replacing all occurrences of a variable
x with a value v in its scope within <span class="stt">e</span>.</p></blockquote></div><div class="SIntrapara">It is the qualification &ldquo;in its scope&rdquo; that makes our example work, because it
rules out the middle reduction from the top-most node in the graph and thus any
possibility of reaching <span class="RktPn">(</span><span class="RktSym">lam</span><span class="stt"> </span><span class="RktSym">z</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span>, the wrong result.</div></p><p>Generally speaking, substitution is an intuitive procedure that people can
usually manage with small examples. That is, they can calculate out the result
of small program fragments or at least use substtitution-based thinking to
predict the behavior up to free variables.  In this sense, substitution explains
the meaning of the <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> language. But, it is a complex procedure
and injecting it as a single step into the description of the semantics demands
a large leap. Furthermore, as already discussed, the substitution procedure
traverses the abstract syntax tree in the same as any abstract state machine
that determines the result in a deterministic manner. Hence, this book presents
the true semantics of <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> via a CEK machine.</p><p><div class="SIntrapara"><span style="font-weight: bold">Variable Definitions, Modules, and More</span> Even back in the 1960s,
programming language researchers pointed out that the immediate application of a
<span class="RktSym">lam</span> function to value v is like a <span class="RktSym">let</span> definition. In
programming notation,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">block[let[x,e1],e2]</span></p></blockquote></div><div class="SIntrapara">is equivalent to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[lam[x,e2],e1]</span></p></blockquote></div><div class="SIntrapara">This kind of equivalence is dubbed <span style="font-style: italic">syntactic sugar</span>, because it is a
mere local transformation of one schematic AST into another.</div></p><p>The idea of creating a <span class="RktSym">lam</span> function and to apply it immediately has
several other uses. In a language without modules, for example, it can be used
to create a scope for a set of definitions, to return only some of the defined
values, and to rebind them to the same names. This has the effect of hiding some
of the definitions inside the <span class="RktSym">lam</span> function&rsquo;s scope.</p><p>Recently, the trick has become popular in other languages. In the JavaScript
community, it is considered a pattern and has the name <span style="font-style: italic">immediately
invoked functions</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Delayed Evaluation</span> Church&rsquo;s original lambda calculus uses a different
rule for the evaluation of function applications:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">current state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">next state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">call[lam[x,e1],e2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">e1 [x &lt;- e2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>beta</p></td></tr></table></blockquote></div><div class="SIntrapara">It generalizes the idea of call-by-name parameter passing, discussed in
<a href="ch_algebra.html#%28part._sub~3aname%29" data-pltdoc="x">Delayed Evaluation: Call By Name</a>. No language with first-class functions implements
call-by-name this way. Lazy languages use a cache to avoid the repeated
evaluation of <span class="stt">e2</span>, and this idea is discussed in <a href="ch_mutation.html#%28part._cesk._sec~3alaziness%29" data-pltdoc="x">Call by Need</a>.</div></p><p><span style="font-weight: bold">Exercises</span> The following exercises aim to deepen your understanding of the
syntax and substitution semantics of <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>.</p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3ajson-lc))"></a><span style="font-weight: bold">Exercise</span>&nbsp;47. Existing <span class="refelem"><span class="refcolumn"><span class="refcontent">Instructors need to do the second
part of this exercise if they wish to grade it across all students.</span></span></span> programming
languages uses many different forms of syntax for a <span class="RktSym">lam</span> expression. For
example, <span class="RktPn">lam["z",add["z",9]]</span> definition might look like any of the
following:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">function (z) return z + 9</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(lambda z (+ z 9))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">fun z -&gt; z + 9</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\z -&gt; z + 9</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(z) -&gt; z + 9</span></p></td></tr></table></div><div class="SIntrapara">If your favorite language is not represented, render the example in yours.</div></p><p>Design a concrete JSON syntax for <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> and then implement a parser
that maps the concrete syntax into the abstract syntax. <a href="#%28counter._%28exercise._ex~3ajson-lc%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3actxt-lc))"></a><span style="font-weight: bold">Exercise</span>&nbsp;48. Develop a grammar that describes the possible contexts
in which the transitions for <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> may be applied. Take a look at
<a href="ch_arith.html#%28tech._ast._arithmetic._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic-C</span></a> in <a href="ch_arith.html#%28part._sec~3astepper-1%29" data-pltdoc="x">A State Machine for Arithmetic: Non-Determinism</a> for the grammar of contexts for
<a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>. <a href="#%28counter._%28exercise._ex~3actxt-lc%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3actxt-lc2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;49. Recall the first <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[call[lam["f","f"],lam["z",add["z",9]]],1]</span></p></blockquote></div><div class="SIntrapara">Use the transition rules for code to determine its result step by step. <a href="#%28counter._%28exercise._ex~3actxt-lc2%29%29" class="ex-end" data-pltdoc="x"></a></div></p><h4>4.2<tt>&nbsp;</tt><a name="(part._sec~3arec)"></a>What is Recursion</h4><p>The preceding section makes no mention of recursion, which might worry you.
After all, <a href="ch_algebra.html" data-pltdoc="x">Algebra, Your Second Programming
Language</a> heavily invests in a separate explanation of
recursive functions. It turns out that <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> already supports
recursion&#8212;<wbr></wbr><span class="emph">without</span> special provisions&#8212;<wbr></wbr>and this is a good opportunity
to look at this complex phenomenon from a different angle.</p><p><div class="SIntrapara">Let&rsquo;s return to algebra for a moment, where you encountered problem such
as this one:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 6  </span>Solve the following equation:</p></td></tr><tr><td><p>&#160; &#160; <span style="font-style: italic">-</span>2<span style="font-style: italic"> * x = x</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> + </span>1<span style="font-style: italic"></span></p></td></tr></table></blockquote></div><div class="SIntrapara">These problems followed you all through high school then. If, by chance, you
took a course on advanced calculus, you may have encountered problems like this
one:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 7  </span>Solve the following equation:</p></td></tr><tr><td><p>&#160; &#160;  <span style="font-style: italic">f</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = f</span>&prime;<span style="font-style: italic"></span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"></span></p></td></tr><tr><td><p>where <span style="font-style: italic">f</span>&prime;<span style="font-style: italic"></span> is the derivative function of <span style="font-style: italic">f</span>.</p></td></tr></table></blockquote></div><div class="SIntrapara">Unlike the first problem, which requests a numeric solution, this calculus
problem is an equation in a <span class="emph">function variable</span>. That is, the solution is a
function, not a number.</div></p><p>Looking for entire functions as solutions to equations sounds difficult.  But,
recursive functions in programming languages are most easily understood as such
equations. And, one way to understand their workings is to think of programming
languages as equation solvers.</p><p>Consider this simple recursion functions, formulated in mathematical notation:</p><p><div class="SIntrapara"><blockquote><p><img src="pict_13.png" alt="image" width="170" height="51"/></p></blockquote></div><div class="SIntrapara">It is a so-called piece-wise function definition: one part for an input of
<span style="font-style: italic"></span>1<span style="font-style: italic"></span> and another for all other natural numbers. The function translates into
a conditional function in programming languages:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["f","z",if0["z",1,mul["z",call["f",add["z",-1]]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Stop! Convince yourself that this abstract syntax tree in <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>
(plus the <span class="RktSym">if0</span> conditional from <a href="ch_algebra.html#%28part._sec~3a3sum%29" data-pltdoc="x">Summary</a>) corresponds to the
mathematical function.</div></p><p><div class="SIntrapara">Let&rsquo;s take a close look at the general nature of such equations.  Specifically,
let&rsquo;s ignore the specific function and write down the general shape of such
equations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">f</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">f</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">This equation says that <span class="RktSym">f</span> is defined as a function whose argument
<span class="RktSym">n</span> may show up in the function body as well as calls to <span class="RktSym">f</span>.
Substitution works both ways, meaning we can eliminate multiple occurrences of
<span class="RktSym">f</span> inside of its function body like this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">f</span><span class="RktRdr">,</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">f</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">f</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">f</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">If you think of <span class="RktSym">f</span> as a value and apply the substitution rule (argument
for parameters), you get the original equation back. To some extent, this
process is basic algebra.</div></p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Church and other students of the lambda calculus called this
transformation an alpgha renaming in the 1920s.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">By applying a &ldquo;name refactoring&rdquo; to the new <span class="RktSym">lam</span> node, it becomes much
clearer that <span class="RktSym">f</span> occurs only once on the right-hand side:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">g</span><span class="RktRdr">,</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">g</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">g</span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">f</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">Mathematically inclined programming language researchers like to name
expressions at such points to improve their understanding, and then this
equation makes a lot more sense:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">G</span><span class="RktRdr">,</span><span class="RktSym">f</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">where <span class="RktSym">G</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">lam</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">g</span><span class="stt"> </span><span class="RktRdr">,</span><span class="RktSym">lam</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">z</span><span class="stt"> </span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="stt"> </span><span class="RktSym">z</span><span class="stt"> </span><span class="RktSym">..</span><span class="stt"> </span><span class="RktSym">call</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">g</span><span class="stt"> </span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">..</span><span class="stt"> </span><span class="RktSym">call</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">g</span><span class="stt"> </span><span class="RktRdr">,</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span>.</div></p><p><div class="SIntrapara">In mathematics, such equations have a name: fixed-point equations. That is, the
desired function <span class="RktSym">f</span> is a fixed point of the function <span class="RktSym">G</span>, And a
fixed point of a mathematical function <span style="font-style: italic">G</span> is any value <span style="font-style: italic">z</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>0<span style="font-style: italic"></span></span><span style="font-style: italic"></span> such that
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">G</span>(<span style="font-style: italic">z</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>0<span style="font-style: italic"></span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> = z</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>0<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></blockquote></div><div class="SIntrapara">In plain English, feeding a fixed-point to a function returns the fixed point.</div></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The original Y combinator is due to Curry; this version
originated with Plotkin.</p></blockquote></blockquote></blockquote><p><div class="SIntrapara">The <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> language comes with a function that can compute the fixed
point for every function that has the shape of <span class="RktSym">G</span>. The function is
called <span class="stt">Y</span>&#8212;<wbr></wbr>or Y combinator&#8212;<wbr></wbr>and it mathematical terms it
satisfies this equation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[G,call[Y,G]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktPn">call[Y,G]</span></p></blockquote></div><div class="SIntrapara">or with <span class="RktSym">G</span> spelled out:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">call[lam["f",lam["z",...]],call[Y,lam["f",lam["z",...]]]]</span></td></tr><tr><td><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">call[Y,lam["f",lam["z",...]]]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here is <span class="RktSym">Y</span> in plain <span class="RktSym">lam</span> terms:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">g</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktPn">lam["y",call["g",lam["z",call[call["y","y"],"z"]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["y",call["g",lam["z",call[call["y","y"],"z"]]]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">If you are curious how one can justify the Y combinator, see
<a href="http://www.ps.uni-sb.de/courses/sem-prog97/material/YYWorks.ps">On
the Why of Y</a>. The same idea is presented in the form of a question-and-answer
game in <span style="font-style: italic">The Little Schemer</span>, MIT Press.</span></span></span>
Even a first look elicits some immediate observations:
</div><div class="SIntrapara"><ul><li><p>&ldquo;In plain <span class="RktSym">lam</span> terms&rdquo; means it is <span class="emph">not</span> recursive;</p></li><li><p>The first thing anyone notices is that the function&rsquo;s body applies two
identical <span class="RktSym">lam</span> terms to each other.</p></li><li><p>Furthermore, each of these <span class="RktSym">lam</span> terms contains another &ldquo;self
application,&rdquo; namely <span class="RktPn">call["y","y"]</span>.</p></li></ul></div><div class="SIntrapara">Nothing in plain mathematics&#8212;<wbr></wbr>high school or college&#8212;<wbr></wbr>prepares you for
functions like that. But, recall the CEK transition rule from <a href="ch_algebra.html#%28part._sec~3afun%29" data-pltdoc="x">The Meaning of Function Definitions</a>:</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="5"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td colspan="5"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call[fn,{--}]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p>ae1</p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" colspan="11"><p>if [<span class="RktPn">fun[fn,x,ae1]</span> /  <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] is in <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> and
&#160; &#160; &#160; &#160; &#160; &#160;
<a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> is <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt"> </span><span class="RktPn"> [x &lt;- nn]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="RktPn">]</span></p></td></tr></table></div><div class="SIntrapara">Given a call to a recursive function, this rule creates an environment by
extending the environment (basically) with itself. This act is quite
similar to an application of a function to itself.</div></p><p>In short, self-application appears to be one way to create recursion, though
beware, not every language supports the creation of such functions.</p><p><span style="font-weight: bold">Curiosity</span> Programming language theoreticians like <span class="RktSym">Y</span> or similar
functions.  The very idea of <span class="RktSym">Y</span> allows a separation between
recursion&#8212;<wbr></wbr>code that uses <span class="RktSym">Y</span>&#8212;<wbr></wbr>and the rest of a programming language.
Its existence tremendously simplify the models of languages and proofs of
theorems about models.</p><p>Programming language implementors do <span class="emph">not</span> use <span class="RktSym">Y</span> to create
recursive functions. Not even so-called purely functional languages use the
trick of self-applying functions. <a href="ch_mutation.html#%28part._sec~3arec%21%29" data-pltdoc="x">What is Recursion, Take 2</a> picks up this thread and
shows how a compiler realizes recursion in principle in much simpler ways.</p><p>So in the end, we should consider <span class="RktSym">Y</span> an amazing curiosity and not much
more.</p><p><span style="font-weight: bold">How to Use <span class="RktSym">Y</span></span> Writing recursive functions in <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> is
about the same amount of work as in <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>. How to go about it is
best illustrated with a worked example.</p><p><div class="SIntrapara">Let&rsquo;s return to the motivating example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["f","z",if0["z",1,mul["z",call["f",add["z",-1]]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">The name "f" is visible in both its body <span class="RktPn">if0[n,1,mul[n,call["f",add[n,-1]]]]</span> and in the body of <span class="RktSym">block</span>, which is represented with an
ellipsis. Invoking it produces the factorial number of whatever natural number
it is given; if it is given a negative integer, it goes into an infinite loop.</div></p><p><div class="SIntrapara">In order to rewrite such a program fragment into <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>, we first
separate the function name from its definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="stt">"f"</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktPn">lam["z",if0["z",1,mul["z",call["f",add["z",-1]]]]]</span></p></blockquote></div><div class="SIntrapara">Next we extract "f" from the body to obtain the equivalent of <span class="RktSym">G</span> above:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">"f"</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["g",lam["z",if0["z",1,mul["z",call["g",add["z",-1]]]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"f"</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Alternatively, here are two equivalent informal definitions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="stt">"f"</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktPn">call[G,"f"]</span></p></blockquote></div><div class="SIntrapara">where <span class="RktSym">G</span> is <span class="RktPn">lam["g",lam["z",if0["z",1,mul["z",call["g",add["z",-1]]]]]]</span>.</div></p><p><div class="SIntrapara">Now we can rewrite the program with a <span class="RktSym">let</span> definition instead of a
recursive <span class="RktSym">fun</span> definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">let</span><span class="RktPn">[</span><span class="hspace">&nbsp;</span><span class="stt">"f"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call[Y,lam["g",lam["z",if0["z",1,mul["z",call["g",add["z",-1]]]]]]]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">This definition is <span class="emph">not</span> recursive; in particular, "f" is <span class="emph">not</span> in
scope on the right-hand side of the <span class="RktSym">let</span> definition, though it is
still visible in the body of the <span class="RktSym">block</span> expression.</div></p><p><div class="SIntrapara">Since <span class="RktSym">let</span> is just syntactic sugar, going to plain <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> is
straightforward:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">lam["f",...]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call[Y,lam["g",lam["z",if0["z",1,mul["z",call["g",add["z",-1]]]]]]]</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Substitution and Proof</span> The proof of <span class="stt">Y</span>&rsquo;s extraordinary capabilities
is surprisingly short, though like many proofs demands a couple of
insights. Recall the fixed point equation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">call[lam["f",lam["z",...]],call[Y,lam["f",lam["z",...]]]]</span></td></tr><tr><td><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">call[Y,lam["f",lam["z",...]]]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The first insight is to work backwards through the equation, that is, the proof
shows
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">call[Y,lam["f",lam["z",...]]]</span></td></tr><tr><td><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">call[lam["f",lam["z",...]],call[Y,lam["f",lam["z",...]]]]</span></td></tr></table></blockquote></div><div class="SIntrapara">But, since equations hold in both directions that&rsquo;s not a problem.</div></p><p><div class="SIntrapara">So the starting point is this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[Y,lam["f",lam["y",...]]]</span></p></blockquote></div><div class="SIntrapara">After replacing Y with its definition, we can substitute <span class="RktPn">lam["f",lam["y",...]]</span> for "g" into its body:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call[lam["f",lam["y",...]],lam["z",call[call["y","y"],"z"]]]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call[lam["f",lam["y",...]],lam["z",call[call["y","y"],"z"]]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Next the big self-application inside of Y has to be evaluated, which again
works via plain substitution:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">lam["f",lam["y",...]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call[lam["f",lam["y",...]],lam["z",call[call["y","y"],"z"]]]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call[lam["f",lam["y",...]],lam["z",call[call["y","y"],"z"]]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">z</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">And at this point, you may recognize an instance of Y if you pull out the
<span class="RktPn">lam["f",lam[x,...]]</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">lam["f",lam["y",...]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktPn">call[Y,lam["f",lam["y",...]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">z</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Church and other students of the lambda calculus called this
refactoring an eta reduction in the 1920s.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">At this point, a second insight is needed:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">lam["z",call["f","z"]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="stt">"f"</span></p></blockquote></div><div class="SIntrapara">That is, if "f" is a function, wrapping <span class="RktPn">lam["z",call[{--},"z"]]</span>
around it doesn&rsquo;t change the behavior of the term at all. It still consumes one
argument, calls "f" on the argument, and returns the result.</div></p><p><div class="SIntrapara">Since <span class="RktPn">call[Y,lam["f",lam["y",...]]]</span> is guaranteed to reduce to a
function, we get the last step:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[lam["f",lam["y",...]],call[Y,lam["f",lam["y",...]]]]</span></p></blockquote></div><div class="SIntrapara">which is the function applied to its fixed point.</div></p><h5>4.2.1<tt>&nbsp;</tt><a name="(part._.Crazy_.Combinators)"></a>Crazy Combinators</h5><p>Given that the Y combinator eliminates recursion, people started wondering
whether it is possible to eliminate other aspects of <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> in a
similar way. As it turns out, logicians<span class="refelem"><span class="refcolumn"><span class="refcontent">Curry and Schoenfinkel
independently discovered how to eliminate <span class="RktSym">lam</span>. Church developed the
particular representation of numbers used here.</span></span></span> were once again ahead of
programming language researchers. They developed functional representation of
numbers and operations on them as far as back as the 1930s. Even before that,
they had demonstrated that <span class="RktSym">lam</span> was superfluous in a computation system
that treated functions a values. . This sub-section takes a brief look at these
ideas in anticipation of the overall analysis of <a href="ch_express.html" data-pltdoc="x">The Dimensions</a>.</p><p><div class="SIntrapara">Let&rsquo;s start with a look at number representations. Here is a straightforward
representation of the number <span class="RktVal">3</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">lam["f",lam["z",call["f",call["f",call["f","z"]]]]]</span></p></blockquote></div><div class="SIntrapara">More generally, any natural number <span style="font-style: italic">n</span> is representable as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">lam["f",lam["z",call["f",call[...,call["f","z"]]]]]</span></p></blockquote></div><div class="SIntrapara">with <span style="font-style: italic">n</span> applications of "f" to <span class="stt">"z"</span>.</div></p><p><div class="SIntrapara">It does not suffice, however, to claim that some <span class="RktSym">lam</span> tree represents a
number. The numbers of <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> come with operations, and these
operations must have equivalents as <span class="RktSym">lam</span> expressions, too. A relatively
direct observation suggests that apply the representation of a number to another
number computes the exponent of the second to the first.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">exponentiation </span><span style="font-style: italic">z</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">y</span></span><span style="font-style: italic"></span></td></tr><tr><td><span class="RktPn">lam["z",lam["y",call["y","z"]]]</span></td></tr></table></blockquote></div><div class="SIntrapara">Stop! Use substitution to determine the result of applying the representation of
<span class="RktVal">3</span> to the representation of <span class="RktVal">2</span>. Make sure that "f" is applied
eight times to <span class="stt">"z"</span>.</div></p><p><div class="SIntrapara">Finding exponentiation through playful experimentation is not a coincidence, and
it leads directly to multiplication:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">multiplication </span><span style="font-style: italic">z * y</span></td></tr><tr><td><span class="RktPn">lam["z",lam["y",lam["f",lam["w",call[call["z",call["y","f"]],"w"]]]]]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">This brings us to addition, the seemingly simplest operation, but one that
demands an even more complex <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> term than the previous two
operations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">addition: </span><span style="font-style: italic">z + y</span></td></tr><tr><td><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">z</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">f</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">lam</span><span class="RktPn">[</span><span class="RktSym">w</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call[call["z","f"],call[call["y","f"],"w"]]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Stop! You may wish to tackle <a href="#%28counter._%28exercise._ex~3anum%29%29" data-pltdoc="x">exercise&nbsp;52</a> before you proceed.</div></p><p>At this point, we may safely ignore the presence of numbers and operations on
numbers when it comes to <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>. What is left is language of
variables, <span class="RktSym">lam</span> functions, and function calls. If it is possible to
eliminate <span class="RktSym">lam</span>, too, we have a small, fixed language that should be easy
to realize in hardware, which is also an artifact that can perform a fixed
number of functions.</p><p><div class="SIntrapara">Eliminating <span class="RktSym">lam</span> from a language takes a bit more than eliminating
numbers. The essence, as discovered in the 1920s, is to translate
<a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> expressions into a syntax with just two pre-defined functions:
<span class="RktSym">S</span> and <span class="RktSym">K</span>. In terms of our language, the first one is simple,
though somewhat odd:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">K</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></p></blockquote></div><div class="SIntrapara">It takes two arguments, one at a time, and returns only the first value.
The definition of the second function is quite complex:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">S</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktPn">lam["w",lam["y",lam["z",call[call["w","z"],call["y","z"]]]]]</span></p></blockquote></div><div class="SIntrapara">It consumes three arguments, again, one at a time. The first two are clearly
functions, and they are applied to the third argument. The trick is that the
result of the first application must be a function again, and it is applied to
the result of the second.</div></p><p><div class="SIntrapara">Before we move on, let&rsquo;s look at a trivial example in this world. Specifically,
the translation of <span class="RktPn">lam[x,x]</span> as <span class="RktPn">call[call[call[S,K],K],K]</span>. To argue that this translation is correct, we can use substitution once
again, replacing <span class="stt">S</span> and <span class="stt">K</span> with their definitions as needed:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span class="RktPn">call[call[call[call[S,K],K],K],x]</span></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span class="RktPn">call[call[K,x],call[K,x]]</span></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span class="RktPn">call[lam["y",x],lam["y",x]]</span></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span class="stt">x</span></p></td></tr></table></div><div class="SIntrapara">So for any argument <span class="stt">x</span>, applying <span class="RktPn">call[call[call[S,K],K],K]</span>
to it returns the same value. That is, the term acts exactly like the identity
function.</div></p><p><a href="#%28counter._%28figure._fig~3abracket%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">28</span></a> presents the complete translation. The function
<span class="stt">to_sk</span> consumes an <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> expression that does not contain
numbers of operations on numbers. That is, it is either a name, a <span class="RktSym">lam</span>
node, or a <span class="RktSym">call</span> node. It basically just traverses the term and, every
time it encounters a <span class="RktSym">lam</span> node, it applies the actual workhorse: the
so-called <span class="stt">bracket</span> function.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><a name="(tech._ast._sk)"></a><span style="font-style: italic">AST-sk</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">e = x | K | S | </span><span class="RktPn">call[e,e]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x = </span><a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">---&gt; </span><a href="#%28tech._ast._sk%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-sk</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">// eliminate all </span><span class="RktSym">lam</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">sub-expressions from `ast`</span></p></td></tr><tr><td><p><span class="stt">def to_sk(ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">Name</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; return ast</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">[lam x bdy] -&gt; return bracket(x,to_sk(bdy))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">[call f a]</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-&gt; return call[to_sk(f),to_sk(a)]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// </span><a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt"></span><a href="#%28tech._ast._sk%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-sk</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; </span><a href="#%28tech._ast._sk%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-sk</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">// eliminate occurrences of `name` from `ast`</span></p></td></tr><tr><td><p><span class="stt">def bracket(name,ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Name</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; if (ast is equal to name)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">call[call[S,K],K]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return call[K,ast]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">[call f a] -&gt; return call[call[S,bracket(name,f)],bracket(name,a)]</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abracket))" x-target-lift="Figure"></a>Figure&nbsp;28: </span>Eliminating <span class="RktSym">lam</span> from <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> programs</span></p></blockquote><p><div class="SIntrapara">The purpose of <span class="stt">bracket</span> is to simulate <span class="RktSym">lam</span> for applications of
<span class="stt">S</span> and <span class="stt">K</span> plus names. When the given abstract syntax tree just a name,
say <span class="stt">"z"</span>, <span class="stt">bracket</span> returns
</div><div class="SIntrapara"><ul><li><p>either <span class="RktPn">call[call[S,K],K]</span>, which we know is the identify
function, if <span class="stt">"z"</span> is the given name;</p></li><li><p>or <span class="RktPn">call[K,"z"]</span>, which throws away whatever other argument it
receives, if <span class="stt">"z"</span> is not the given name.</p></li></ul></div><div class="SIntrapara">When the given AST is an application, <span class="stt">bracket</span> inserts an application of
<span class="stt">S</span> to distribute the future argument to the simulated <span class="RktSym">lam</span> to both
parts of the application so that each can decide what to do with it.</div></p><p>Programming language researchers found the idea of reducing everything to a
fixed set of functionality appealing. In the 1970s and 1980s, they studied
combinators and combinator-based translations to understand the principles of
languages and compilers. As mentioned, a fixed set of combinators resembles the
fixed set of instructions of actual hardware. In the end, though, it turned out
that these theoretical translations could not be made practical. They remain of
interest to computing theoreticians.</p><p><span style="font-weight: bold">Exercises</span> The following exercises suggest experimentation with
combinators in your chosen language.</p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3ay2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;50. Rewrite the following <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> fragment into
<a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">block[fun["g",x,call["g",x]],call["g",42]]</span></p></blockquote></div><div class="SIntrapara">Can you think of an even shorter term to create an infinite loop in <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>? <a href="#%28counter._%28exercise._ex~3ay2%29%29" class="ex-end" data-pltdoc="x"></a></div></p><p><a name="(counter._(exercise._ex~3ay1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;51. Rewrite the Y combinator in your chosen language&#8212;<wbr></wbr>if it is
untyped. Otherwise, take a break and eat a peanut butter sandwich.</p><p>Define the factorial function normally. Then create a recursive version using Y.
Make sure they deliver the same result on any positive integer. <a href="#%28counter._%28exercise._ex~3ay1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3anum))"></a><span style="font-weight: bold">Exercise</span>&nbsp;52. Represent the numbers <span class="RktVal">2</span> and <span class="RktVal">3</span> as function
expressions in your chosen language. If your chosen language is typed, you will
need to experiment with polymorphism.</p><p>Design the function <span class="stt">to_number</span>. It consumes the representation of a number
and applies it to a function that adds <span class="RktVal">1</span> to a number and the number
<span class="RktVal">0</span>. Stop! What should this function return when applied to the function
expression representing <span class="RktVal">2</span>?</p><p>Design the function <span class="stt">exponent</span>. It consumes two number representations and
produces the exponent. Formulate tests using <span class="stt">to_number</span>.</p><p>Consider repeating this last exercise for multiplication and addition. <a href="#%28counter._%28exercise._ex~3anum%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>4.3<tt>&nbsp;</tt><a name="(part._sec~3acek)"></a>The CEK Machine</h4><p><div class="SIntrapara">Adapting the CEK machine to <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> yields a surprisingly simple
machine. In terms of grammatical differences, the <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> language
comes with a more general <span class="RktSym">call</span> node than <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>.
The revised grammar no longer restricts the function position of <span class="RktSym">call</span>
to a name, but permits arbitrary expressions to show up there. For
example,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">21</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Hence the revised CEK machine must evaluate this position and remember to
perform the function call later. This observation calls for a revised set of
stack frames:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._cek._frame)"></a><span style="font-style: italic">CEK-frame</span><span class="stt">:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">f = </span><span class="RktPn">call[{--},e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><span class="RktPn">call[v,{--}]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">| </span><span class="RktPn">add[{--},e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><span class="RktPn">add[v,{--}]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">| </span><span class="RktPn">mul[{--},e]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><span class="RktPn">mul[v,{--}]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/ </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td></tr></table></div><div class="SIntrapara">Recall that <span class="stt">v</span> belongs to the set of <a href="#%28tech._ast._value%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-values</span></a>, and <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> is a an
environment. The latter is necessary because expressions&#8212;<wbr></wbr>including
values&#8212;<wbr></wbr>may contain free variables, and the environment collects their values.</div></p><p>The process of evaluation <span class="RktSym">call</span> nodes proceeds just like the process for
evaluation <span class="RktSym">add</span> or <span class="RktSym">mul</span> nodes. First the machine descends into
the left part and reduces it to a value. Second it swaps this value with the
right-side expression, which is in the stack together with its
environment. Finally, when it has a function and its argument value, the machine
sets up an extended environment to evaluate the body.</p><p><div class="SIntrapara">Environments remain finite tables that associate names with values. Since the
set of values includes <span class="RktSym">lam</span> expressions now, and since such expressions
may come with free variables, the environments contain environments to cover
these variables:
</div><div class="SIntrapara"><blockquote><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> <span class="RktPn"> [x &lt;- v]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> means that <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> is extended with
the association <span class="stt">[x, v / </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt">]</span> where <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> gives meaning to all the
free variables in <span class="stt">v</span>.</p></blockquote></div><div class="SIntrapara">In a sense, the revised environments are a cross between those of
<a href="ch_algebra.html#%28part._algebra._sec~3alet%29" data-pltdoc="x">The Meaning of Variable Definitions</a>, with their uniform
notation, and <a href="ch_algebra.html#%28part._sec~3afun%29" data-pltdoc="x">The Meaning of Function Definitions</a>, with their environment-accompanied
<span class="RktSym">fun</span> nodes.</div></p><p><a href="#%28counter._%28figure._fig~3acek%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">29</span></a> presents the transition rules for <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> control
codes. The first three cover the normal evaluation of a function call, just as
described above. The fourth rule shows how the revised machine retrieves values
and their environments from the current environment; the value becomes the
control code and the retrieved environment becomes the current one. The last
rule is needed to discover an exceptional situation, namely, the attempted
application of a number as if it were a value. Like division by 0, the CEK
machine treats this situation as an error and terminates execution.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="5"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="5"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">call[e1,e2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>e1</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">v</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></td></tr></table></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>e2</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></td></tr></table></td></tr><tr><td valign="top"><p><span class="RktSym">v</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktPn">lam[x,e]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">e</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt"> </span><span class="RktPn"> [x &lt;- v]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">x</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">v</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule" colspan="11"><p>if [x, v/<a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] is in <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> </p></td></tr><tr><td valign="top"><p><span class="RktSym">v</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span><span class="RktSym">nn</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>xn</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="5"><p> xn is "<span class="stt">closure expected, number found</span>" </p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p><span style="font-weight: bold">Legend</span>
(1) <span class="RktSym">e1</span> <span class="RktSym">e2</span> <span class="RktSym">e</span> stand for expressions;
(2) <span class="RktSym">x</span> represent names; and
(3) <span class="stt">nn1</span> <span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers </p></td></tr><tr><td><p>&#160;</p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3acek))" x-target-lift="Figure"></a>Figure&nbsp;29: </span>A CEK machine for <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-Lambda</span></a></span></p></blockquote><p>Even a superficial look shows that the CEK transitions of <a href="#%28counter._%28figure._fig~3acek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">29</span></a>
are far more uniform than those of <a href="ch_algebra.html" data-pltdoc="x">Algebra, Your Second Programming
Language</a>. All forms of function
application&#8212;<wbr></wbr><span class="RktSym">call</span>, <span class="RktSym">add</span>, and <span class="RktSym">mul</span>&#8212;<wbr></wbr>are evaluated in
the same manner now. Environments no longer differentiate between value
associations and function associations. This uniformity extends to the set of
stacks frames.</p><p>The uniformity hides the complexity that has been added to environments. Recall
that environments always grow via extension. In <a href="ch_algebra.html" data-pltdoc="x">Algebra, Your Second Programming
Language</a> the data
structure is a tree, though with function definitions pointing down to lower
layers of the tree. The environment is a pointer identifying the start node in
the tree for the retrieval of values. With the promotion of functions to values,
however, the environment data structure gets new kinds of links.</p><p><div class="SIntrapara">A good way to understand the generalized environments is to work through the
example from the beginning of the section. That is, to construct and analyze the
trace of this program on the new CEK machine:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">21</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktVal">21</span><span class="RktPn">]</span></td></tr></table></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call[lam["w",lam["z","w"]],42]</span><span class="RktPn">]</span></td></tr></table></td></tr><tr><td valign="top"><span class="RktPn">lam["w",lam["y","w"]]</span></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call[lam["w",lam["z","w"]],42]</span><span class="RktPn">]</span></td></tr></table></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call[{--},21]</span></p></td></tr><tr><td valign="top" class="trace"><span class="RktVal">21</span></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call[lam["w",lam["z","w"]],42]</span><span class="RktPn">]</span></td></tr></table></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call[lam["w",lam["y","w"]],{--}]</span></p></td></tr><tr><td valign="top"><span class="RktPn">lam["y","w"]</span></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">call</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call[lam["w",lam["z","w"]],42]</span><span class="RktPn">]</span></td></tr></table></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = [<span class="stt">"w"</span>,<span class="RktVal">21</span>] </p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>These first four steps are <span class="emph">search</span> steps that descend into the
abstract syntax tree of <span class="RktSym">call</span> nodes until they find a &ldquo;function
redex.&rdquo; The reduction puts the argument into the environment, and places the
body into the code register.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><span class="RktSym">call</span><span class="RktPn">[</span><span class="hspace">&nbsp;</span><span class="RktPn">lam["w",lam["y","w"]]</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call[lam["y","w"],{--}]</span> / <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>Since the stack says the argument is still to be evaluated, the
machine swaps the value from the control code register plus the current
environment with the top-most stack frame. Keep in mind that we shows stacks
growing downwards but use the common terminology of &ldquo;top of the stack.&rdquo;</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><span class="RktPn">lam["w",lam["z","w"]]</span></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call[lam["y","w"],{--}]</span> / <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call[{--},42]</span></p></td></tr><tr><td valign="top" class="trace"><span class="RktVal">42</span></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call[lam["y","w"],{--}]</span> / <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call[lam["w",lam["z","w"]],{--}]</span></p></td></tr><tr><td valign="top"><span class="RktPn">lam["z","w"]</span></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call[lam["y","w"],{--}]</span> / <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = [<span class="stt">"w"</span>,<span class="RktVal">42</span>] </p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The process is repeated for the nearly identical argument expression.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><p><span class="stt">"w"</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> <span class="RktPn"> ["y" &lt;- lam["z","w"]]</span> / <a href="ch_algebra.html#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr></table></div><div class="SIntrapara">Stop! The machine is about to look up the value of <span class="stt">"w"</span>, and because the stack
is empty, this value is the program&rsquo;s final result. What is the value?</div></p><p><a href="#%28counter._%28figure._fig~3acek-envs%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">30</span></a> shows the environment data structure for the preceding
trace. The growth immediately branches out in two directions: one for the
function application on the left side of the <span class="RktSym">call</span> node and one for the
application on the right. Then the machine extends the first branch to add the
argument. But, because this argument us a <span class="RktSym">lam</span> expression with free
variables, it comes with its own environment&#8212;<wbr></wbr>that is, a pointer to another
part of the data structure. The dotted line indicates this novel kind of
cross-branch pointer.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_14.png" alt="image" width="601.1" height="210.60000000000002"/></p></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3acek-envs))" x-target-lift="Figure"></a>Figure&nbsp;30: </span>The environment tree of a a CEK machine</span></p></blockquote><p>The figure also reveals the final answer of our program: <span class="RktVal">21</span>. As
mentioned in <a href="ch_algebra.html#%28part._sec~3afun%29" data-pltdoc="x">The Meaning of Function Definitions</a>, the lookup starts at the indicated place and
proceeds toward the root. When the search process finds an association with the
desired name, it has found its value. Of course, we can also confirm that
<span class="RktVal">21</span> is the expected outcome with the substitution model of
reasoning. The two models should never diverge in their predictions.</p><p><a name="(counter._(exercise._ex~3acek1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;53. Describe all states, the initial states, and the final
states of the CEK machine from <a href="#%28counter._%28figure._fig~3acek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">29</span></a> for the complete
<a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> language. Then complete the set of transitions, including all
possible error scenarios for addition and multiplication. <a href="#%28counter._%28exercise._ex~3acek1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3acek2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;54. Trace the evaluation of
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[lam[x,call[x,x]],lam[x,call[x,x]]]</span></p></blockquote></div><div class="SIntrapara">with the transitions of <a href="#%28counter._%28figure._fig~3acek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">29</span></a>. This program is often called
&#937;, and it is the shortest infinite loop in <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>. <a href="#%28counter._%28exercise._ex~3acek2%29%29" class="ex-end" data-pltdoc="x"></a></div></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3acek3))"></a><span style="font-weight: bold">Exercise</span>&nbsp;55. Add transition rules for an <span class="RktSym">if0</span> conditional to the
CEK machine:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">if0[0,e1,e2]</span></p></blockquote></div><div class="SIntrapara">evaluates to whatever <span class="stt">e1</span> evaluates to, and for some value that is not <span class="RktVal">0</span>,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">if0[v,e1,e2]</span></p></blockquote></div><div class="SIntrapara">evaluates to <span class="stt">e2</span>. Then trace
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">call[call[Y,lam["g",lam[x,if0[x,1,mul[x,call["g",add[x,-1]]]]]]],1]</span></p></blockquote></div><div class="SIntrapara">on your revised machine. <a href="#%28counter._%28exercise._ex~3acek3%29%29" class="ex-end" data-pltdoc="x"></a></div></p><h4>4.4<tt>&nbsp;</tt><a name="(part._sec~3atheorems3)"></a>The Type Soundness Theorem</h4><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The Halting Theorem of Theory says that there is no algorithm that
decides whether a program terminates. It does not imply that we cannot prove
theorems about classes of programs, including non-terminating ones.</p></blockquote></blockquote></blockquote><p>Programming language theoreticians like to prove a type-soundness theorem about
their models. The theorem expresses that the language evaluator is well behaved.
For a full-fledged language, &ldquo;well behaved&rdquo; means that it behaves in one of
the following three ways for any given program: delivers a value, raises one of
several clearly specified exceptions, or goes into an infinite loop.</p><p>Although <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> is a language without types, we can state (and could
prove) a type-soundness theorem for it. Indeed, the absence of a type system
makes it easier to explain the idea in detail <span class="emph">before</span> we deal with this
additional, complicated principle of programming languages.</p><p><span style="font-weight: bold">Definition</span> Let a <span style="font-style: italic">program</span> be an <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> expressions
without free variables.</p><p>Let <span style="font-style: italic">trans</span> be the transitive-reflexive closure of the CEK transition
relation in <a href="#%28counter._%28figure._fig~3acek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">29</span></a> plus rules for addition and multiplication,
including rules for signaling an exception when either one of these two
operations has to deal with a <span class="RktSym">lam</span> expression.</p><p>Let <a name="(tech._cek)"></a><span style="font-style: italic">cek</span> relate programs via <span style="font-style: italic">trans</span> to final states whose control
codes are values and exception strings.</p><p><div class="SIntrapara">Here is some essential notation:
</div><div class="SIntrapara"><ul><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"> = v</span> is equivalent to the more conventional relational
notation <span style="font-style: italic"> e </span><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"> n </span> and means that program <span style="font-style: italic">e</span> is related to
a number <span style="font-style: italic">v</span> or a <span class="RktSym">lam</span> expression <span style="font-style: italic">v</span>. Note that the latter
may contain free variables.</p></li><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"> = xn</span> means that program <span style="font-style: italic">e</span> is related to one of
the two expression strings <span class="stt">closure expected, number found</span> or <span class="stt">number expected, closure found</span>.</p></li><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"></span> &#8593; means that the program <span style="font-style: italic">e</span> has an
infinitely long evaluation trace in <span style="font-style: italic">trans</span>.</p></li></ul></div></p><p>Now we can state what programming language theory considers the most basic
theorem when it comes to evaluators.</p><p><span style="font-weight: bold">Type Soundness Theorem</span> The relation <a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a> is a function and thus an
evaluator.</p><p>For all <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> programs <span class="RktSym">e</span>, one of the following statements
hold:</p><ul><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"> = v</span> is a number or <span class="stt">closure</span>;</p></li><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"> = xn</span> where <span style="font-style: italic">xn</span> is either <span class="stt">closure expected, number found</span> or
<span class="stt">number expected, closure found</span>; or</p></li><li><p><a href="#%28tech._cek%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">e</span>)<span style="font-style: italic"></span> &#8593;.</p></li></ul><p>There are many frameworks for writing down the meaning of programs, and for each
of those there are many methods for proving a type-soundness theorem. For
example, the substitution approach to reasoning about programs also defines an
evaluator, not just the CEK machine. The two are the same functions, but the
method for proving type-soundness differ due to the details of the
specification.</p><p>Finally, researchers prefer not to look at the <span class="RktSym">lam</span> expression that may
result from an evaluation. Instead they say the result is <span class="stt">closure</span>, which is
what many implementations of <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a> like languages print when the
result is a function. Using this token to represent an answer permits the idea
of compiling <span class="RktSym">lam</span> expression to reduce their execution cost.</p><h4>4.5<tt>&nbsp;</tt><a name="(part._sec~3a4sum)"></a>Summary</h4><p>Promoting functions to values adds expressive power to programming languages.
Developers use first-class functions in many different ways, ranging from simple
callbacks to module-like abstractions or simulating full-fledged control.</p><p><div class="SIntrapara">While the promotion of functions does not introduce a new language construct,
it illuminates the most critical aspect of design: the trade-off between
usability on one side and implementation on the other, between expressive
power and theorems:
</div><div class="SIntrapara"><ul><li><p>The key advantages are <span style="font-weight: bold">uniformity</span> of language features.</p><p>For the programmer, more uniformity means easier to use and better ways to
express basic ideas.</p><p>For the programming language theoretician, it teases out important
ideas. <span style="font-weight: bold">Recursion</span> is one of them. In the presence of first-class functions,
recursion is no longer a special case; it is a fixed point function. Uniformity
also simplifies stating and proving <span style="font-weight: bold">theorems</span> about the entire
language. This second aspect is probably why first-class functions caught on in
this community decades before it became a ubiquitous part of every major
language.</p></li><li><p>The key downside of the promotion is the increased <span style="font-weight: bold">complexity</span> of the
environment data structure in the CEK machine, a representative implementation.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>For the special case of call-by-name languages (see
<a href="ch_algebra.html#%28part._sub~3aname%29" data-pltdoc="x">Delayed Evaluation: Call By Name</a>), the stack property still holds. But, such
languages come with many other performance problems.</p></blockquote></blockquote></blockquote><p>The environment is a stack-like data structure for <a href="ch_algebra.html#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>, because
environment part of every <span class="RktSym">fun</span> definition points further down into the
data structure. In the presence of first-class functions, an environment is a
tree-like data structure with cross-cutting pointers, often called a directed
acyclic graph. Without knowledge of the code and the rest of the program; it is
no longer possible to determine which branch of the tree is no longer needed;
hence, aligning the environment with the stack and using &ldquo;pop&rdquo; to reclaim
storage has become impossible.</p></li></ul></div><div class="SIntrapara">In sum, eliminating special cases like <span class="RktSym">fun</span> yields simple models and
powerful languages. But, it imposes a cost on the language implementor.</div></p><p>As in all scientific disciplines, it remains important to keep practical
implications in mind and to simplify as much as practical but not more. What is
practical changes over time. At this point, empowering programmers is far more
important than enabling implementors to come up with a scheme that fits the
available hardware.</p><p><div class="SIntrapara"><span style="font-weight: bold">Project</span> Here is a JSON syntax for a language similar to <a href="#%28tech._ast._lambda%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-lambda</span></a>:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "*", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "-", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "/", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["if0", X, Y, Z]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["lam",</span><a href="#%28tech._parameter%29" class="techoutside" data-pltdoc="x"><span class="techinside">Parameters</span></a><span class="stt">,X]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["call",X,</span><a href="#%28tech._argument%29" class="techoutside" data-pltdoc="x"><span class="techinside">Arguments</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._parameter)"></a><span style="font-style: italic">Parameters</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a JSON array of names:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- [</span><a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">, ..., </span><a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._argument)"></a><span style="font-style: italic">Arguments</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a JSON array of Lambda expressions:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- [X,...,Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="stt">X</span><span class="stt">, </span><span class="stt">Y</span><span class="stt">, and </span><span class="stt">Z</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">are JSON representations of Lambda expressions.</span></p></td></tr></table></div><div class="SIntrapara">It differs from the language of this chapter in that functions may consume several
arguments at once and function calls may apply a function to several arguments.</div></p><p>The <a href="#%28tech._parameter%29" class="techoutside" data-pltdoc="x"><span class="techinside">Parameters</span></a> of a <span class="RktSym">lam</span> expression must be pairwise distinct.</p><p>The only scoping rule says that all <a href="#%28tech._parameter%29" class="techoutside" data-pltdoc="x"><span class="techinside">Parameters</span></a> of a <span class="RktSym">lam</span> expression
are defined in its body.</p><p>The informal meaning of the language is basically the same as in this chapter with
the following caveats. All sub-expressions of <span class="RktSym">call</span> are evaluated from
left to right before the function is called. The <span class="RktSym">if0</span> expression has the
same meaning as the one in <a href="ch_algebra.html#%28part._sec~3a3sum%29" data-pltdoc="x">Summary</a>. Division signals an error when the
second argument is <span class="RktVal">0</span>.</p><p><div class="SIntrapara">Develop a program in your chosen language that reads valid JSON expressions from
standard input and prints one of these possible results to standard output:
</div><div class="SIntrapara"><ul><li><p><span class="stt">"syntax error"</span> if the JSON text is not formed according to the grammar;</p></li><li><p><span class="stt">"undefined variable"</span> if the JSON text contains a <a href="ch_algebra.html#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a> without
corresponding definition;</p></li><li><p><span class="stt">"division by 0"</span> if the execution of the program attempts to divide by 0;</p></li><li><p><span class="stt">"wrong number of arguments"</span> if the execution of the program tries to
apply a function with <span style="font-style: italic">n</span> parameters to <span style="font-style: italic">k</span> arguments and <span style="font-style: italic">n</span><span style="font-style: italic">
</span><span style="font-style: italic">&#8800;</span><span style="font-style: italic"> k</span>;</p></li><li><p><span class="stt">"closure expected"</span> if the execution of the program tries to use a number
as a function; </p></li><li><p><span class="stt">"number expected"</span> if the execution of the program tries to perform a numeric
operation on a function;</p></li><li><p>a JSON number if the syntax is correct, all variables are declared, and
everything evaluates correctly.</p></li></ul></div></p><p>Identify the components of your program and make sure to understand which
component can terminate your program with which error message.  Keep in mind that
you need to develop an abstract syntax description first.</p><p>Base the program on the CEK machine. Make sure to describe all
possible environments and stacks in terms of your chosen language
before you code.</p><p>Demonstrate with one integration test that your program properly supports
recursion.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_algebra.html" title="backward to &quot;3 Algebra, Your Second Programming
Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_mutation.html" title="forward to &quot;5 Mutable Objects&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3&nbsp;Algebra, Your Second Programming
Language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Machines and Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="ch_pl.html" class="tocviewlink" data-pltdoc="x">Programming Languages</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ch_arith.html" class="tocviewlink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="ch_lambda.html" class="tocviewlink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ch_mutation.html" class="tocviewlink" data-pltdoc="x">Mutable Objects</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="ch_cc.html" class="tocviewlink" data-pltdoc="x">Full Control</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="ch_express.html" class="tocviewlink" data-pltdoc="x">The Dimensions</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="ch_space.html" class="tocviewlink" data-pltdoc="x">Space</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="ch_types.html" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="ch_futures.html" class="tocviewlink" data-pltdoc="x">Futures</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._sec~3aalgebra%29" class="tocviewlink" data-pltdoc="x">Variables and Functions</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#%28part._sec~3ascope%29" class="tocviewlink" data-pltdoc="x">Static Scope</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#%28part._sec~3astatic%29" class="tocviewlink" data-pltdoc="x">Static Checking:<span class="mywbr"> &nbsp;</span> Scope</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="#%28part._algebra._sec~3alet%29" class="tocviewlink" data-pltdoc="x">The Meaning of Variable Definitions</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="#%28part._sec~3afun%29" class="tocviewlink" data-pltdoc="x">The Meaning of Function Definitions</a></td></tr><tr><td align="right">3.6&nbsp;</td><td><a href="#%28part._sec~3atheorems2%29" class="tocviewlink" data-pltdoc="x">Theorems and Language Design</a></td></tr><tr><td align="right">3.7&nbsp;</td><td><a href="#%28part._sec~3a3sum%29" class="tocviewlink" data-pltdoc="x">Summary</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8.0.1</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_arith.html" title="backward to &quot;2 Arithmetic,
Your First Programming Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_lambda.html" title="forward to &quot;4 First-Class Functions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._ch~3aalgebra)"></a>Algebra, Your Second Programming
Language</h3><p>Your first algebra course expanded your programming experience. It introduced
variables and functions. But your teacher remained in control, programming you
and asking you to play computer.</p><p>This chapter uses your knowledge of simple algebra to expand on the ideas of the
previous chapter. As it turns out, the introduction of variables and functions
raises a number of fundamental issues that algebra courses may gloss over, but
programming languages must explicate. That most important of these is the notion
of scope. At the same time, the study of programming languages must reinforce
your knowledge of basic algebra concepts, most importantly, the idea of
substituting values for variables.</p><p>So, this chapter connects the dots all the way from the very first function you
encountered in algebra courses to the core of the programming languages and the
basic ideas about programming you likely encoountered in your very first course.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aalgebra%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>Variables and Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3ascope%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>Static Scope</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3astatic%29" class="toclink" data-pltdoc="x">3.3<span class="hspace">&nbsp;</span>Static Checking: Scope</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._algebra._sec~3alet%29" class="toclink" data-pltdoc="x">3.4<span class="hspace">&nbsp;</span>The Meaning of Variable Definitions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3afun%29" class="toclink" data-pltdoc="x">3.5<span class="hspace">&nbsp;</span>The Meaning of Function Definitions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sub~3aname%29" class="toclink" data-pltdoc="x">3.5.1<span class="hspace">&nbsp;</span>Delayed Evaluation: Call By Name</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3atheorems2%29" class="toclink" data-pltdoc="x">3.6<span class="hspace">&nbsp;</span>Theorems and Language Design</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3a3sum%29" class="toclink" data-pltdoc="x">3.7<span class="hspace">&nbsp;</span>Summary</a></p></td></tr></table><h4>3.1<tt>&nbsp;</tt><a name="(part._sec~3aalgebra)"></a>Variables and Functions</h4><p><div class="SIntrapara"><span style="font-weight: bold">Simple Algebra</span> A typical algebra<span class="refelem"><span class="refcolumn"><span class="refcontent">In the United States, this
is often called pre-algebra.</span></span></span> worksheet contain exercises such as this one:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 1  </span>Let <span style="font-style: italic">f</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = </span>3<span style="font-style: italic"> * x</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> - </span>2<span style="font-style: italic"> * x + </span>4<span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">f</span> for <span style="font-style: italic"></span>0<span style="font-style: italic"></span>, <span style="font-style: italic"></span>7<span style="font-style: italic"></span>, and -3.</p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The answers are <span class="RktVal">4</span>, <span class="RktVal">137</span>, and <span class="RktVal">37</span>,
respectively. What truly matters, though, are the following ideas:
</div><div class="SIntrapara"><ul><li><p>the name <span style="font-style: italic">f</span> is defined in the first line</p></li><li><p>the occurrence of <span style="font-style: italic">f</span> is a reference to this definition;</p></li><li><p><span style="font-style: italic">x</span> is a name but plays a different role than <span style="font-style: italic">f</span>; and</p></li><li><p>the meaning of the phrase &ldquo;the value of <span style="font-style: italic">f</span> for&rdquo; is defined in
terms of substitution of values for variables, plus some arithmetic. For example,</p><table cellspacing="0" cellpadding="0"><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-style: italic">f</span>(<span style="font-style: italic"></span>7<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>3<span style="font-style: italic"> * </span>7<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> - </span>2<span style="font-style: italic"> * </span>7<span style="font-style: italic"> + </span>4<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>by substituting <span style="font-style: italic"></span>7<span style="font-style: italic"></span> for <span style="font-style: italic">x</span> in the definition of <span style="font-style: italic">f</span></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>3<span style="font-style: italic"> * </span>4<span style="font-style: italic"></span>9<span style="font-style: italic"> - </span>2<span style="font-style: italic"> * </span>7<span style="font-style: italic"> + </span>4<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>by multiplication</p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>1<span style="font-style: italic"></span>4<span style="font-style: italic"></span>7<span style="font-style: italic"> - </span>2<span style="font-style: italic"> * </span>7<span style="font-style: italic"> + </span>4<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>by multiplication</p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>1<span style="font-style: italic"></span>4<span style="font-style: italic"></span>7<span style="font-style: italic"> - </span>1<span style="font-style: italic"></span>4<span style="font-style: italic"> + </span>4<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>by multiplication</p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>1<span style="font-style: italic"></span>3<span style="font-style: italic"></span>7<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>by addition and subtraction.</p></td></tr></table></li></ul></div><div class="SIntrapara">All these ideas have informed the design of programming languages for decades.</div></p><p><div class="SIntrapara">Occasionally these algebra worksheets also say that names stand for constants:
0</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p>Let &#960; stand for 3.14 in the following exercise.</p></td></tr><tr><td><p></p></td></tr><tr><td><p><span style="font-weight: bold">Problem 2  </span>Let <span style="font-style: italic">A</span>(<span style="font-style: italic">r</span>)<span style="font-style: italic"> = </span>&#960;<span style="font-style: italic"> * r</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">A</span> for <span style="font-style: italic"></span>0<span style="font-style: italic"></span>, <span style="font-style: italic"></span>7<span style="font-style: italic"></span>, and <span style="font-style: italic">-</span>3<span style="font-style: italic"></span>.</p></td></tr></table></blockquote></div><div class="SIntrapara">Because of &#960; is exactly 3.14, the answers to this exercise are
<span class="RktVal">0</span>, <span class="RktVal">153.86</span>, and <span class="RktVal">28.26</span>, respectively.
If instead the statement had been &#960; is 3.1415, the calculations and the outcomes
would have been quite different&#8212;<wbr></wbr>yet it would have been unnecessary to change
the way the exercise is written.</div></p><p><div class="SIntrapara">Another aspect of these algebra worksheet is that they use the same function
name over and over again:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 3  </span>Let <span style="font-style: italic">f</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = x</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> - </span>1<span style="font-style: italic"></span>7<span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">f</span> for <span style="font-style: italic"></span>3<span style="font-style: italic"></span>, <span style="font-style: italic">-</span>1<span style="font-style: italic"></span>, and 2.</p></td></tr></table></blockquote></div><div class="SIntrapara">Nobody would ever say that the occurrence of <span style="font-style: italic">f</span> in the second line is a
reference to the definition of <span style="font-style: italic">f</span> in problem 1 above.</div></p><p><div class="SIntrapara">In sum, algebra injects a number of ideas into the world of programming languages:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">explicit declaration of names</span>, that is, points that define function
names (<span style="font-style: italic">f</span>, <span style="font-style: italic">A</span>) and variable names (<span style="font-style: italic">x</span>, <span style="font-style: italic">r</span>);</p></li><li><p><span style="font-weight: bold">static scope</span>, that is, the idea that occurrences of variables point
to a particular defining point in well-delineated textual regions; and</p></li><li><p><span style="font-weight: bold">substitution</span> of values for names as the means to obtain meaning.</p></li></ul></div><div class="SIntrapara">As a matter of fact, programming languages generalize these ideas in many ways,
and they do so for the benefit of programmers.</div></p><p>This chapter gradually extends the simplistic model of a programming language from
<a href="ch_arith.html" data-pltdoc="x">Arithmetic,
Your First Programming Language</a> with these ideas. Doing so produces a language that Computer
Science Theoreticians consider equivalent to any full-fledged, classical model of
computing. Software developers and programmers, though, want more than that from
their major tool, and <a href="ch_express.html" data-pltdoc="x">The Dimensions</a> addresses this idea in detail.</p><p><span style="font-weight: bold">Pragmatics</span> Variable declarations and static scope for names in programs
evolved from a good idea to a critical, but invisible aspect over the decades.
Substitution is a front-line tool for programmers who wish to reason about the
behavior of their code&#8212;<wbr></wbr>without running it and observing the effects.</p><p>When a programming language demands the explicit declaration of names&#8212;<wbr></wbr>as
classes, functions, methods, etc.&#8212;<wbr></wbr>its implementation can and does check
whether all name references are declared. This simple cross-check prevents typos
from messing up program execution. Without such checks, a program may produce
reasonable-looking yet entirely wrong results, or they may cause a
difficult-to-debug crash.</p><p>Some of the first programming languages, and even some recent ones, permit
programmers to introduce and use a variable wherever they need it.  Given the
serious consequences, no experienced software developer should ever choose a
language with implicit variable declarations over one that demands explicit
declarations.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><span style="font-weight: bold">Warning</span> In some programmer communities, the word &ldquo;scope&rdquo;
refers to unrelated ideas.</p></blockquote></blockquote></blockquote><p>Static scope is critical to programming in teams.  A software developer needs to
know that choosing a name for a class, a method, a loop variable, and so on
cannot be invalidated by a choice that is made for a different textual region,
that is, a module, a class, a method, and so on. For example, a parameter choice
of <span class="RktSym">x</span> for one method does not mean that <span class="RktSym">x</span> is ruled out for the
next method.</p><p>Today, no software developers would doubt the value of static scoping, but for
several decades, static scoping had to compete with <span class="emph">dynamic scoping</span>, a
resolution of a variable&rsquo;s reference to its declaration <span class="emph">during program
execution</span>.</p><p>A programmer must have some understanding about what a program computes when it
runs, how a component behaves when it is used by a client module. Since
variables and functions are the simplest addition to arithmetic, substitution
becomes a natural concept. Algebra teaches that variables represent unknown yet
fixed quantifies and that, once the value becomes known, we just replace the
variable with the value.  A Java method for computing the area of a circle is
like <span style="font-style: italic">A</span> above and its workings can most easily be understood as if the
program were an algebra exercise.  More generally even, mathematics teaches that
defined names can always be replaced with their definition.</p><p>While substitution is intuitive, it poses two problems. First, it is rather
inefficient. Second, substitution does not work in the presence of assignment
statements, a common feature of most programming languages. Both problems are
easily resolved, though.</p><p><span style="font-weight: bold">Abstract Syntax: Functions and Variables</span> The starting point of this
chapter is a small programming language that extends <a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> with
variables and functions similar to the way algebra courses do.</p><p><div class="SIntrapara">The language extension calls for way of defining variables, such as for &#960; in
problem 2, and of defining functions, such as in all three problems. In the
context of abstract syntax, this calls for two additional struct definitions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">name</span><span class="RktRdr">,</span><span class="RktSym">right</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">fun</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">name</span><span class="RktRdr">,</span><span class="RktSym">parameter</span><span class="RktRdr">,</span><span class="RktSym">body</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Intuitively, both are intended to associate a name with another entity. For
variables, the &ldquo;other&rdquo; is called <span class="RktSym">right</span>; for functions, two pieces are
needed: the <span class="RktSym">parameter</span><span class="refelem"><span class="refcolumn"><span class="refcontent">A parameter is often called
<span class="emph">independent variable</span> in algebra; a body the <span class="emph">right-hand</span> side.</span></span></span> and
the function <span class="RktSym">body</span>, which is the expression that computes the result of
the function from the parameter&rsquo;s value. Notice the switch from algebra
to programming language terminology.</div></p><p><div class="SIntrapara">While function and variable definitions <span class="emph">cannot</span> be expressions, the use of
a function is. An algebra worksheet, for example, may ask students to evaluate
<span style="font-style: italic">f</span>(<span style="font-style: italic">g</span>(<span style="font-style: italic">h</span>(<span style="font-style: italic"></span>3<span style="font-style: italic"></span>)<span style="font-style: italic">-</span>4<span style="font-style: italic"></span>)<span style="font-style: italic">*</span>9<span style="font-style: italic"></span>)<span style="font-style: italic"></span>&#8212;<wbr></wbr>a nested expression of function uses and arithmetic. In
programming language we say &ldquo;function call,&rdquo; and a representation needs two
pieces:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">call</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">name</span><span class="RktRdr">,</span><span class="RktSym">argument</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">The first one is the name of the function, and the second is the argument
expressions.</div></p><p><div class="SIntrapara">Lastly, we need a way to integrate definitions with expressions. An
expression-oriented programming language uses a local block for this purpose,
and that is what our abstract syntax uses:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">block</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">definition</span><span class="RktRdr">,</span><span class="RktSym">body</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">Concretely, the <span class="RktSym">block</span> node explicitly scopes a definition for an
expression, dubbed <span class="RktSym">body</span>. The result of <span class="RktSym">body</span> is the result of a
<span class="RktSym">block</span> expression; the defined name is visible only in <span class="RktSym">body</span>.</div></p><p><div class="SIntrapara">With these structs in place, the abstract syntax for the extended programming
language is rather straightforward:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._algebra)"></a><span style="font-style: italic">AST-algebra</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| </span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| call[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">name</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| block[</span><a href="#%28tech._ast._def%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-def</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._ast._def)"></a><span style="font-style: italic">AST-def</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">let[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| fun[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">name</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._name)"></a><span style="font-style: italic">Name</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a JSON String</span></p></td></tr></table></div><div class="SIntrapara">It consists of three rules: one for the extended language of expressions, one
for the new language of definition, and one for names. The nest step is to
translate the informal and implied ideas about scope into concrete statements in
the context of our models&#8212;<wbr></wbr>and that comes with some surprises.</div></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3ajson-algebra))"></a><span style="font-weight: bold">Exercise</span>&nbsp;30. In<span class="refelem"><span class="refcolumn"><span class="refcontent">Instructors need to do
the first part of this exercise if they wish to grade it across
students.</span></span></span>  existing programming languages a <span class="RktSym">block</span> is often
just a sequence of statements enclosed in braces.  A <span class="RktPn">let["y",4]</span> definition might look like any of the following:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int y = 4;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">let int v = 4;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">def y = 4</span></p></td></tr></table></div><div class="SIntrapara">If your favorite language is not represented, make up an example.</div></p><p>Make up examples of <span class="RktPn">fun["g","x",add["x",4]]</span> in some of the languages you know.</p><p>Design a concrete JSON syntax for the abstract syntax introduced here and then
implement a parser that maps the concrete syntax into the above ASTs. <a href="#%28counter._%28exercise._ex~3ajson-algebra%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>3.2<tt>&nbsp;</tt><a name="(part._sec~3ascope)"></a>Static Scope</h4><p><div class="SIntrapara">Let&rsquo;s turn some of the algebra problems into programs, to get used to the
additional abstract syntax but also to get a sense of what scope means. Here is
the first problem as an <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",add[mul[3,mul["x","x"]],add[mul[-2,"x"],4]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call["f",-3]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">The <span class="RktSym">block</span> node puts together a <span class="RktSym">fun</span> definition and a
<span class="RktSym">call</span>. The occurrence of "f" in the <span class="RktSym">block</span>&rsquo;s second
part is clearly a reference to the definition of "f" in the first
one&#8212;<wbr></wbr>meaning the second part must be part of the scope of the <span class="RktSym">fun</span>
definition.</div></p><p><div class="SIntrapara">Now take a look at the translation of the second example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["&#960;",3.14]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["A","r",mul["&#960;",mul["r","r"]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["A",7]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">It consists of two nested blocks. The outer one defines the variable "&#960;"
while the inner one defines the function "A" ; the very inner part
is a function call o "A" . Again, the <span class="RktSym">let</span> definition of
"&#960;" is visible in the second part of the block, and this includes
both the <span class="RktSym">fun</span> definition and the innermost part of the program. Hence
the occurrence of "&#960;" within the body of the <span class="RktSym">fun</span> definition
refers to the variable definition and, as before, the occurrence of "A"
on the last line refers to the <span class="RktSym">fun</span> definition.</div></p><p><div class="SIntrapara">Instead of translating the third problem, we consider another typical algebra
problem in this abstract syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",add["x",2]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["g","x",mul[4,"x"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">block</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["h","x",add[call["f","x"],call["g","x"]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["h",42]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">The name "x" is used as the parameter part of every single function:
"f" , "g" , and "h" . Algebra teachers may make thic choice unconciously
and it may confuse you. Programming language design enables this kind
of name usage intentionally because the three functions might be
defined by three different programmers at three different stages of
program development or in three different modules, and the must be
able to use the same name for function parameters without fear of
mutual interference. Generally speaking, the scope of parameter names
is only the body of the function. In this spirit, the following
program is also perfectly legal syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["x",42]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",add["x",21]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["f","x"]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">The "x" on the last line refers to the "x" in the <span class="RktSym">let</span> definition
but the "x" in the <span class="RktSym">fun</span> definition refers to the parameter of
the function. As a matter of fact, because the developer used "x" as the
name of the parameter, it is impossible to refer to the "x" in the
<span class="RktSym">let</span> definition.</div></p><p><div class="SIntrapara">This last example suggests another one, a true edge case:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["f",42]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",add["x",21]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["f","f"]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">At this point, we leave algebra and mathematics behind and truly move
into programming language design decisions. The designer has a choice
to make and the feasible alternatives are these:
</div><div class="SIntrapara"><ul><li><p>Names used to define variables in <span class="RktSym">let</span> and functions in
<span class="RktSym">fun</span> exist at the same level or, as we usually say, in the same
space.</p><p>In this case, the program is syntactically correct but both occurrences
of "f" on the last line refer to the <span class="RktSym">fun</span> definition. Once the
program is run, "f" will attempt to add <span class="RktVal">21</span> to itself&#8212;<wbr></wbr>-and
cause an error.</p></li><li><p>The two kinds of definitions introduce names in two distinct
spaces: variable names (also called constants) and function names.</p><p>Here the program is syntactically correct because the two occurrences
of "f" refer to two different definitions: the first one refers to the
function and the second one to the variable.</p><p>The alternative comes with the downside that functions can&rsquo;t easily be
used as arguments to other functions.</p></li></ul></div><div class="SIntrapara">There are also other, even more complicated alternatives. Over time the
one-space alternative has become somewhat more popular in languages
without types, while typed languages often have several spaces for names.</div></p><p>This book uses the &ldquo;one space for all names&rdquo; approach.</p><p><div class="SIntrapara">Even with this choice in place, the abstract syntax of the <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>
language still doesn&rsquo;t have an unambiguous description of the scope of its
definitions. So here is one last example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["x",add["x",3]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",call[...,call["f",add["x",-1]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["f",42]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Both definitions seem to refer to themselves: the <span class="RktSym">let</span> definition comes
with "x" on the right-hand side and the <span class="RktSym">fun</span> definition with an occurrence
of "f" in its body. Programming language designers must decide whether these
occurrences of names are indeed self-references of the definitions or something
else. And this decision is settled when they describe the scope of definitions.</div></p><p>Conventional programming languages come with two kinds of definitions: non-recursive
variable definitions and recursive function definitions. This choice is also quite
intuitive because defining "x" in terms of itself like in the preceding example is
meaningless, though recursive functions are common.</p><p><div class="SIntrapara">This book goes with this choice, too, making it finally possible to provide precise
descriptions of the <span style="font-style: italic">scope</span> of names, that is, the textual regions in
<a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> where an occurrence of a name points to a particular definition:
</div><div class="SIntrapara"><ul><li><p>A <span class="RktSym">let</span> definition is in scope in the body part of its immediately
surrounding <span class="RktSym">block</span>.</p></li><li><p>The function name of a <span class="RktSym">fun</span> definition is in scope in the body part of
itself <span class="emph">and</span> in the body part of its immediately surrounding <span class="RktSym">block</span>.</p></li><li><p>The parameter name of a <span class="RktSym">fun</span> definition is only in scope in the body
part of itself.</p></li></ul></div><div class="SIntrapara">If a name is re-introduced again via some definition within a scope, the outer
definition is <span style="font-style: italic">shadowed</span>. A name without definition is called an
<span style="font-style: italic">undefined identifier</span> or a <span style="font-style: italic">free variable</span>.</div></p><p><span style="font-weight: bold">Exercises</span> The following exercises illustrate some of the graphical
techniques that programming language designers use to discuss scope.</p><p><a name="(counter._(exercise._ex~3arecursive~3f))"></a><span style="font-weight: bold">Exercise</span>&nbsp;31. What is missing from making recursive functions useful in Algebra? <a href="#%28counter._%28exercise._ex~3arecursive~3f%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3ascope))"></a><span style="font-weight: bold">Exercise</span>&nbsp;32. Translate Problem 3 from the preceding section into
<span class="RktSym">AST-algebra</span>. Identify the scope of "f" and "x" in the result. <a href="#%28counter._%28exercise._ex~3ascope%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3ashadow))"></a><span style="font-weight: bold">Exercise</span>&nbsp;33. Identify the scope of each variable in the
following <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["x",add[2,2]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","y",add["x",block[let["x",21],mul["x","x"]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["f","x"]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Use different colors for different scopes. Draw arrows from each
occurrence of a name to its place of definition. Finally, make sure to
understand that the scope of "x" comes with a hole. <a href="#%28counter._%28exercise._ex~3ashadow%29%29" class="ex-end" data-pltdoc="x"></a></div></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3afree))"></a><span style="font-weight: bold">Exercise</span>&nbsp;34. Draw arrows from all occurrences of names to their places of
definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["x",add["x",2]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","x",mul[2,call["f",add["x",-1]]]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">mul[3,x]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Use a blue box for free variables. <a href="#%28counter._%28exercise._ex~3afree%29%29" class="ex-end" data-pltdoc="x"></a></div></p><h4>3.3<tt>&nbsp;</tt><a name="(part._sec~3astatic)"></a>Static Checking: Scope</h4><p>The definition of a programming language must define scope. Its implementation
checks that programs live up to basic scoping rules <span class="emph">before</span> they are run,
just like they check that programs live up to the grammatical rules.  Due to
this temporary relationship, such checks are called <span style="font-style: italic">static</span>. Following
the discussion of the preceding section, contemporary languages tend to demands
that all names in a program come with definition points and that no variable is
free&#8212;<wbr></wbr>and this section demonstrates how to check such properties.</p><p><div class="SIntrapara">Before we present a basic algorithm, though, we need to settle one more
question, namely,
</div><div class="SIntrapara"><blockquote><p>whether function names may occur anywhere or only in function calls.</p></blockquote></div><div class="SIntrapara">If function names occur anywhere, the programming language deals with functions
and numbers in a uniform manner&#8212;<wbr></wbr>both are values and can, for example, be
passed to other functions. Otherwise, functions are like those you got to know
in your algebra courses.<span class="refelem"><span class="refcolumn"><span class="refcontent">If you took calculus, you may realize that
functions <span class="emph">are</span> values even in mathematics.</span></span></span></div></p><p>For now, we choose to follow algebra, meaning the names of functions may show up
only in function positions of <span class="RktSym">call</span> structs. A consequence of this
choice is that parameter names may <span class="emph">not</span> in the function position of
<span class="RktSym">call</span> structs. If they did show up there, the function would have to be
passed a function as an argument value.</p><p><div class="SIntrapara">Next comes the choice of what to check and how. The simplest alternative is to
have the a static-scope checker consumes abstract syntax and deliver a Boolean:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">--&gt; Boolean</span></p></td></tr></table></div><div class="SIntrapara">Another alternative is to follow the precedent of parsing and reconstruct an
abstract syntax tree that contains error structs for undefined identifiers.
This section goes with the first one, and the exercises call for the second one.</div></p><p>The code sketch in <a href="#%28counter._%28figure._fig~3aall-defined%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">20</span></a> shows the essence of a
static-scope checker. The main function defers to a function that produces
<span class="emph">all</span> free variables in a program in a single list. If this list is empty,
<span class="stt">scope_checker</span> returns true, otherwise false.</p><p><span style="font-weight: bold">Notation</span> The code sketch uses stack-like lists: <span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span> and <span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span>
are both the empty list. A one-element list is written as <span class="RktPn">[</span><span class="RktSym">a</span><span class="RktPn">]</span><span class="RktMeta"></span>. The
expression <span class="stt">(a . l)</span> adds element <span class="stt">a</span> to a list <span class="stt">l</span>, and <span class="RktSym">l1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">++</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">l2</span><span class="RktMeta"></span> denotes the concatenation of two lists.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">---&gt; Boolean</span></p></td></tr><tr><td><p><span class="stt">// list the free variables in this `ast`</span></p></td></tr><tr><td><p><span class="stt">def scope_checker(ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return [] == </span><span class="RktPn">free_in_expr[ast,(),()]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// `let_vars` is the list of `let` defined variables and parameters</span></p></td></tr><tr><td><p><span class="stt">// `fun_vars` is the list of `fun` define function names</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">] List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">] ---&gt; List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="stt">// list the free variables in this `ast`</span></p></td></tr><tr><td><p><span class="stt">def free_in_expr(ast,let_vars,fun_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">number</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; return []</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">add[lft,rgt]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; ... elided ...</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">mul[lft,rgt]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; ... elided ...</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">name -&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (name is in let_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return []</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return [name]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">call[fn,arg]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (fn is in fun_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">free_in_expr[arg,let_vars,fun_vars]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return fn . </span><span class="RktPn">free_in_expr[arg,let_vars,fun_vars]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">block[def,bdy]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">{free, nu_let_vars, nu_fun_vars} = </span><span class="RktPn">free_in_def[def,let_vars,fun_vars]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return free ++ </span><span class="RktPn">free_in_expr[bdy,nu_let_vars,nu_fun_vars]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._def%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-def</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">] List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">] --&gt; {List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">], List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">], List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">]}</span></p></td></tr><tr><td><p><span class="stt">// the free variables in this `ast` plus the newly defined names</span></p></td></tr><tr><td><p><span class="stt">def free_in_def(ast,let_vars,fun_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">let[lhs,rhs]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">nu_let_vars = (lhs . let_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">{</span><span class="RktPn">free_in_expr[rhs,let_vars,fun_vars]</span><span class="stt">, nu_let_vars, fun_vars}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">fun[fname,para,bdy]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">nu_fun_vars</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= (fname . let_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">local_let_vars = (para . let_vars)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">{</span><span class="RktPn">free_in_expr[bdy,local_let_vars,nu_fun_vars]</span><span class="stt">, let_vars, nu_fun_vars}</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aall-defined))" x-target-lift="Figure"></a>Figure&nbsp;20: </span>Statically checking programs for free variables</span></p></blockquote><p>The &ldquo;work horse&rdquo; of the code consists of two functions: <span class="stt">free_in_expr</span> and
<span class="stt">free_in_def</span>. As suggested in <a href="part_prologue.html" data-pltdoc="x">Prologue</a>, this arrangement
matches the grammar of <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> and <a href="#%28tech._ast._def%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-def</span></a>, two data
descriptions that refer to each other. The two functions refer to each other in
the same way and the same places as the two data definitions. Furthermore, both
functions use a so-called accumulator design, meaning they consume additional
arguments about context-sensitive information. Here one accumulator represents
the list of <span class="RktSym">fun</span> defined names that the functions have encountered
between the very root of the AST and the current position.  The other one is the
list of <span class="RktSym">let</span> defined variables and parameters that the functions have
seen up this point.</p><p>The <span class="stt">free_in_expr</span> function returns the list of all undefined names in an
expression. Its most complex code is the case for <span class="RktSym">block</span> in
<span class="stt">free_in_expr</span>. A <span class="RktSym">block</span> node contains an <a href="#%28tech._ast._def%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-def</span></a> and an
<a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>. The first defines one name whose scope includes the second
node. Hence, <span class="stt">free_in_expr</span> defers to <span class="stt">free_in_def</span> to produce the
relevant information; the result is the concatenation of the free variables in
the definition and the free variables in the <span class="RktSym">block</span>&rsquo;s body.</p><p>The <span class="stt">free_in_def</span> function delivers a three-part result: (1) the list of
undefined names in the definition, specifically in the right-hand side of a
<span class="RktSym">let</span> node and the body of a <span class="RktSym">fun</span> node; (2) the list of
<span class="RktSym">let</span> defined names; and (3) the list of <span class="RktSym">fun</span> defined function
names. Its most complex case concerns the <span class="RktSym">fun</span>-shaped AST. Such a
definition adds the function name to the scope of the function&rsquo;s body <span class="emph">and</span>
the <span class="RktSym">block</span>&rsquo;s body, which explains the local definition of <span class="stt">nu_fun_vars</span>.
By contrast, the function parameter&rsquo;s scope is just the function body, which is
why <span class="stt">local_let_vars</span> is used only for the call to <span class="stt">free_in_expr</span>. The
result in this case consists of the free variables in the <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>
sub-expression, the given <span class="stt">let_vars</span>, and the given <span class="stt">fun_vars</span> extended
with the function name. In short, the code is a near-direct translation of the
English description into code.</p><p><span style="font-weight: bold">Exercise</span> The exercises ask you to adopt the code sketch of
<a href="#%28counter._%28figure._fig~3aall-defined%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">20</span></a> to alternatives of the Algebra language.</p><p><a name="(counter._(exercise._ex~3astatic-scope0))"></a><span style="font-weight: bold">Exercise</span>&nbsp;35. Implement the static-scope checker for the
language of Algebra in your chosen programming language.</p><p>When you have a complete implementation, including a comprehensive unit test
suite, integrate it with the parser from <a href="#%28counter._%28exercise._ex~3ajson-algebra%29%29" data-pltdoc="x">exercise&nbsp;30</a> into a complete
program that reads a JSON Algebra program from <span class="stt">STDIN</span>.  If the Algebra
program satisfies all grammatical and scoping rule, the program prints the JSON
string <span class="stt">"true"</span> to <span class="stt">STDOUT</span>. If it violates a grammatical rule, the
program prints <span class="stt">"syntax error"</span>. If it fails the static-scope check, the
output is <span class="stt">"undefined identifier"</span>. <a href="#%28counter._%28exercise._ex~3astatic-scope0%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3astatic-scope1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;36. Most conventional languages support the definition
of functions with several parameters. Here is an appropriate revision of the
grammar for definitions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._def*)"></a><span style="font-style: italic">AST-def*</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">let[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| fun[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,List[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">name</span></a><span class="stt">],</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">The expression grammar must be changed to refer to <a href="#%28tech._ast._def%2A%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-def*</span></a> in
<span class="RktSym">block</span>.</div></p><p>Implement a static-scope checker for this variant of Algebra. <a href="#%28counter._%28exercise._ex~3astatic-scope1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3astatic-scope2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;37. In contemporary programming languages functions
are ordinary values, just like numbers or lists. The scoping rules for this
variant of the Algebra language permit the names of functions and parameters in
the function position of a <span class="RktSym">call</span> node.</p><p>Modify the code sketch of <a href="#%28counter._%28figure._fig~3aall-defined%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">20</span></a> to cope with this
generalized variant of the Algebra language. Note that the generalization
<span class="emph">simplifies</span> the code.</p><p>Adapt the solution of <a href="#%28counter._%28exercise._ex~3astatic-scope0%29%29" data-pltdoc="x">exercise&nbsp;35</a> to this variant. <a href="#%28counter._%28exercise._ex~3astatic-scope2%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>3.4<tt>&nbsp;</tt><a name="(part._algebra._sec~3alet)"></a>The Meaning of Variable Definitions</h4><p>The meaning of names demands a careful investigation. We start with the meaning
of <span class="RktSym">let</span> defined names in this section. The next sections move on to <span class="RktSym">fun</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Substitution</span> Algebra teaches that if a problem introduces a name for a
value, like problem 1 at the beginning of this chapter, the best way to understand
this definition is as a shorthand for replacing the name with its value:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p>Let &#960; stand for 3.14 in the following exercise.</p></td></tr><tr><td><p></p></td></tr><tr><td><p><span style="font-weight: bold">Problem 2  </span>Let <span style="font-style: italic">A</span>(<span style="font-style: italic">r</span>)<span style="font-style: italic"> = </span>&#960;<span style="font-style: italic"> * r</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">A</span> for <span style="font-style: italic"></span>0<span style="font-style: italic"></span>, <span style="font-style: italic"></span>7<span style="font-style: italic"></span>, and <span style="font-style: italic">-</span>3<span style="font-style: italic"></span>.</p></td></tr></table></blockquote></div><div class="SIntrapara">The words &ldquo;within its scope&rdquo; are implicitly understood. So the following
rewrite of the problem is equivalent to the original:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 2  </span>Let <span style="font-style: italic">A</span>(<span style="font-style: italic">r</span>)<span style="font-style: italic"> = </span>3<span style="font-style: italic">.</span>1<span style="font-style: italic"></span>4<span style="font-style: italic"> * r</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">A</span> for <span style="font-style: italic"></span>0<span style="font-style: italic"></span>, <span style="font-style: italic"></span>7<span style="font-style: italic"></span>, and <span style="font-style: italic">-</span>3<span style="font-style: italic"></span>.</p></td></tr></table></blockquote></div><div class="SIntrapara">But, a programmer might point out that the original function definition is
better at signaling the intent of computing the area of a circle.</div></p><p><div class="SIntrapara">From this perspective, a <span class="RktSym">let</span> defined name extends the language of
Arithmetic with a simple rule that applies in every context:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;" colspan="3"><p>current state</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>next state</p></td></tr><tr><td valign="top"><p><span class="RktPn">block[let[x,nn],ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>==</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">ae2 [x &lt;- nn]</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae2</span> stands for an arbitrary expression and <span class="stt">nn</span> stands for any number</p></td></tr></table></blockquote></div><div class="SIntrapara">This articulation of the rule omits the context, and it works in both deterministic
and non-deterministic settings.</div></p><p>The notation <span class="RktPn">ae2 [x &lt;- nn]</span> is common in programming languages to
express the substitution of nn for x in its scope within <span class="stt">ae2</span>. While it
looks simple and is intuitive, getting this function correct is non-trivial. We
introduce it in stages, starting here.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt"></span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">Number ---&gt; </span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">// substitute `num` for `var` in its scope within `ast`</span></p></td></tr><tr><td><p><span class="stt">def substitute(ast,var,num)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">number</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; return ast</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">add[lft,rgt]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; add[substitute(lft,var,num),substitute(rgt,var,num)]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">mul[lft,rgt]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; ... elided ...</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">name -&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (ast is var)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return num</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return ast</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">call[fn,arg]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">call[fn,substitute(arg,var,num)]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">block[let[lhs,rhs],bdy]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (lhs is var)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return block[sub_def((let lhs rhs),var,num),bdy]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block[sub_def((let lhs rhs),var,num),</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">substitute(rhs,var,num),var,num]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">def sub_let(ast,var,num)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">let[lhs,rhs]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; let[lhs,substitute(rhs,var,num)]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._algebra._(figure._fig~3alet-subst))" x-target-lift="Figure"></a>Figure&nbsp;21: </span>Substituting a number for a variable in simplified <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a></span></p></blockquote><p><a href="#%28counter._algebra._%28figure._fig~3alet-subst%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">21</span></a> displays a code sketch for the substitution function
for <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> if it includes only <span class="RktSym">let</span> definitions. The
function is mostly a standard recursive algorithm that matches the data
description of the abstract syntax trees. The last clause, however, deserves
special attention. It does not just blindly traverse the <span class="RktSym">block</span>
structure, but checks whether the <span class="RktSym">let</span> defined variable is equal to the
one that is being replaced.</p><p>Stop! Why does the function compare the names?</p><p><div class="SIntrapara">When you encounter possibly surprising code, it is always best to make up a
matching example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">block[let["y",1],add[block[let["y",add["y",1]],"y"],"y"]]</span></p></blockquote></div><div class="SIntrapara">This small program defines <span class="emph">twice</span>. The second definition uses <span class="RktPn">add["y",1]</span> on the right-hand side, and this occurrence of <span class="stt">"y"</span> is a reference
to the first definition. Hence <span class="RktSym">substitute</span> must replace this <span class="stt">"y"</span> with
<span class="RktVal">1</span>. By contrast, if the substitution function were to blindly replace
the last <span class="stt">"y"</span>, it would change the meaning of the expression.  This last
<span class="stt">"y"</span> is <span class="emph">not</span> in scope of the first definition, and that&rsquo;s why
<span class="RktSym">substitute</span> performs the comparison and takes different actions
depending on the outcome.</div></p><p><span style="font-weight: bold">The Stack Machine with Substitution</span> <a href="ch_arith.html" data-pltdoc="x">Arithmetic,
Your First Programming Language</a> explains how to
derive a stack machine from the formal system of calculations that represents an
algebra student solving a homework. It is straightforward to adapt this abstract
state machine to deal with <span class="RktSym">let</span> defined names via substitution.</p><p><div class="SIntrapara">The first step is to enlarge the set of stack frames to deal with <span class="RktSym">block</span>s:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">Frame</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| block[let[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">name</span></a><span class="stt">,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">],</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">Stop! Inspect the last line; the others are the same as for <a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>.</div></p><p>The second step is to add a state transition rule to <a href="ch_arith.html#%28counter._%28figure._fig~3aarith-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a>.
See <a href="#%28counter._algebra._%28figure._fig~3alet-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">22</span></a> for the revised rule. If the control state matches a
<span class="RktSym">block</span> with a <span class="RktSym">let</span> definition whose right-hand side is not a
value, the machine pushes an instance of the new kind of stack frame and
puts the right-hand expression into the conrrol-code register. Once this
expression becomes a value in the context of such a new stack frame, the value
is substituted into its scope, which is retrieved from the stack via a pop.</p><p><div class="SIntrapara"><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="3"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">let[x,ae1]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let[x,{--}]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span></td></tr></table></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let[x,{--}]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span></td></tr></table></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">ae2 [x &lt;- nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr></table><p><span style="font-weight: bold">Legend</span>
 (1) <span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions;
 (2) <span class="RktSym">x</span> represents a name; and
 (3) <span class="stt">nn1</span> <span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers</p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._algebra._(figure._fig~3alet-ck))" x-target-lift="Figure"></a>Figure&nbsp;22: </span>A stack machine for simple Algebra, plus substittution</span></p></blockquote></div><div class="SIntrapara">}</div></p><p><a name="(counter._algebra._(exercise._ex~3ack-alg1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;38. Describe all states, the initial states, and the final
states of the CK machine from <a href="#%28counter._algebra._%28figure._fig~3alet-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">22</span></a> for the simplified
<a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> language. Complete the set of transitions. <a href="#%28counter._algebra._%28exercise._ex~3ack-alg1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara">Here is a sample execution on this abstract state machine:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">block[let["y",add[2,2]],mul["y","y"]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[2,2]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">block[let["y",{--}],mul["y","y"]]</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">4</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">block[let["y",{--}],mul["y","y"]]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">mul[4,4]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr></table></div><div class="SIntrapara">The right-hand side of the <span class="RktSym">let</span> definition is an addition, and thus the
machine pushes a new frame onto the empty stack. Next the addition is reduced to
a number, which is then substituted into the body of the block in the top-most
stack frame.</div></p><p>What is barely notable, though, is the duplication of work between this machine
and the <span class="RktSym">substitute</span> function. The transition from the second to the
third state calls for a use of <span class="RktSym">substitute</span> to realize the <span class="RktPn">ae2 [x &lt;- nn]</span> aspect of the transition, that is, the second rule in
<a href="#%28counter._algebra._%28figure._fig~3alet-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">22</span></a>. As noted, <span class="RktSym">substitute</span> traverses the entire
expression, finds all occurrences of the given name, and replaces it with a
number. When the machine pics up from there, it also traverses the
(reconstructed) expression, one node at a time. This double traversal seems like
a waste of time. Programming language people have therefore developed a
technique that combines the machine&rsquo;s traversal with substitution and thus
explains the work of the latter within the samef ramework as other computational
reductions.</p><p><div class="SIntrapara"><span style="font-weight: bold">Environments, Delayed Substitutions</span> The simple idea is to <span class="emph">delay</span>
substitution and to accumulate delayed substitution in a data structure instead.
In programming languages, this new data structure is called an
<span style="font-style: italic">environment</span>. Roughly speaking, an environment is a table that relates
names to, for now, numbers:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._algebra._e)"></a><span style="font-style: italic">E</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span style="font-style: italic">E</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= </span><span style="font-style: italic">&#8709;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">| </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt">, [</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">, Value]</span></p></td></tr></table></div><div class="SIntrapara">For now Values are just Numbers; the next few sections of this chapter refine this
idea. Notice the similarities to stacks <a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>. Like stacks, environments can be
described with a simpler, less mathematical description: <span class="refelem"><span class="refcolumn"><span class="refcontent">For the
special case of this chapter, environments could be considered as stacks, but this
just doesn&rsquo;t hold in general and is really a compiler topic.</span></span></span>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">E</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= [</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">, Value], ..., [</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">, Value]</span></p></td></tr></table></div><div class="SIntrapara">Neither data description shows, however, that stacks and environments are
rather different data structures. For that, we need to look at how
environments are used.</div></p><p>Environments come with two kinds of operations. First, the machine uses these
tables to look up whether a name is associated with a number and which
one. The book combines the two in English but separating them in an
implementation is a good idea. Second, environments grow with additions and
replacements of associations. The technical term is <span style="font-style: italic">environment
extension</span> and merges the two aspects into one. The notation for environment
extension is
<span class="emph">E</span> <span class="RktPn"> [x &lt;- nn]</span>.
This operation consumes three inputs (<a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>, x, and nn) and produces a
new environment. Regardless of whether x is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>, looking up x in the
result is guaranteed to yield nn and nothing else; looking up any other name
yields the same result as looking in the <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> environment. So in this sense,
environment extension may add an association or replace an existing one.</p><p><div class="SIntrapara">Adding an environment to the stack machine creates the <span style="font-style: italic">CEK machine</span>.
</div><div class="SIntrapara"><ul><li><p>a <span style="font-weight: bold">state</span> consists of three registers: a control code, which is an
<a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>; an environment <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>, which associates all <span class="emph">free</span>
variables in the control code with a value; and a stack <a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, which
represents the rest of the computation;</p></li><li><p>an <span style="font-weight: bold">initial state</span> consists of an expression without free variables
in the control-code register, an empty environment, and empty stack;</p></li><li><p>a <span style="font-weight: bold">final state</span> has a value in the control-code register and empty
environments and stacks in the other registers; and</p></li><li><p>the CEK-machine&rsquo;s essential transitions are displayed in
<a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a> for the subset of <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> that comes with
just <span class="RktSym">let</span> definitions.</p></li></ul></div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="5"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td colspan="5"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">let[x,ae1]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let[x,{--}]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" class="rule"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" class="rule"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let[x,{--}]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" class="rule"><p>ae2</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"> </span><span class="RktPn"> [x &lt;- nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p>x</p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p>nn</p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top" colspan="7"><p>if [x, nn] is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p>(1) <span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions;
(2) <span class="RktSym">x</span> represents a name; and
(3) <span class="stt">nn1</span> <span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers </p></td></tr><tr><td><p>&#160;</p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._algebra._(figure._fig~3alet-cek))" x-target-lift="Figure"></a>Figure&nbsp;23: </span>The CEK machine for simple Algebra</span></p></blockquote><p>The transitions of <a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a> describe how the CEK machine deals
with a <span class="RktSym">let</span> definition in a block. It pushes the <span class="RktSym">block</span> frame
onto the stack, with the current environment. Moving the environment is
necessary because the block&rsquo;s body mat contain free variables and their meaning
is in the <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> environment. The second rule shows how this <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> gets back into the
environment register; when the control code contains just a number and the
top-most stack frame is a <span class="RktSym">block</span> with a hole, the machine drops the
current environment and moves the one from the stack to the register.  The final
rule is about variables in the control-code register. Compared to the
substitution-based CK machine, the machine places the value of a variable into
the environment. When it later encounters the same name in the control-code
registers, it retrieves the name&rsquo;s value from the current environment.</p><p><div class="SIntrapara">It is time to inject some precision into the description of the machine,
specifically the data description of the stack frames. Unlike the machine for
Arithmetic, an Algebra machine must include the environment with stack frames if
those include an expression that might have free variables. Hence we cannot just
use a stack of <a href="ch_arith.html#%28tech._frame%29" class="techoutside" data-pltdoc="x"><span class="techinside">Frame</span></a>s but must instead use a stack of <a href="#%28tech._algebra._eframe%29" class="techoutside" data-pltdoc="x"><span class="techinside">EFrame</span></a>s:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._algebra._eframe)"></a><span style="font-style: italic">EFrame</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">] / </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">] / </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| block[let[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">],</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">] / </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td></tr></table></div><div class="SIntrapara">The notation <span class="hspace">&nbsp;</span><span class="stt">mul[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a><span class="stt">] / </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt">  </span> means that <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>
supplies the meaning for the free variables in the <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>
sub-expression.</div></p><p>Stop! Why are there no environments in the second and fourth clause of the
description?</p><p><div class="SIntrapara">A close look at environments shows that they are essentially functions. They
always map a finite number of variables to their values, because it has either
no value for a name or it has exactly one. So let&rsquo;s see how the machine deals
with environments with an example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block[</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt"></span><span class="RktPn">let["y",1]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">add[</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block[</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">let["y",add["y",1]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">y]]</span></p></td></tr></table></div><div class="SIntrapara">Stop! What do you expect as the value of this program?</div></p><p>The best way to understand such a program is to start with the variable
declarations and their scope.  In this case, the program contains two
<span class="RktSym">let</span> declarations of "y" and thus creates a hole in the scope of the
outer one.  One definition sets the variable to <span class="RktVal">1</span>, and the other one to
<span class="RktPn">add["y",1]</span>, where this occurrence of "y" refers to the outermost
definition. Similarly, the last two lines mention "y" and point to two different
definitions: the occurrence on the last line refers to the outermost one, and
the one on the next-to-last line to the innermost definition. Once you
understand the scoping structure, it is straightforward to see that the result
of this program is <span class="RktVal">3</span>.</p><p><div class="SIntrapara">Let&rsquo;s confirm this static analysis of the program with a machine trace:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">let["y",1]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let["y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><span style="font-style: italic">&#8709;</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">1</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">let["y",{--}]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">let["y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><span style="font-style: italic">&#8709;</span></td></tr></table></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The right-hand side of every <span class="RktSym">let</span> always becomes the control
code. The remainder becomes a frame for the control stack, which grows
downwards.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">add</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">let["y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The result is put into the environment, and the body of <span class="RktSym">let</span> becomes the control code.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">let["y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr></table></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span> <span class="RktPn">add[{--},"y"]</span> /  ["y", <span class="RktVal">1</span>] </p></td></tr><tr><td valign="top"><p><span class="RktPn">add["y",1]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">block[let["y",{--}],"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktSym">y</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">block[let["y",{--}],"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},1]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">block[let["y",{--}],"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},1]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>After pealing off three layers from the <span class="RktSym">block</span> expression, the machine extracts the value of "y" from the environment.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[1,1]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">block[let["y",{--}],"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p><span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">block[let["y",{--}],"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktSym">y</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>["y", <span class="RktVal">2</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The new environment maps "y" to <span class="RktVal">2</span>.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><p><span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},"y"]</span> / ["y", <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The machine looks up the value of "y", and then it restores the old environment value from the control stack.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[2,"y"]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p><span class="RktSym">y</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[2,{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">1</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[2,{--}]</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The value of this "y" is <span class="RktVal">1</span> as it should be. Stop! Why?</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><p><span class="RktPn">add[2,1]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>["y", <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">3</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr></table></div><div class="SIntrapara">The machine has reached a final state, and unloading this state obviously
produces <span class="RktVal">3</span>.</div></p><p><a name="(counter._algebra._(exercise._ex~3alet-cek-alg1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;39. While the description of the CEK machine is
complete with respect to the states, it is missing a number of
transitions for the Arithmetic subset of the simplified Algebra
language.  Complete the set of transitions from
<a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a>. <a href="#%28counter._algebra._%28exercise._ex~3alet-cek-alg1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._algebra._(exercise._ex~3ack-algebra-let-cek))"></a><span style="font-weight: bold">Exercise</span>&nbsp;40. Implement the transition function
from <a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a> for the language of Algebra (minus
<span class="RktSym">fun</span> definitions) in your chosen programming language.</p><p>When you have implemented the transition function, including a unit
test suite, design a <span class="RktSym">driver</span> function to create a complete
implementation of the abstract state machine for Algebra. <a href="#%28counter._algebra._%28exercise._ex~3ack-algebra-let-cek%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>3.5<tt>&nbsp;</tt><a name="(part._sec~3afun)"></a>The Meaning of Function Definitions</h4><p>Now that we understand simple variable definitions, it is time to turn to
function definitions. The functions in any contemporary language and in this
chapter may call themselves recursively. Hence the explanation of their meaning
must also explain recursion.</p><p>In principle, mathematics always considers names to be replaceable with their
definition, recursion needs special care. Plain substitution as in the preceding
section cannot possibly work. Since the body of the function may refer to its
name, the function definition must stay around. And this means the approach of
making definitions disappear does not work; the machine must somehow keep track
of them.</p><p>The CEK machine of the preceding section already has a mechanism for associating
names with values: the environment. What we need is a representations of
functions in the environment, because so far it merely associates names with
numbers.</p><p><div class="SIntrapara">So, imagine a CEK machine that reaches this state:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">block[fun[fn,x,ae1],ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr></table></blockquote></div><div class="SIntrapara">The definition itself does not call for evaluation; functions only matte when
they are called. Hence the machine must move ae2 into the control code
register. But, this expression may contain calls to fn, meaning the environment
for ae2 must remember the function definition. Let&rsquo;s imagine the brute force
solution of moving the entire function definition into the environment:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><p>ae2</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="RktPn">]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr></table></blockquote></div><div class="SIntrapara">Like <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"> </span><span class="RktPn"> [x &lt;- nn]</span>, <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="RktPn">]</span>
means an environment that is like <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> and also knows the definition of fn
shadowing any other mention of this name. Thus, if, for example, ae2 contains
<span class="RktPn">call[fn,42]</span>, the machine can extract the function and &ldquo;replace&rdquo; x
with <span class="RktVal">42</span> in the ae1 expression&#8212;<wbr></wbr>just like a student in algebra.</div></p><p><div class="SIntrapara">In the context of a programming language, this simplistic approach of placing and
retrieving a complete <span class="RktSym">fun</span> definition into the environment isn&rsquo;t quite
right. To make this concrete, consider the following sample program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["g","w","w"]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","z",call["g","z"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["g","y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">mul[call["f",1],call["g",1]]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Although the program is simplistic, it reminds us quickly of the role of the
environment. The function "g" is defined twice, with a definition of "f" sandwiched
between them. Static scope demands that the call to "g" in "f" refers to the outer
one, not the inner one. In other words, when the machine reaches the definition
of "f" its state looks like this:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">environment</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">fun["f","z",call["g","z"]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["g","y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">mul[call["f",1],call["g",1]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">[</span><span class="RktPn">fun["g","w","w"]</span><span class="RktPn">]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr></table></blockquote></div><div class="SIntrapara">That is, the environment already contains the definition of all free names in the
control code. If the machine is to run the function&rsquo;s body in the correct scope,
it must also remember the environment.</div></p><p><div class="SIntrapara">The example suggests a slight revision of the brute force approach. Instead of
moving only the <span class="RktSym">fun</span> definition into the environment, the machine also
remembers the environment itself with this function definition. Here is the
notation we use for this form of environment extension:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="hspace">&nbsp;</span><span class="RktPn">fun[fn,x,ae1]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">When it comes to implementing this form of environment extension, it suffices to
associate the <span class="RktSym">fun</span> definition with a reference to the current environment.
As in the preceding section, extending the environment with a <span class="RktSym">fun</span>
definition shadows any existing association of this name (fn) to a value or a
<span class="RktSym">fun</span> definition.</div></p><p><div class="SIntrapara">Now that we have this representation, the machine is a rather natural adaptation
of the one in <a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a>:
</div><div class="SIntrapara"><ul><li><p>The code register contains arbitrary <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> expressions.</p></li><li><p>Because of function calls, the environment contains both <span class="RktSym">fun</span>
definitions and ordinary variable-number associations.</p></li><li><p>Similarly, function calls demand an evaluation of the function argument,
and <span class="RktPn">call[fn,{--}]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a> is thus a new kind of stack frame.
But, in the absence of <span class="RktSym">let</span> definitions, the machine does not need
<span class="RktSym">block</span>-based frames.</p></li></ul></div><div class="SIntrapara">Once you have data descriptions for the registers of the abstract machine,
the transitions almost write themselves. The essential transitions are displayed
in <a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a>.</div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="5"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="5"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">fun[fn,x,ae1]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">ae2</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span> is <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span class="RktPn">]</span> </p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">call[fn,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>ae2</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call[fn,{--}]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="RktRdr">,</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call[fn,{--}]</span><span class="hspace">&nbsp;</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>ae1</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" colspan="11"><p>if [<span class="RktPn">fun[fn,x,ae1]</span> /  <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>;
&#160; &#160; &#160; &#160; &#160; &#160;
<a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> is <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt"> </span><span class="RktPn"> [x &lt;- nn]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="RktPn">]</span></p></td></tr><tr><td valign="top" class="rule"><p>x</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>nn</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule" colspan="11"><p>if [x, nn] is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p><span style="font-weight: bold">Legend</span>
(1) <span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions;
(2) <span class="RktSym">fn</span> and  <span class="RktSym">x</span> represent names; and
(3) <span class="stt">nn1</span> <span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers </p></td></tr><tr><td><p>&#160;</p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afun-cek))" x-target-lift="Figure"></a>Figure&nbsp;24: </span>A CEK machine for functional Algebra</span></p></blockquote><p><div class="SIntrapara">The four rules of <a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a> explain all syntactic additions of
<span class="RktSym">fun</span> definitions to <a href="ch_arith.html#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>:
</div><div class="SIntrapara"><ol><li><p>The first one deals with <span class="RktSym">fun</span> definitions exactly as explained
above.</p></li><li><p>The second one addresses <span class="RktSym">call</span>. When the CEK machine encounters
a function call, it moves the argument into the control-code register and
remembers the need to call the function with a new frame on the stack.</p><p>This method of calling functions on values is unsurprisingly named
<span style="font-style: italic">call by value</span>. See <a href="#%28part._sub~3aname%29" data-pltdoc="x">Delayed Evaluation: Call By Name</a> for an alternative also
inspired by algebra.</p><p>Notice that the <span class="RktSym">call</span> instruction does <span class="emph">not</span> push a frame onto the
control stack.</p></li><li><p>In this programming language with algebra-like functions, arguments
evaluate to numbers, and it is added to the function&rsquo;s environment, just like
<span class="RktSym">let</span> variables. What the third rule also shows is that the <span class="RktSym">fun</span>
definition must be added again because functions just might call themselves.</p></li><li><p>The last rule shows that retrieving variables works just like in the
preceding section. So even if <span class="RktSym">let</span> definitions are missing, the
underlying mechanism still exists.</p></li></ol></div><div class="SIntrapara">Since the machine extends environments in two different ways and functions are
not (yet) values, these transition rules aren&rsquo;t as complete as the ones in the
preceding section. Specifically, if the environment contains a function
definition whose name is "z" and the machine looks for an association of "z" to a
number, it gets <span style="font-style: italic">stuck</span>, that is, there is no transition to take it to a
new state and the current state isn&rsquo;t final. <a href="#%28part._sec~3atheorems2%29" data-pltdoc="x">Theorems and Language Design</a> addresses
this point in detail.</div></p><p><div class="SIntrapara">Let&rsquo;s study the workings of this new CEK machine with a complete trace of the
above example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">fun["g","w","w"]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["f","z",call["g","z"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["g","y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">mul[call["f",1],call["g",1]]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">fun["f","z",call["g","z"]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["g","y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">mul[call["f",1],call["g",1]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = [ <span class="RktPn">fun["g","w","w"]</span> / <span style="font-style: italic">&#8709;</span>]</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">fun["g","y",add["y",1]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">mul[call["f",1],call["g",1]]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = [ <span class="RktPn">fun["f","y",call["g","y"]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] [ <span class="RktPn">fun["g","w","w"]</span> / <span style="font-style: italic">&#8709;</span>]</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The definition of <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span> does not match the corresponding rule in
<a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a>. We omit the extension with the function itself because
it isn&rsquo;t recursive.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><span class="RktPn">mul[call["f",1],call["g",1]]</span></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = [<span class="RktPn">fun["g","y",add["y",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] [ <span class="RktPn">fun["f","y",call["g","y"]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] </p></td></tr><tr><td valign="top" class="explain" colspan="5"><p> Although <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> contains only one function for "g" the first definition
of "g" is still reachable through the <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> associated with "f".</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><p><span class="RktPn">call["f",1]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">1</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call["f",{--}]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top"><p><span class="RktPn">call["g","z"]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span> <span class="RktPn"> ["z" &lt;- 1]</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>This transition shows the first function call. A number in the control
code register plus a <span class="RktPn">call["f",{--}]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> as the most recently added stack
frame means the machine looks up "f" and finds its definition. The argument goes
into the environment of "f" and the function body becomes the control code.</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top" class="trace"><p>"z"</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>5<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">call["g",{--}]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call["g",{--}]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p>"w"</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>5<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span> <span class="RktPn"> ["w" &lt;- 1]</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>The function named "f" immediately calls the first "g".</p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[{--},call["g",1]]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">call["g",1]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call["g",{--}]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add["y",1]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span> = <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> <span class="RktPn"> ["y" &lt;- 1]</span></p></td></tr><tr><td valign="top" class="explain" colspan="5"><p>&#160;</p></td></tr><tr><td valign="top"><p>"y"</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},1]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">1</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},1]</span> / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[1,1]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>6<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">2</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[1,{--}]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">mul[1,2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">2</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr></table></div><div class="SIntrapara">The trace has reached a final state, and the result is the expected one.</div></p><p>Take a second look at the six environments that come about during the execution
of the example on the CEK machine. Initially the machine just moves <span class="RktSym">fun</span>
definitions into the environment register. For the evaluation of function calls,
it retrieves the <span class="RktSym">fun</span> definitions and their environments. Indeed, the
machine replaces the content of the environment register with an extension of
this retrieved environment data structure.</p><p><a href="#%28counter._%28figure._fig~3afun-envs%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">25</span></a> shows how environment data structure can be understood
as an ever-growing tree. It consists of nodes and arrows that indicate growth.
Each node associates a name with a number or a <span class="RktSym">fun</span> definition.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_11.png" alt="image" width="644.4" height="330.0"/></p></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afun-envs))" x-target-lift="Figure"></a>Figure&nbsp;25: </span>The environment tree of a a CEK machine for functional Algebra</span></p></blockquote><p><span class="refelem"><span class="refcolumn"><span class="refcontent">For the particular case of <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> with just
algebra-like functions, it is actually possible to arrange this tree into the
shape of a plain stack. Old-fashioned texts on compilers explain this technique.</span></span></span></p><p>The tree starts with the empty environment (not shown) and accumulates all
associations of names with <span class="RktSym">fun</span> definitions and numbers.  At any
particular point in time, the register points to one of the nodes in this
tree. Looking for a name from a particular pointer starts at the specified node
and proceeds downwards toward the root of the tree. When this search finds a
node with the desired name, it stops.</p><p><span style="font-weight: bold">Exercises</span> The following set of exercises form a small project that will
deepen your understanding of the CEK machine design.</p><p><a name="(counter._(exercise._ex~3acek-alg1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;41. Describe all states, the initial states, and the final
states of the CEK machine from <a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a> for the simplified
<a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> language. Complete the set of transitions. <a href="#%28counter._%28exercise._ex~3acek-alg1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3acek-alg3))"></a><span style="font-weight: bold">Exercise</span>&nbsp;42. Implement the transition function from
<a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a> for the language of Algebra (minus <span class="RktSym">let</span>
definitions) in your chosen programming language.</p><p>When you have implemented the transition function, including a unit
test suite, design a <span class="RktSym">driver</span> function to create a complete
implementation of the abstract state machine for Algebra. <a href="#%28counter._%28exercise._ex~3acek-alg3%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3acek-alg2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;43. Use the transitions from <a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a> to
explain how the following program goes into an infinite loop.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">block[fun["g","y",call["g","y"]],call["g",42]]</span></p></blockquote></div><div class="SIntrapara">Should this execution run out of space? Does your implementation of the abstract
machine run out of space?</div></p><p>Translate the <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> program into your chosen programming
language. Does it run out of space? <a href="#%28counter._%28exercise._ex~3acek-alg2%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3acek-alg4))"></a><span style="font-weight: bold">Exercise</span>&nbsp;44. <a href="#%28counter._%28exercise._ex~3arecursive~3f%29%29" data-pltdoc="x">Exercise&nbsp;31</a> already suggests that the
language lacks a conditional to make this capability useful.</p><p>Design a concrete syntax for your favorite conditional expression. It can be as
simple as an <span class="RktSym">if</span> expression.
Then extend the implementation of <a href="#%28counter._%28exercise._ex~3acek-alg3%29%29" data-pltdoc="x">exercise&nbsp;42</a> to include this
conditional. <a href="#%28counter._%28exercise._ex~3acek-alg4%29%29" class="ex-end" data-pltdoc="x"></a></p><h5>3.5.1<tt>&nbsp;</tt><a name="(part._sub~3aname)"></a>Delayed Evaluation: Call By Name</h5><p><div class="SIntrapara">Algebra worksheets and books also come with problems that don&rsquo;t seem to fit our
idea of a programming language and how programs are evaluated:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 4  </span>Let <span style="font-style: italic">f</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = </span>3<span style="font-style: italic"> * x</span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> - </span>2<span style="font-style: italic"> * x + </span>4<span style="font-style: italic"></span>.</p></td></tr><tr><td><p>Let <span style="font-style: italic">g</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = </span>2<span style="font-style: italic"> * x + </span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is <span style="font-style: italic">f</span>(<span style="font-style: italic">g</span>(<span style="font-style: italic"></span>3<span style="font-style: italic"> * y</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>? When you have the result plug in <span style="font-style: italic">y = </span>1<span style="font-style: italic"></span>?</p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The answer is 940 but the important idea is
that substitution can work on entire terms not just numbers:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-style: italic">f</span>(<span style="font-style: italic">g</span>(<span style="font-style: italic"></span>3<span style="font-style: italic"> * y</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic">f</span>(<span style="font-style: italic"></span>2<span style="font-style: italic"> * </span>[<span style="font-style: italic"></span>3<span style="font-style: italic"> * y</span>]<span style="font-style: italic"> + </span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></td></tr><tr><td><p><span style="font-style: italic">=</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-style: italic"></span>3<span style="font-style: italic"> * </span>[<span style="font-style: italic"></span>2<span style="font-style: italic"> * </span>(<span style="font-style: italic"></span>3<span style="font-style: italic"> * y</span>)<span style="font-style: italic"> + </span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>]<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> - </span>2<span style="font-style: italic"> * </span>[<span style="font-style: italic"></span>2<span style="font-style: italic"> * </span>(<span style="font-style: italic"></span>3<span style="font-style: italic"> * y</span>)<span style="font-style: italic"> + </span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>]<span style="font-style: italic"> + </span>4<span style="font-style: italic"></span></p></td></tr></table></div><div class="SIntrapara">The calculations uses the convention of bracketing the expression that is
substituted for the function&rsquo;s parameter&#8212;<wbr></wbr>as programming languages calls the
dependent variable of a function definition.  The resulting expression is a (n
unnamed) function of <span style="font-style: italic">y</span>, and if we substitute <span style="font-style: italic"></span>1<span style="font-style: italic"></span> for <span style="font-style: italic">y</span> we get
940 again.</div></p><p><div class="SIntrapara">The key is, however, that the calculation does <span class="emph">not</span> reduce the arguments
to numbers <span class="emph">before</span> the substitution happens. Now consider the following
algebra problem:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Problem 5  </span>Let <span style="font-style: italic">f</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"> = </span>4<span style="font-style: italic"></span>2<span style="font-style: italic"></span>.</p></td></tr><tr><td><p>What is the value of <span style="font-style: italic">f</span>(<span style="font-style: italic"> </span>1<span style="font-style: italic">/</span>0<span style="font-style: italic"> </span>)<span style="font-style: italic"></span>?</p></td></tr></table></blockquote></div><div class="SIntrapara">You will never encounter such a problem in a course on algebra, but in the realm
of programming such programs exist. One method of calculation produces the
&ldquo;obvious&rdquo; answer <span style="font-style: italic"></span>4<span style="font-style: italic"></span>2<span style="font-style: italic"></span>; the other one does not get past the division by
<span style="font-style: italic"></span>0<span style="font-style: italic"></span>.</div></p><p>Early programming language designers had the idea that programs should be able
to deliver an answer if there exists one. Algol &rsquo;60 is the prime example of
such a language design effort. The designers of Algol named this function call
discipline <span style="font-style: italic">call by name</span>. It was an idea that some pursued for
several decades, considering it the essence of mathematics turned into
programming. Haskell, a contemporary language, still adheres to this
philosophy; see <a href="ch_mutation.html#%28part._cesk._sec~3alaziness%29" data-pltdoc="x">Call by Need</a> for details.</p><p><div class="SIntrapara">An explanation in terms of a CEK machine is rather straightforward. One
transition rule must obviously change: the one for function calls.  Instead of
evaluating the argument expression, the revised transition rule directly calls
the function and associates the function&rsquo;s parameter with the argument expression
in the environment. This obvious change implies three more:
</div><div class="SIntrapara"><ul><li><p>Moving an expression into the environment is like moving a <span class="RktSym">fun</span>
definition there. Since the expression may contain free variables, the new
variable association in the environment includes an environment. The first rule
in <a href="#%28counter._%28figure._fig~3afun-cek-cbn%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">26</span></a> uses the notation [<span class="RktPn">fun[fn,x,ae1]</span> /
<a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] to indicate such an extension.</p></li><li><p>When a variable shows up in the control-code register the machine
retrieves an expression with an environment from the current environment, The
second rule in <a href="#%28counter._%28figure._fig~3afun-cek-cbn%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">26</span></a> uses [x, ae2 / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] for this
retrieval. The machine then installs ae2 and <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span> into the corresponding
registers.</p></li><li><p>A function call never creates a continuation frame.</p></li></ul></div><div class="SIntrapara">Stop! When do function arguments actually get evaluated?</div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="5"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="5"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">call[fn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>ae1</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" colspan="11"><p>if [<span class="RktPn">fun[fn,x,ae1]</span> /  <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a>;
&#160; &#160; &#160;
<a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span> is <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt"> </span><span class="RktPn"> [x &lt;- ae2]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun[fn,x,ae1]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="RktPn">]</span></p></td></tr><tr><td valign="top" class="rule"><p>x</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>ae2</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="ch_arith.html#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule" colspan="11"><p>if [x, ae2 / <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>] is in <a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a></p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p><span style="font-weight: bold">Legend</span>
(1) <span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions; and
(2) <span class="RktSym">fn</span> and  <span class="RktSym">x</span> represent names; and
(3) <span class="stt">nn1</span> <span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers </p></td></tr><tr><td><p>&#160;</p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afun-cek-cbn))" x-target-lift="Figure"></a>Figure&nbsp;26: </span>A call-by-name CEK machine for functional Algebra</span></p></blockquote><p><a name="(counter._(exercise._ex~3acek-cbn1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;45. Describe all states, the initial states, and the final
states of the call-by-name CEK machine from <a href="#%28counter._%28figure._fig~3afun-cek-cbn%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">26</span></a>. Then
complete the set of transitions. <a href="#%28counter._%28exercise._ex~3acek-cbn1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara"><a name="(counter._(exercise._ex~3acek-cbn2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;46. Trace the evaluation of the following program on both
CEK machines:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">fun["g","y",mul["y","y"]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">fun["h","z",call["g","z"]]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">call["h",add[10,10]]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">If you have implementations of both, just instrument the <span class="RktSym">driver</span> to
print each intermediate state. Otherwise calculate by hand.</div></p><p>Note how the call-by-name machine evaluates <span class="RktPn">add[10,10]</span> twice, while
the regular CEK machine evaluates it only once. <a href="#%28counter._%28exercise._ex~3acek-cbn2%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>3.6<tt>&nbsp;</tt><a name="(part._sec~3atheorems2)"></a>Theorems and Language Design</h4><p>Proving theorems about evaluators is a form of language-design debugging. For
example, an attempt to prove theorems about a blueprint like those in
<a href="ch_arith.html#%28part._sec~3atheorems1%29" data-pltdoc="x">Theorems</a> can have two outcomes. A <span class="emph">positive</span> one is a proof of
the theorem; it confirms rudimentary properties about the
design. <span class="refelem"><span class="refcolumn"><span class="refcontent">This distinction ignores the possibility that the proof
fails <span class="emph">without</span> delivering a counter-example to the conjecture. In this
case, we do not know whether the theorem holds or not.</span></span></span>  A <span class="emph">negative</span>
result may show that the conjectured theorem is not true, that is, it is
<span class="emph">not</span> a theorem. This outcome may point out gaps in the design, and a
language designer might be able to address while preserving the pragmatics for
the intended audience.</p><p><div class="SIntrapara">Even a language as simple as <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> can serve as an example for this
idea. Let&rsquo;s start with naming some evaluators of interest that this chapter
introduces:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">name</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">domain</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;" colspan="3"><p><span style="font-style: italic">range</span></p></td></tr><tr><td valign="top"><p><a name="(tech._cek._let)"></a><span style="font-style: italic">cek-let</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>, <span class="RktSym">let</span> only</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._algebra._%28figure._fig~3alet-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">23</span></a></p></td></tr><tr><td valign="top"><p><span style="font-style: italic">cek-fun</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>, <span class="RktSym">fun</span> only</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a></p></td></tr></table></blockquote></div><div class="SIntrapara">As before, the names denote mathematical relations generated as the
transitive-reflexive closure of the transition relations. The domain is
restricted to a subset of the language. The range is still Number, because the
language design itself treats only numbers as proper values,</div></p><p>All three evaluators still define mathematical functions. Thus, whenever a
programmer runs a specific program, the result will be the same in terms of this
mathematics.</p><p><span style="font-weight: bold">Basic Theorem</span> The relations <a href="ch_arith.html#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a>, <a href="ch_arith.html#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a>, and
<a href="ch_arith.html#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a> are mathematical functions on their specified domain and range.</p><p>The second theorem, however, holds only for the first evaluator, <a href="#%28tech._cek._let%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-let</span></a>,
not the others. For a student of programming languages, this does not come as a
surprise. Recursive functions introduce the possibility of <span style="font-style: italic">diverging
programs</span>, which, according to theoreticians of computer science, is an
essential characteristic of full-fledged languages. A diverging program&#8212;<wbr></wbr>also
known as non-terminating&#8212;<wbr></wbr>does not have a result.</p><p><span style="font-weight: bold">Strong Evaluation Theorem</span> The evaluator <a href="#%28tech._cek._let%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-let</span></a> is a total
function on its specified domain. The evaluators <a href="ch_arith.html#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a>, and
<a href="ch_arith.html#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a> are partial functions.</p><p>Programming language researchers like to state this idea in a precise way, They
therefore tend to resort to a different theorem statement to bring this
across. To start with, they define evaluators with a range expressed with the
underlying machinery in mind. In the case of a CEK machine, this means
<span style="font-style: italic">terminal states</span>, that is, states to which no transition rule applies.</p><p><div class="SIntrapara">For <a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a>, a terminal state does not have to be a final state. The
discussion of <a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a> abstractly alludes to the problem, but it
is always best to see concrete examples. Here is a grammatical correct program
that runs into a stuck state:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">env.</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">stack</span></p></td></tr><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">block</span><span class="RktPn">[</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktSym">fun</span><span class="RktPn">[</span><span class="RktVal">"g"</span><span class="RktRdr">,</span><span class="RktVal">"g"</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">call["g","g"]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">call["g",42]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">&#8709;</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">call["g",42]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>[<span class="RktPn">fun["g","g",call["g","g"]]</span> / <span style="font-style: italic">&#8709;</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">42</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span class="RktPn">fun["g","g",call["g","g"]]</span> / <span style="font-style: italic">&#8709;</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call["g",{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">call["g","g"]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>[<span class="RktPn">fun["g","g",call["g","g"]]</span> / <span style="font-style: italic">&#8709;</span>]</p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p>"g"</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span class="RktPn">fun["g","g",call["g","g"]]</span> / <span style="font-style: italic">&#8709;</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">call["g",{--}]</span></p></td></tr></table></div><div class="SIntrapara">This last state is a terminal state, because the environment does <span class="emph">not</span>
contain an association of "g" with a number. The last environment comes about
through the application of the transition rule for function calls, which says
that the environment register of the next state is set to
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">&#8709;</span><span class="stt"> </span><span class="RktPn"> ["g" &lt;- 42]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktPn">fun["g","g",call["g","g"]]</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><a href="#%28tech._algebra._e%29" class="techoutside" data-pltdoc="x"><span class="techinside">E</span></a><span style="font-style: italic"></span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">Since an environment may contain only one association per name in the CEK
machine, and since the extension with the <span class="RktSym">fun</span> definition is the second
one, the result is
</div><div class="SIntrapara"><blockquote><p>[<span class="RktPn">fun["g","g",call["g","g"]]</span> / <span style="font-style: italic">&#8709;</span>]</p></blockquote></div><div class="SIntrapara">And, as stated, this environment lacks an association of "g" with a number.</div></p><p><div class="SIntrapara">Terminal states that aren&rsquo;t final states are called <span style="font-style: italic">stuck states</span>.
While it might be tempting to list specific stuck states as possible results of
a program evaluation, programming language people prefer to hide the precise
nature of the underlying machine with definitions such as the following:
</div><div class="SIntrapara"><blockquote><p><a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a>(ae) = <span class="stt">stuck</span></p><p>if the transitive closure of the CEK transition relation reaches a terminal
state that is not a final state.  </p></blockquote></div><div class="SIntrapara">and by implication
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">name</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">domain</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;" colspan="3"><p><span style="font-style: italic">range</span></p></td></tr><tr><td valign="top"><p><a name="(tech._cek._fun)"></a><span style="font-style: italic">cek-fun</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>, <span class="RktSym">fun</span> only</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number, <span class="stt">stuck</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._%28figure._fig~3afun-cek%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a></p></td></tr></table></blockquote></div></p><p>With this revision, we can precisely characterize <a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a> with a theorem
that generalizes strong evaluation.</p><p><div class="SIntrapara"><span style="font-weight: bold">Stuck State Theorem</span> For all <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a> expressions <span class="RktSym">ae</span>
(without <span class="RktSym">let</span>), one of the following statements hold:
</div><div class="SIntrapara"><ul><li><p><a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"></span> is a number;</p></li><li><p><a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"></span> is <span class="stt">stuck</span>; or</p></li><li><p><a href="#%28tech._cek._fun%29" class="techoutside" data-pltdoc="x"><span class="techinside">cek-fun</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"></span> is undefined, meaning the program diverges.</p></li></ul></div></p><p><div class="SIntrapara">Language theoreticians do not like designs that lead to stuck states. It is, in
principle, legitimate to interpret these gaps in meaning design as permission
for the implementor to have the machine perform arbitrary actions. Conversely,
the discovery of (the equivalent of) stuck states in the description of a
language&rsquo;s meaning is often taken as a challenge to eliminate the gaps. In the
case of <a href="#%28tech._ast._algebra%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-algebra</span></a>, there are two choices:
</div><div class="SIntrapara"><ul><li><p>Treat the failed attempt to retrieve a number from the environment as an
exception, similar to division by <span class="RktVal">0</span>. This solution is common in
contemporary scripting languages.</p></li><li><p>Change the grammar so that names used as function names in <span class="RktSym">fun</span>
definitions may not show up in any other position but the function position in
<span class="RktSym">call</span> expressions. This solution is a variant of the separate name space
solution. Instead of using two name spaces, it employs a static check similar to
the one for free variables to discover ill-formed programs.</p></li><li><p>Adding a type system is the proper generalization of the second alternative.
The type system also rejects programs after they are declared grammatically
correct. But, instead of somewhat ad hoc rules such as the ones for using names
in certain ways, it comes with uniform rules that find many more
mistakes. <a href="ch_types.html" data-pltdoc="x">Types</a> presents this alternative. Most traditional and
contemporary typed languages use this approach.</p></li></ul></div><div class="SIntrapara">The next section includes a project on exploring the first alternative.</div></p><h4>3.7<tt>&nbsp;</tt><a name="(part._sec~3a3sum)"></a>Summary</h4><p><span class="refelem"><span class="refcolumn"><span class="refcontent">At the pre-college level such courses often fail to
introduce proper words and proper distinctions for these ideas. But a thorough
study of programming languages demands good terminology.</span></span></span>
Variables and functions are the most basic building blocks of software, and they
are direct descendants of ideas found in school-level algebra courses.  A
programmer must understand all implications. Otherwise it is impossible to think
about programs and predict their behavior, especially because programming
languages pile a number of features on top of variables and functions.</p><p><div class="SIntrapara">Here are the ideas that this chapter introduces beyond those of <a href="ch_arith.html" data-pltdoc="x">Arithmetic,
Your First Programming Language</a>:
</div><div class="SIntrapara"><ul><li><p>The definition of a name comes with a <span style="font-weight: bold">scope</span>, a region of text where
the definition is valid. This is equally true for variable definitions, function
definitions, and function parameters.</p></li><li><p>In principle, <span style="font-weight: bold">substituting</span> arguments for parameters explains the
behavior of functions. Replacing a name with its definition in its scope explains
what a definition means.</p></li><li><p>A more concrete explanation represents substitutions as <span style="font-weight: bold">environments</span>,
tables that associate names with values and functions.</p><p>So, in a CEK machine, C represents active instructions, E represents the meaning
of names in the instructions, and K represents what is left to do when the
instructions have been executed.</p></li><li><p>Theorems can serve as an <span style="font-weight: bold">evaluation criteria</span> for language
designs. (But, many other factors are equally important.)</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Project</span> Here is a JSON syntax for an Algebra-like language:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">An Algebra expressions rendered as JSON is one of the following:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "*", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "-", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "/", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["if0", X, Y, Z]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["for0",</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,X,Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["decl",</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,[</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,X],Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["call",</span><a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a><span class="stt">,X,Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where </span><span class="stt">X</span><span class="stt">, </span><span class="stt">Y</span><span class="stt">, and </span><span class="stt">Z</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">are JSON representations of Algebra expressions.</span></p></td></tr></table></div></p><p>Two features associate a static scope with a name. In the <span class="stt">for0</span> loop <span class="stt">Y</span>
is the scope of the <a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a>. In the <span class="stt">decl</span> array, the first <a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a>
is the function name and, as such, is visible in <span class="stt">X</span> and <span class="stt">Y</span>; the second
<a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a> is the function&rsquo;s parameter and only visible in <span class="stt">X</span>.</p><p><div class="SIntrapara">As for the informal meaning of the language constructs, the meaning of
</div><div class="SIntrapara"><ul><li><p>the arithmetic subset of this language is as before. Remember
that the CEK machine stops with a <span class="stt">division-by-0</span> error.</p></li><li><p>the conditional is that the value of <span class="stt">X</span> determines the value of the
expression: <span class="RktVal">0</span> means <span class="RktSym">Y</span> is run, while a non-0 number means the
execution proceeds with <span class="stt">Z</span>.</p></li><li><p>the function declaration combines <span class="RktSym">block</span>s and <span class="RktSym">fun</span>s into a
single construct. The result of a <span class="stt">decl</span> is the result of its body <span class="stt">Y</span>.</p></li><li><p>the function call expression has the same meaning as in this chapter.</p></li></ul></div></p><p><div class="SIntrapara">The rather unique <span class="stt">for0</span> loop needs some explanation. Let&rsquo;s make the syntax a
bit more concrete with an example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">["for0", "x", N, ["call", "f", "x"]]</span></p></td></tr></table></div><div class="SIntrapara">for some expression <span class="stt">N</span>. It evaluates the <span class="stt">N</span> to a number <span style="font-style: italic">n</span>. It
then successively associates <span class="stt">x</span> with <span style="font-style: italic"></span>0<span style="font-style: italic"></span> to <span style="font-style: italic">n-</span>1<span style="font-style: italic"></span> and evaluates
the body expression. For this example, the loop calls <span class="stt">f</span> on <span class="stt">x</span>. The
first time the loop&rsquo;s body expression evaluates to <span style="font-style: italic"></span>0<span style="font-style: italic"></span>, the loop stops and
returns the current value of <span class="stt">x</span>. <span class="refelem"><span class="refcolumn"><span class="refcontent">Check out Racket&rsquo;s
<span class="RktSym">for/first</span>, which is a similar loop.</span></span></span></div></p><p><div class="SIntrapara">Develop a program in your chosen language that reads valid JSON expressions from
standard input and prints one of these possible results to standard output:
</div><div class="SIntrapara"><ul><li><p><span class="stt">"syntax error"</span> if the JSON text is not formed according to the grammar;</p></li><li><p><span class="stt">"undefined variable"</span> if the JSON text contains a <a href="#%28tech._name%29" class="techoutside" data-pltdoc="x"><span class="techinside">Name</span></a> without
corresponding definition;</p></li><li><p><span class="stt">"division by 0"</span> if the execution of the program attempts to divide by 0;</p></li><li><p><span class="stt">"number expected, function found"</span> if the execution of the program tries
to retrieve the numeric value of a variable and finds a <span class="RktSym">fun</span> definition
in the environment instead;</p></li><li><p><span class="stt">"function expected, number found"</span> if the execution of the program tries
to retrieve a function and finds a numeric variable association in the
environment instead;</p></li><li><p>a JSON number if the syntax is correct, all variables are declared, and
everything evaluates correctly.</p></li></ul></div></p><p>Identify the components of your program and make sure to understand
which component can terminate your program with which error message.
Keep in mind that you need to develop an abstract syntax description
first.</p><p>Base the program on the CEK machine. Make sure to describe all
possible environments and stacks in terms of your chosen language
before you code.</p><p>Demonstrate with one integration test that your program properly supports
recursion.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_arith.html" title="backward to &quot;2 Arithmetic,
Your First Programming Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_lambda.html" title="forward to &quot;4 First-Class Functions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2&nbsp;Arithmetic,
Your First Programming Language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Machines and Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="ch_pl.html" class="tocviewlink" data-pltdoc="x">Programming Languages</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="ch_algebra.html" class="tocviewlink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="ch_lambda.html" class="tocviewlink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ch_mutation.html" class="tocviewlink" data-pltdoc="x">Mutable Objects</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="ch_cc.html" class="tocviewlink" data-pltdoc="x">Full Control</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="ch_express.html" class="tocviewlink" data-pltdoc="x">The Dimensions</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="ch_space.html" class="tocviewlink" data-pltdoc="x">Space</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="ch_types.html" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="ch_futures.html" class="tocviewlink" data-pltdoc="x">Futures</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._sec~3aarith-syn%29" class="tocviewlink" data-pltdoc="x">The Syntax and Abstract Syntax of Arithmetic</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._sec~3ainterpreter%29" class="tocviewlink" data-pltdoc="x">An Interpreter for Arithmetic</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part._sec~3astepper-1%29" class="tocviewlink" data-pltdoc="x">A State Machine for Arithmetic:<span class="mywbr"> &nbsp;</span> Non-<wbr></wbr>Determinism</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#%28part._step2._sec~3astepper-2%29" class="tocviewlink" data-pltdoc="x">A State Machine for Arithmetic:<span class="mywbr"> &nbsp;</span> Determinism</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#%28part._sec~3astack%29" class="tocviewlink" data-pltdoc="x">A Stack Machine for Arithmetic</a></td></tr><tr><td align="right">2.6&nbsp;</td><td><a href="#%28part._sec~3aexceptions%29" class="tocviewlink" data-pltdoc="x">Division</a></td></tr><tr><td align="right">2.7&nbsp;</td><td><a href="#%28part._sec~3atheorems1%29" class="tocviewlink" data-pltdoc="x">Theorems</a></td></tr><tr><td align="right">2.8&nbsp;</td><td><a href="#%28part._sec~3a2sum%29" class="tocviewlink" data-pltdoc="x">Summary</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8.0.1</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_pl.html" title="backward to &quot;1 Programming Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_algebra.html" title="forward to &quot;3 Algebra, Your Second Programming
Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._ch~3aarith)"></a>Arithmetic,
Your First Programming Language</h3><p>In the beginning, computer people saw programming as a generalization of
arithmetic. They perceived computers as vast and extremely fast calculators.
And to this day, every full-fledged programming language contains a language for
stating arithmetic computations.</p><p>Arguably, your first experience in formal programming concerned arithmetic. Your
teacher taught you adding, subtracting, multiplying, and dividing numbers and a
notation for stating such calculations. Then your teacher assigned you lots of
homework assignments, and you calculated. Your teacher programmed, and you
played the role of the computer.</p><p>This chapter uses the simple programming langauge of arithmtic&#8212;<wbr></wbr>a language
found within almost every programming language&#8212;<wbr></wbr>to introduce a series of
important principles with concrete examples: syntax, abstract syntax, semantics
from interpreters and state machines, , models, blueprints, and some more.
Subsequent chapters build on, and expand, these principles.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aarith-syn%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>The Syntax and Abstract Syntax of Arithmetic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3ainterpreter%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>An Interpreter for Arithmetic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3astepper-1%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>A State Machine for Arithmetic: Non-Determinism</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._step2._sec~3astepper-2%29" class="toclink" data-pltdoc="x">2.4<span class="hspace">&nbsp;</span>A State Machine for Arithmetic: Determinism</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3astack%29" class="toclink" data-pltdoc="x">2.5<span class="hspace">&nbsp;</span>A Stack Machine for Arithmetic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Names_of_.Machines__.C__.C.C__.C.K%29" class="toclink" data-pltdoc="x">2.5.1<span class="hspace">&nbsp;</span>The Names of Machines: C, CC, CK</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aexceptions%29" class="toclink" data-pltdoc="x">2.6<span class="hspace">&nbsp;</span>Division</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3atheorems1%29" class="toclink" data-pltdoc="x">2.7<span class="hspace">&nbsp;</span>Theorems</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3a2sum%29" class="toclink" data-pltdoc="x">2.8<span class="hspace">&nbsp;</span>Summary</a></p></td></tr></table><h4>2.1<tt>&nbsp;</tt><a name="(part._sec~3aarith-syn)"></a>The Syntax and Abstract Syntax of Arithmetic</h4><p><div class="SIntrapara"><span style="font-weight: bold">Syntax</span>
<a href="part_prologue.html" data-pltdoc="x">Prologue</a> presents a rather primitive form of arithmetic: addition.
Let&rsquo;s start with a simple generalization of this language:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of nested arithmetic expressions uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- numbers as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representations of arithmetic expressions.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "*", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representations of arithmetic expressions.</span></p></td></tr></table></div><div class="SIntrapara">With this language you can write down additions <span class="emph">and</span>
multiplications!<span class="refelem"><span class="refcolumn"><span class="refcontent">No worries, this chapter also gets to subtraction
and division.</span></span></span></div></p><p>If you also want to generalize the program from <a href="part_prologue.html" data-pltdoc="x">Prologue</a> that
computes the value of such an expression, you might be tempted to add a line to
description of the internal data representation and another one in the
definition of <span class="RktSym">sum</span>. There is a first problem,
however. <a href="part_prologue.html" data-pltdoc="x">Prologue</a> comes with the implicit promise that the input
is perfectly formed, and this promise is simply unrealistic in the world of
programming languages. Programmers make mistakes, and a programming language
must deal with it.</p><p><div class="SIntrapara">So imagine an inattentive programmer who accidentally writes
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[12 34 "+" 56]</span></p></td></tr></table></div><div class="SIntrapara">The JSON library of a programming language reads <span class="emph">all</span> of JSON expressions,
not just arithmetic expressions.  And then your <span class="RktSym">sum</span> function is applied
to a list that it cannot deal with.</div></p><p>Technically, the JSON reader encounters a sequence of characters: <span class="stt">"["</span>,
<span class="stt">"1"</span>, <span class="stt">"2"</span>, <span class="stt">" "</span>, <span class="stt">"3"</span>, <span class="stt">"4"</span>, and so on. Its first task is
to recognize the words: the left bracket, the <span class="stt">12</span>, the <span class="stt">34</span>, the string
<span class="stt">"+"</span> all the way to the end.</p><p><div class="SIntrapara">The JSON reader performs an additional task. It groups tokens according to
matching brackets and braces, thereby identifying the nesting structure of JSON
arrays and JSON objects. If this process took place in Racket, it would deliver
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">12</span><span class="hspace">&nbsp;</span><span class="RktVal">34</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">56</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">a representation of the text as Racket data. In general, a library such as the
JSON reader comes with a description of all possible data that it may deliver,
regardless of the data a programs may wish to receive.</div></p><p><div class="SIntrapara">A second problem concerns the contrast between the <span class="emph">idea</span> of arithmetic and
the concrete notation. For example, the chosen JSON representation already
eliminates the order-of-operations problem that so many kids struggle with
initially. By using nested arrays, each of which uses exactly addition or
multiplication, all of us know exactly what is to be computed. Consider Racket,
though. It uses the text
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">to express what JSON says with <span class="stt">[1, ",", 1]</span>. Yet, the two expressions send
the same message to a reader: add <span class="RktVal">1</span> and <span class="RktVal">1</span>. And some calculators
use post-fix notation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">for the same addition. Clearly all of these notations&#8212;<wbr></wbr>and some more&#8212;<wbr></wbr>are in
some sense equivalent. When we wish to understand how a programming language
deals with addition expressions, we know that, internally, it deals with all of
these concrete notations in the same way.</div></p><p><span style="font-weight: bold">Abstract Syntax</span> To address these two problems, the programming language
world has developed the notion of abstract syntax and parsing. Roughly speaking,
<span style="font-style: italic">abstract syntax</span> is an internal data representation of programming
text. It is called abstract because it hides the concrete notation, and indeed,
several different concrete representations. It is syntax because it still
resembles program notation.</p><p><div class="SIntrapara">Structures (or objects) make a conventional choice for abstract syntax. This
book uses a notation that is easily translated into any programming language.
For arithmetic expressions, we need two structures:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">left</span><span class="RktRdr">,</span><span class="RktSym">right</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">//</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">structure</span><span class="hspace">&nbsp;</span><span class="RktSym">with</span><span class="hspace">&nbsp;</span><span class="RktSym">two</span><span class="hspace">&nbsp;</span><span class="RktSym">fields:</span></td></tr><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">mul</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">left</span><span class="RktRdr">,</span><span class="RktSym">right</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">//</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Here are some examples of abstract syntax and the concrete syntax it represents:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td valign="top" colspan="2"><p></p></td><td valign="top" colspan="2"><p>Concrete Syntax</p></td></tr><tr><td style="border-bottom: 1px solid black;"><p>Abstract Syntax</p></td><td style="border-bottom: 1px solid black;"><p>JSON</p></td><td style="border-bottom: 1px solid black;"><p>Racket</p></td><td style="border-bottom: 1px solid black;"><p>calculator</p></td></tr><tr><td valign="bottom"><p><span class="RktPn">add[1,1]</span></p></td><td valign="bottom"><p><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktSym">,</span><span class="RktVal">"+"</span><span class="RktSym">,</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktMeta"></span></p></td><td valign="bottom"><p><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p></td><td valign="bottom"><p><span class="stt">1 1 +</span></p></td></tr><tr><td valign="bottom"><p><span class="RktPn">mul[2,2]</span></p></td><td valign="bottom"><p><span class="RktPn">[</span><span class="RktVal">2</span><span class="RktSym">,</span><span class="RktVal">"*"</span><span class="RktSym">,</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktMeta"></span></p></td><td valign="bottom"><p><span class="RktPn">(</span><span class="RktSym">*</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span></p></td><td valign="bottom"><p><span class="stt">2 2 *</span></p></td></tr><tr><td valign="bottom"><p><span class="RktPn">mul[add[1,1],2]</span></p></td><td valign="bottom"><p><span class="RktPn">[</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktSym">,</span><span class="RktVal">"+"</span><span class="RktSym">,</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktSym">,</span><span class="RktVal">"*"</span><span class="RktSym">,</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktMeta"></span></p></td><td valign="bottom"><p><span class="RktPn">(</span><span class="RktSym">*</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span></p></td><td valign="bottom"><p><span class="stt">1 1 + 2 *</span></p></td></tr></table></div><div class="SIntrapara">The point of abstract syntax, though, is that it represents the concrete syntax
with a tree-shaped data structure where each node corresponds to a rule in the
grammar of the language. For example, <span class="RktPn">mul[add[1,1],2]</span> can be written down as
this tree:</div></p><p><div class="SIntrapara"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_4.png" alt="image" width="259.587890625" height="146.8984375"/></p></blockquote></div><div class="SIntrapara">As always in computer science, the tree shape is upside-down. The rectangular
nodes represent one of the structures, while the circular ones denote a leaf,
here a number. The labeled edges stand for the &ldquo;field&rdquo; relationship between
structures and content.</div></p><p><div class="SIntrapara">A generalization of the examples leads directly to a data description of the
abstract syntax for arithmetic:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">An </span><a name="(tech._abstract._syntax._tree._for._arithmetic)"></a><span style="font-style: italic">abstract syntax tree for arithmetic</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">(</span><a name="(tech._ast._arithmetic)"></a><span style="font-style: italic">AST-arithmetic</span><span class="stt">) is one of:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- a number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- add[l,r]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- mul[l,r]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where </span><span class="RktSym">l</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">and </span><span class="RktSym">r</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">belong to </span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">.</span></p></td></tr></table></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Chomsky developed the notion of grammars before Backus and Naur
created a notation like this one for the description of Algol 60.</span></span></span>
Research papers use a more concise but equivalent version of this definition,
often called <span style="font-style: italic">BNF</span>, <span style="font-style: italic">Backus-Naur Form</span>, and equivalent names:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">AST-arithmetic</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">Note how, regardless of the precise shape, this data description refers to
itself in the second and third bullet of the enumeration.</div></p><p><a name="(counter._(exercise._ex~3aarith1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;5. Represent <span class="stt">[13,"+",[[1,"*",1],"+",72]]</span> with abstract syntax. <a href="#%28counter._%28exercise._ex~3aarith1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3aarith2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;6. Render the abstract syntax
<span class="RktPn">add[mul[add[2,mul[1,3]],8],9]</span> in our chosen JSON syntax, Racket,
and the calculator notation. <a href="#%28counter._%28exercise._ex~3aarith2%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3aarith3))"></a><span style="font-weight: bold">Exercise</span>&nbsp;7. Draw the trees for the <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> structures in
<a href="#%28counter._%28exercise._ex~3aarith2%29%29" data-pltdoc="x">exercise&nbsp;6</a>. <a href="#%28counter._%28exercise._ex~3aarith3%29%29" class="ex-end" data-pltdoc="x"></a></p><p><span style="font-weight: bold">Parsing</span> A JSON reader turns text into data. A parser performs two tasks
for this data. First, it checks that the data is an arithmetic expression in the
sense of the definition at the beginning of this chapter. Second, as it checks,
it constructs an abstract syntax tree. To deal with errors, the target data
structure is an expanded notion of AST:</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">struct err [message]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._ast._arithmetic/error)"></a><span style="font-style: italic">AST-arithmetic/error</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| err[String]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">A structure like <span class="RktPn">err["invalid operation"]</span> in an AST indicates
that the parser&rsquo;s checking discovered a data structure that represents neither
an addition nor a multiplication.</div></p><p><div class="SIntrapara"><a href="#%28counter._%28figure._fig~3aparser-arith%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">9</span></a> shows a code sketch for a parser that reads a JSON
text file and returns an <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>. The JSON reader creates a
structured form of data from the given text; but not all of this data is
necessarily a correct JSON arithmetic expression. JSON comes in four shapes:
</div><div class="SIntrapara"><ul><li><p>numbers</p></li><li><p>strings</p></li><li><p>arrays of JOSN</p></li><li><p>objects of JSON</p></li></ul></div><div class="SIntrapara">Hence the parser must distinguish those four cases.</div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="www.json.org">JSON-Data</a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">--&gt; </span><a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">def parser(jd)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case jd is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">number -&gt; return jd</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">string -&gt; return </span><span class="RktPn">err["string found, invalid input"]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">array</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-&gt; if ( length of jd is not 3 )</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">record the occurrence of an error in a ``log''</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">err[array of wrong length found, invalid input]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if ( the second element of jd is "+" )</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">add[parser[jd[1]],parser[jd[3]]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if ( the second element of jd is "*" )</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">mul[parser[jd[1]],parser[jd[3]]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">err["invalid operation"]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">object -&gt; </span><span class="RktPn">err["object found, invalid input"]</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aparser-arith))" x-target-lift="Figure"></a>Figure&nbsp;9: </span>A parser for the Arithmetic Programming Language</span></p></blockquote><p>Let&rsquo;s take a look at each case in turn. In the case of numbers and strings, the
answer is clear. A number by itself is already an AST. This corresponds to the
first clause of the arithmetic grammar.  A string is a syntax error.</p><p>Not all JSON arrays are valid; only those that contain exactly three elements.
Furthermore, the middle element must be either <span class="stt">"+"</span> or <span class="stt">"*"</span>. In all
other cases, the parser may report a syntax error.</p><p>Finally, JSON objects are guaranteed to be illegal input.</p><p>In no case does the parser signal an error, though. Instead the parser returns
an <span class="RktSym">err</span> structure with an appropriate error message. Thus, if a program
contains several syntax errors, the parser can report many or even all of them
to IDE, which, in turn, can mark them up appropriately. A programmer can then
take actions on several mistakes at once.</p><p>Consider the JSON input on the left below:</p><p><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0"><tr><td><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">[[4, "/", 2],</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">"+",</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">[1, "+",</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"hello world"]]</span></p></td></tr></table></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_5.png" alt="image" width="377.326171875" height="144.8984375"/></p></td></tr></table></blockquote></div><div class="SIntrapara">A close reading tells you that its author made two mistakes: our language of
arithmetic does <span class="emph">not</span> understand division, and it certainly does not deal
with strings. The parser discovers both mistakes and records them as
<span class="RktSym">err</span> nodes in the tree it constructs. The resulting AST is on the right.</div></p><p>If the parser is able to construct an <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> instead
of an <a href="#%28tech._ast._arithmetic%2Ferror%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic/error</span></a>, the input is completely
correct. Besides constructing a proper AST, its &ldquo;log&rdquo; also reflects
the absence of errors, and a programming language implementation can
from now on proceed with the knowledge that the program is
grammatically correct.</p><p><div class="SIntrapara"><span style="font-weight: bold">Simplified</span> The presentation of syntax and parsing in this section are
highly simplified compared to a text on compilers or theory of computations:
</div><div class="SIntrapara"><ul><li><p>JSON already forces the &ldquo;programmer&rdquo; to structure text into arrays.</p></li><li><p>The JSON reader delivers structured data, that is, nested trees.</p></li><li><p>A parser for this kind of data does not have to organize a stream of
tokens into a tree.</p></li><li><p>Syntax errors immediately turn into a node; in reality, a parser may
attempt to traverse sub-trees and discover yet more correct and incorrect
pieces.</p></li></ul></div></p><p>Still, the parser of <a href="#%28counter._%28figure._fig~3aparser-arith%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a> presents the very principle of
parsing: the differentiation of (sub)trees into correct and incorrect pieces
during the construction of an abstract syntax tree. In short, you understand the
<span class="emph">principle</span> of parsing now, and from the perspective of programming
language research, it is the principle that matters.</p><p><span style="font-weight: bold">Syntax Doesn&rsquo;t Matter</span> While a programmer may prefer the syntax of Java
over the one for JavaScript or vice versa, syntax does not matter to a
programming language researcher. That is, syntax and its design aren&rsquo;t
principles of programming language research.</p><p><div class="SIntrapara">Researchers instead work with abstract syntax. By stating an abstract syntax, a
researcher implicit expresses what matters about studying a particular language
concept. For example, arithmetic poses many <span class="emph">semantic</span> problems regardless
of the chosen notation. Here is a collection of questions that the above
presentation neglects:
</div><div class="SIntrapara"><ul><li><p>how does the language deal with the imprecision of hardware calculations
compared to calculations in pure arithmetic?</p></li><li><p>does the language include numeric constants independent of the underlying
hardware?</p></li><li><p>does the language permit calculations with the square root of negative
numbers?</p></li></ul></div><div class="SIntrapara">Researchers consider such questions much more important than the choice of
notation in which programmers state the calculations.</div></p><p>Historically, people began to understand that, like a natural language, a
programming language comes with a vocabulary and a grammar. They then borrowed
ideas from linguists to write down descriptions of all tokens in a language and
all grammatically correct phrases. By the late 1960s, developers figured out
that the process of going from such descriptions to the implementation made up a
common pattern&#8212;<wbr></wbr>and like all good developers abstracted over this
pattern. Technically speaking, they created software that translated grammars
for tokens and grammatical rules into lexers and parsers. Courses on
<span style="font-style: italic">Compilers</span> or <span style="font-style: italic">Theory</span> present aspects of parsing; course on
programming languages don&rsquo;t.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Remember this idea next time you write a program that consumes
textual data.</span></span></span>  Software developers uses these descriptions as guides to coding
up lexers and parsers, not just for language-processing programs but for any
program that consumes complex forms of textual data representation.  Then they
use the tools of compiler construction to <span class="emph">generate</span> readers and parsers
and probably never look at the actual code.</p><p><span style="font-weight: bold">Exercises</span> The following exercises aim to deepen your understanding of
JSON reading in your chosen language <span class="refelem"><span class="refcolumn"><span class="refcontent">When using this book for such
exercises in a course, we have found it useful to impose restrictions on JSON
inputs. See <a href="../Notes/note_2-json.html" data-pltdoc="x">JSON: Simplicity and Complexity</a> for details.</span></span></span> and, more importantly, of parsing
as explained above. Exercises in subsequent chapters build on solutions to some
of these exercises.</p><p><a name="(counter._(exercise._ex~3aparse-arith1))"></a><span style="font-weight: bold">Exercise</span>&nbsp;8. Implement a program that reads and parses the
language of Arithmetic in your chosen programming language.</p><p>Add subtraction and division to the language of Arithmetic and modify your
solution to accommodate those. <a href="#%28counter._%28exercise._ex~3aparse-arith1%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3aparse-arith1-sexpr))"></a><span style="font-weight: bold">Exercise</span>&nbsp;9. Abstract syntax truly hides the irrelevant
parts of concrete, textual syntax</p><p><div class="SIntrapara">Consider this alternative text grammar for our simple language of Arithmetic:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A S-expression representation of nested arithmetic expressions uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- numbers as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- S-expressions of the form [+ X Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are S-expression representations of arithmetic expressions.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- S-expression representations of the form [* X Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are S-expression representations of arithmetic expressions.</span></p></td></tr></table></div></p><p>Implement a program that reads and parses the S-expression syntax of Arithmetic
in your chosen programming language. The program should use the <span class="emph">same</span> AST
representation as the one you implemented for <a href="#%28counter._%28exercise._ex~3aparse-arith1%29%29" data-pltdoc="x">exercise&nbsp;8</a>.</p><p>The <a href="https://rosettacode.org/wiki/S-Expressions">Rosetta Code</a> repository has readers for S-expressions for a
large variety of programming languages. <a href="#%28counter._%28exercise._ex~3aparse-arith1-sexpr%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3aparse-arith2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;10. Programming languages come with more than
arithmetic for numbers. They typically also include an arithmetic of booleans,
characters, strings, and other values.</p><p><div class="SIntrapara">Here is a JSON language of String Arithmetic:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of String Arithmetic uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- strings as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "append", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representation of String Arithmetic.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "substring", N, M]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X is a JSON representation of String Arithmetic</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">and N and M are natural numbers (non-negative integers).</span></p></td></tr></table></div><div class="SIntrapara">Design an AST representation for this grammar. Then implement a program that reads
JSON and parses the language of String Arithmetic in your chosen programming
language. <a href="#%28counter._%28exercise._ex~3aparse-arith2%29%29" class="ex-end" data-pltdoc="x"></a></div></p><p><a name="(counter._(exercise._ex~3aparse-arith3))"></a><span style="font-weight: bold">Exercise</span>&nbsp;11. Having fixed numbers to specify a substring
operation is limiting. Real programming languages permit expressions in such
positions that <span class="emph">evaluate</span> to numbers.</p><p><div class="SIntrapara">The following grammar accommodates this mixed form of arithmetic:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of Number Arithmetic uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- numbers as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representation of Number Arithmetic.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "*", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representation of Number Arithmetic.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of String Arithmetic uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- strings as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "append", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representation of String Arithmetic.</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "substring", N, M]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X is a JSON representation of String Arithmetic</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">and N and M are JSON representations of Number Arithmetic.</span></p></td></tr></table></div><div class="SIntrapara">Design an AST representation for this grammar. Then implement a program that
reads JSON and parses the language of String Arithmetic in your chosen
programming language.</div></p><p>The grammar consists two <span style="font-style: italic">productions</span>: one for Number Arithmetic and
one for String Arithmetic. Furthermore, the second one refers to the first.
This arrangement implies that your program needs <span class="emph">two</span> parsing functions:
one for the Number Arithmetic and one for the String Arithmetic
production. Because of the reference from the second to the first production,
the second parser must refer to the first in the corresponding
position. Finally, the specification says that the program is to find a
String Arithmetic program, so the second parser is the primary one from this
perspective.</p><p><span style="font-weight: bold">Hint</span> Remember that a parser program merely constructs an AST. It thus
cannot check whether the numeric expressions in the <span class="stt">"substring"</span> operation
denote natural numbers.</p><p><span style="font-weight: bold">Note</span> This arrangement is artificial. A programming-language grammar
usually does not separate productions for Strings and Numbers in this way. The
point of the exercise is to deepen your understanding of parsing programs and
how mutual recursion works. <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.2<tt>&nbsp;</tt><a name="(part._sec~3ainterpreter)"></a>An Interpreter for Arithmetic</h4><p>To a student in a mathematics course&#8212;<wbr></wbr>be that in grade school or college&#8212;<wbr></wbr>the
<span class="emph">meaning</span> of our arithmetic expression is obvious. It is the number that
results from performing the desired calculations.</p><p><div class="SIntrapara">Let&rsquo;s state this idea as precisely as we can, with code. If the meaning of one
of our Arithmetic programs is just the number, we can easily write a program
that determines this meaning.  Roughly speaking, this program is like
<span class="RktSym">sum</span> from <a href="part_prologue.html" data-pltdoc="x">Prologue</a>.  It consumes an <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>
and produces a number as follows: </div><div class="SIntrapara"><ul><li><p>the value of a number is the number itself;</p></li><li><p>the value of an <span class="RktSym">add</span> is the addition of the values of the two
operands; and</p></li><li><p>the value of an <span class="RktSym">mul</span> is the multiplication  of the values of the
two operands.</p></li></ul></div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">--&gt; Number</span></p></td></tr><tr><td><p><span class="stt">def interpreter(ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">number</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; return ast</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">add[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; return </span><span class="RktPn">interpreter[l]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">+ </span><span class="RktPn">interpreter[r]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">mul[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; return </span><span class="RktPn">interpreter[l]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">* </span><span class="RktPn">interpreter[r]</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3ainterpreter-arith))" x-target-lift="Figure"></a>Figure&nbsp;10: </span>An interpreter for the Arithmetic language</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3ainterpreter-arith%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">10</span></a> turns this reasoning into a code sketch. The
three conditional lines correspond to the three listed cases. In the second and
third case, the code sketch uses a pattern notation that says <span class="stt">ast</span> is a
structure of type <span class="RktSym">add</span> or <span class="RktSym">mul</span>, respectively, and the values in
the two fields are named <span class="RktSym">l</span> and <span class="RktSym">r</span> for the rest of the case. To
the right of the arrow, then, the calls to <span class="RktSym">interpreter</span> recur on the two
field values, respectively. And the values are combined with the appropriate
operators.</p><p>Anyone with a modicum of programming experiences knows, however, that computers
usually don&rsquo;t calculate like human mathematics students. People with some more
experience than a beginner have also encountered differences among different
programming languages.</p><p>Partly, these differences are due to hardware. Most programming languages use
the underlying hardware to interpret Integers and Reals. So, for example, the
Integers available for computations have to fit into a 63 bit word, which may
cause the addition of two positive numbers to yield a negative
one. Mathematicians know how to cope with this problem easily, and good
programmers watch out for them.  When it comes to Reals. hardware is a truly
impoverished medium. It is plain impossible to represent many Reals in hardware,
and we cannot describe these gaps easily as in the case of Integers. As a
result, computing with Reals injects incredibly difficult to predict
imprecision.<span class="refelem"><span class="refcolumn"><span class="refcontent">For an accessible introduction&#8212;<wbr></wbr>using Racket&#8212;<wbr></wbr>read
<a href="Https://jeapostrophe.github.io/home/static/tm-cise2014.pdf"><span style="font-style: italic">Practically Accurate Floating-Point Math</span></a>, an article
on error analysis by Neil Toronto and Jay McCarthy. It is also fun to watch
<a href="https://www.youtube.com/watch?v=HmtgHVwja4k"><span style="font-style: italic">Debugging Floating-Point Math in Racket</span></a>, Neil
Toronto&rsquo;s RacketCon 2011 lecture, available on YouTube.</span></span></span>  Old programmers can
also tell tales of calculating with 8 bits, 16 bits, and 32 bits&#8212;<wbr></wbr>where
imprecision was even worse than with our current 64 bits per word.</p><p>Partly, these differences are due to choices that language designers make. Some
languages offer a rather limited choice of numbers. JavaScript (especially early
variants) come to mind. Others attempt to facilitate mathematical computations
with expressive number representations, going from small byte-sized numbers over
exact Rationals to Complex numbers (and beyond). The Scheme programming language
is a representative of this family, and Racket inherits its number system. In
this world, a programmer has always been able to write down arbitrarily large
Integer constants and arbitrarily precise Rational fractions. Computations with
such numbers is also one-hundred percent correct. Moving from computations with
small hardware-style Integers to very large ones or fractions is invisible to
the programmer. And that is also the problem. In this world, a programmer
typically does not pay attention to the cost of numerical computations&#8212;<wbr></wbr>but
representing numbers in software is much more expensive than representing them
with hardware.</p><p><div class="SIntrapara">In sum, the language of Arithmetic isn&rsquo;t as simple as it looks.<span class="refelem"><span class="refcolumn"><span class="refcontent">A
programming language researcher speaks of <span style="font-style: italic">meta-interpreters</span> when an
interpreter of a language just uses the means of the <span class="emph">implementation</span>
language to interpret the features of the <span class="emph">implemented</span> language.  Reynolds
wrote a scathing critique of this approach in 1972 that is still worth reading.</span></span></span>
The interpreter of <a href="#%28counter._%28figure._fig~3ainterpreter-arith%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">10</span></a> simply interprets addition and
interpretation with the operations that <span class="emph">your chosen programming language</span>
provides. But this choice is in all likelihood inappropriate. Even for our
limited version&#8212;<wbr></wbr>with just addition and multiplication&#8212;<wbr></wbr>writing an interpreter
demands an alternative approach:
</div><div class="SIntrapara"><ul><li><p>If we&#8212;<wbr></wbr>as scientists&#8212;<wbr></wbr>wish to understand the language of Arithmetic of
an existing programming language <span style="font-style: italic">L</span>, the interpreter must implement an
addition and a multiplication algorithm that simulates the one of <span style="font-style: italic">L</span>.</p></li><li><p>If we&#8212;<wbr></wbr>as engineers&#8212;<wbr></wbr>wish to design the language of Arithmetic of our
amazing new language <span style="font-style: italic">M</span>, the interpreter must use an addition and a
multiplication algorithm that explains exactly how programs will be able to
manipulate numbers.</p></li></ul></div><div class="SIntrapara">For both cases, it is also necessary to discuss whether a number really just
denotes itself or whether it needs to be injected into the chosen numeric
representation. The reader and the parser will implement restrictions on literal
numeric constants so this is not a concern of interpretation.</div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">--&gt; Number</span></p></td></tr><tr><td><p><span class="stt">def interpreter(ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">number</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; return </span><span class="RktPn">represent[ast]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">add[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; return </span><span class="RktPn">addition[interpreter[l],interpreter[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">mul[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; return </span><span class="RktPn">multiplication[interpreter[l],interpreter[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// Number -&gt; (Meta)Number</span></p></td></tr><tr><td><p><span class="stt">// inject a numeric literal constant into the chosen number type</span></p></td></tr><tr><td><p><span class="stt">def represent(x)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// Number x Number --&gt; Number</span></p></td></tr><tr><td><p><span class="stt">// implement addition for the language we wish to </span><span class="emph">understand</span><span class="stt">/</span><span class="emph">design</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">def addition(n, m)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">// Number x Number --&gt; Number</span></p></td></tr><tr><td><p><span class="stt">// implement the multiplication we wish to </span><span class="emph">understand</span><span class="stt">/</span><span class="emph">design</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">def multiplication(n, m)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3ainterpreter-arith-2))" x-target-lift="Figure"></a>Figure&nbsp;11: </span>An intepreter for the Arithmetic language</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3ainterpreter-arith-2%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">11</span></a> shows a code sketch that reflects these
considerations. It introduces three auxiliary&#8212;<wbr></wbr>unimplemented&#8212;<wbr></wbr>functions that
deal with three highlighted issues: <span class="RktSym">represent</span>, <span class="RktSym">addition</span>, and
<span class="RktSym">multiplication</span>.</p><p><span style="font-weight: bold">Exercises</span> The goal of the following exercises is to implement complete
interpreters and to understand the issues involved in your chosen language.</p><p><a name="(counter._(exercise._fig~3ainterpreter-arith))"></a><span style="font-weight: bold">Exercise</span>&nbsp;12. Implement the interpreter in
<a href="#%28counter._%28figure._fig~3ainterpreter-arith-2%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">11</span></a> in your chosen programming language. The
calculations must realize precise Integer computations. <span style="font-weight: bold">Hint</span> Every
contemporary programming language comes with a &ldquo;big number&rdquo; package.</p><p>When you have implemented the interpreter, including a unit test suite,
integrate it with the program of <a href="#%28counter._%28exercise._ex~3aparse-arith1%29%29" data-pltdoc="x">exercise&nbsp;8</a>. <a href="#%28counter._%28exercise._fig~3ainterpreter-arith%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._fig~3ainterpreter-string-arith))"></a><span style="font-weight: bold">Exercise</span>&nbsp;13. Implement an interpreter for the
language of String Arithmetic introduced in <a href="#%28counter._%28exercise._ex~3aparse-arith2%29%29" data-pltdoc="x">exercise&nbsp;10</a>.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case.</p><p>When you have implemented the interpreter, including a unit test suite,
integrate it with the program of <a href="#%28counter._%28exercise._ex~3aparse-arith2%29%29" data-pltdoc="x">exercise&nbsp;10</a>. <a href="#%28counter._%28exercise._fig~3ainterpreter-string-arith%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._fig~3ainterpreter-mix-arith))"></a><span style="font-weight: bold">Exercise</span>&nbsp;14. Implement an interpreter for the language
of Mixed String and Number Arithmetic introduced in <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" data-pltdoc="x">exercise&nbsp;11</a>.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case.</p><p>Because the description of abstract syntax comprises two productions, your
interpreter must consist of two functions. Each production takes care of three
kinds of abstract syntax. The two will also be in the same mutual relationship
as the data descriptions of the abstract syntax.</p><p>When you have implemented the interpreter, including a unit test suite,
integrate it with the program of <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" data-pltdoc="x">exercise&nbsp;11</a>. <a href="#%28counter._%28exercise._fig~3ainterpreter-mix-arith%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.3<tt>&nbsp;</tt><a name="(part._sec~3astepper-1)"></a>A State Machine for Arithmetic: Non-Determinism</h4><p>When a good teacher asks students to figure out the value of some arithmetic
expression, it often comes with the admonition &ldquo;show all the steps,&rdquo; which
prepares students for algebra and upper class students. So, look at this
Arithmetic program: <span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span>.</p><p><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">If you have used the stepper of the Beginning Student
Language in DrRacket, you may already have seen a mechanical way of
performing these kinds of calculations.</span></span></span>  Evaluating this expression
in a step by step fashion may look like one of these calculations:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[4,add[1,mul[3,2]]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[4,add[1,6]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[4,7]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktVal">11</span></td></tr></table></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[mul[2,2],add[1,6]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[4,add[1,6]]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">add[4,7]</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktVal">11</span></td></tr></table></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">While the results are the same as they should be, the procedures differ.
Indeed, there are many ways to arrive at the result, and the graph in
<a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a> shows them all:</div></p><p>Stop!  Circle the sub-expression that the various students evaluated at each
line. This will drive home how the evaluations differ.</p><p>Stop again and note how these calculations have been expressed with
<span class="emph">abstract syntax</span>. From here on, the book uses concrete JSON syntax only
for exercises.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_6.png" alt="image" width="492.26171875" height="296.6640625"/></p></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3ahomework))" x-target-lift="Figure"></a>Figure&nbsp;12: </span>An Arithmetic expression and the possible ways of arriving at an answer</span></p></blockquote><p><div class="SIntrapara">A step-by-step calculation is an execution of an Arithmetic program on
an abstract state machine. The set of <span style="font-style: italic">states</span> consists of all
expressions in the language of Arithmetic. Every expression is also an
<span style="font-style: italic">initial</span> state. Numbers make up the set of <span style="font-style: italic">final</span>
states. The transition between states is easily described with this
rule:
</div><div class="SIntrapara"><blockquote><p>Traverse the abstract syntax tree with the goal of finding an <span class="RktSym">add</span> or a
<span class="RktSym">mul</span> node whose two fields contain just numbers. Perform the calculation
and replace the node with the result.</p></blockquote></div><div class="SIntrapara">The key to observe is that this transition function consumes an AST and produces
one. The two differ in just one place.</div></p><p><a href="#%28counter._%28figure._fig~3astepper-arith%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">13</span></a> sketches how to turn this English definition into
code. It is a surprisingly large function, given the short paragraph. Part of
the length is due to plain coding; unlike English, code must show several ideas
explicitly: how the tree is traversed, how a numeric sub-tree is reduced to a
number, how the tree is reconstructed, and some more details. Also, take a close
look at the &ldquo;randomly choose&rdquo; instruction, which occurs in both the case for
<span class="RktSym">add</span> and <span class="RktSym">mul</span>. This implements the short phrase &ldquo;with the goal
of finding ...&rdquo; when the choice is ambiguous.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">// </span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">--&gt; </span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt"></span></p></td></tr><tr><td><p><span class="stt">def transition(ast)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case ast is a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">add[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; if (both </span><span class="RktSym">l</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">and </span><span class="RktSym">r</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">are numbers)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktSym">l</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">r</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else if (</span><span class="RktSym">l</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a number)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">add[l,transition[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else if (</span><span class="RktSym">r</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a number)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">add[transition[l],r]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">randomly choose one of the following:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-- </span><span class="RktPn">add[l,transition[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-- </span><span class="RktPn">add[transition[l],r]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">mul[l,r]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-&gt; if (both </span><span class="RktSym">l</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">and </span><span class="RktSym">r</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">are numbers)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktSym">l</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">r</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else if (</span><span class="RktSym">l</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a number)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">mul[l,transition[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else if (</span><span class="RktSym">r</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is a number)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return </span><span class="RktPn">mul[transition[l],r]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">randomly choose one of the following:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-- </span><span class="RktPn">mul[l,transition[r]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-- </span><span class="RktPn">mul[transition[l],r]</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3astepper-arith))" x-target-lift="Figure"></a>Figure&nbsp;13: </span>A transition function for an abstract state machine for Arithmetic</span></p></blockquote><p><a name="(counter._(exercise._ex~3aasm-arith))"></a><span style="font-weight: bold">Exercise</span>&nbsp;15. Implement this transition function for the language of
Arithmetic in your chosen programming language. The function does not pursue all
possible possibilities but randomly chooses an alternative if there are several.</p><p>When you have implemented the transition function, including a unit test suite,
design the <span class="RktSym">driver</span> function from your solution of <a href="part_prologue.html#%28counter._%28exercise._ex~3afsm%29%29" data-pltdoc="x">exercise&nbsp;1</a> to
create a complete implementation of the abstract state machine for Arithmetic.</p><p><span style="font-weight: bold">Suggestion</span> You may wish to add an instruction to the driver to display
states in the style of the calculations from above. Different runs may give you
different calculations due to the random choice. <a href="#%28counter._%28exercise._ex~3aasm-arith%29%29" class="ex-end" data-pltdoc="x"></a></p><p>Mathematics offers superior tools for writing down transition functions.  It
overlaps with computer science in that it views transitions as operating on
trees and sub-trees. Consider <a href="#%28counter._%28figure._fig~3aredexes%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a>, which illustrates this
point of view with two tree renderings of the expression at the top of
<a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a>.  The highlighting points out the sub-trees&#8212;<wbr></wbr>and thus
sub-expressions&#8212;<wbr></wbr>that consist of just an operation and two
numbers. Mathematical programming language researchers call these pieces
<span style="font-style: italic">reducible expressions</span>, or <span style="font-style: italic">redexes</span> for short.  Here the word
&ldquo;reduce&rdquo; means &ldquo;simplify to a number; the noun is &ldquo;reduction.&rdquo;</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_7.png" alt="image" width="539.587890625" height="217.53125"/></p></blockquote></div><div class="SIntrapara"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_8.png" alt="image" width="539.587890625" height="217.53125"/></p></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aredexes))" x-target-lift="Figure"></a>Figure&nbsp;14: </span>The reducible expressions in the AST of <a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a></span></p></blockquote><p>For a programming language researcher, a reduction transition is tree
surgery. The first step is to find sub-trees such as those highlighted in
<a href="#%28counter._%28figure._fig~3aredexes%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a>. The second step is to prune such a redex sub-tree,
that is, remove it. This step leaves us with a tree that has a hole. The last
step is to fill the hole with the result of performing the specified
calculation.</p><p><a href="#%28counter._%28figure._fig~3acontexts%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">15</span></a> shows the result of the second step: the trees of
<a href="#%28counter._%28figure._fig~3aredexes%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a> with holes. In this figure, the holes have the same
size as the sub-tree. The arrow that points to the hole has a larger head than
the others to point out that this hole is where an expression of Arithmetic can
be placed.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_9.png" alt="image" width="539.587890625" height="217.53125"/></p></blockquote></div><div class="SIntrapara"><blockquote><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_10.png" alt="image" width="539.587890625" height="217.53125"/></p></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3acontexts))" x-target-lift="Figure"></a>Figure&nbsp;15: </span>The contexts of redexes in the AST of <a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a></span></p></blockquote><p><div class="SIntrapara">Mathematics introduced a concise textual notation for this tree surgery, and
programming languages has used it for several decades. The key idea is to
explicitly define contexts as expressions with holes:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._arithmetic._c)"></a><span style="font-style: italic">AST-arithmetic-C</span><span class="stt">:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><a name="(tech._c)"></a><span style="font-style: italic">C</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">The first alternative, <span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>, represents the hole of the context.</div></p><p>Stop! Clarify in your mind how this shorthand translates into a
conventional data description that starts with &ldquo;X is one of.&rdquo;</p><p>Stop again! Convince yourself that every context contains exactly one hole.</p><p>Why are the examples from <a href="#%28counter._%28figure._fig~3acontexts%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a> contexts according
to this grammar?</p><p><div class="SIntrapara">Here are the two trees of <a href="#%28counter._%28figure._fig~3acontexts%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a> expressed as contexts:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">the tree at the top:</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span style="font-style: italic">topC</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= </span><span class="RktPn">add[mul[2,2],add[1,{--}]]</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">the tree at the bottom: </span><span style="font-style: italic">botC</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= </span><span class="RktPn">add[{--},add[1,mul[3,2]]]</span></p></td></tr></table></div><div class="SIntrapara">Use these examples to inspect the correspondence between the textual and the
tree-based notation of contexts.</div></p><p><div class="SIntrapara">To express that a context is filled with an Arithmetic expression, say <span class="stt">a</span>,
people use the notation <span class="stt">C[a]</span>. Thus, filling the top context with <span class="RktPn">mul[3,2]</span>, like this,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">topC</span><span class="stt">[ </span><span class="RktPn">mul[3,2]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">or filling the bottom context with <span class="RktPn">mul[2,2]</span> like this,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">botC</span><span class="stt">[ </span><span class="RktPn">mul[2,2]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">reconstructs the original expression from <a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a>. And best of
all, filling these two contexts with numbers yields the next step in the
transition sequence:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">topC</span><span class="stt">[ </span><span class="RktVal">6</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span style="font-style: italic">botC</span><span class="stt">[ </span><span class="RktVal">4</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">At this point, you can probably guess how this mathematical notation can be used
to write a concise and unambiguous specification of the transition function.</div></p><p><div class="SIntrapara">The following table is a complete definition for the transition function that
powers the abstract state machine for Arithmetic: <span class="refelem"><span class="refcolumn"><span class="refcontent">This
specification ignores that mathematical addition is perhaps not desired for the
language of interest. The discussion of this issue in <a href="#%28part._sec~3ainterpreter%29" data-pltdoc="x">An Interpreter for Arithmetic</a>
suffices.</span></span></span>
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">current state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">next state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>[<span class="RktPn">add[k,l]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>[<span class="RktSym">n</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr><tr><td valign="top" class="rule"><p><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>[<span class="RktPn">mul[k,l]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>[<span class="RktSym">n</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Each row corresponds to one possible transition. The first row, for example,
says that if the current machine state&#8212;<wbr></wbr>which is an expression of our
Arithmetic language&#8212;<wbr></wbr>is equal to some context filled with an <span class="RktSym">add</span>
redex, then the next state is the result of filling the same context with the
result of adding the two numbers. The second row can be explained in an
analogous manner.</div></p><p>At this point, you may wonder how this concise table can make the random choices
of the code in <a href="#%28counter._%28figure._fig~3astepper-arith%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">13</span></a>. The random choice is built into
the definition of <a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>, which for every structure (<span class="RktSym">add</span>,
<span class="RktSym">mul</span>), permits looking for a redex in the left or the right field.</p><p><div class="SIntrapara">Let&rsquo;s look at two traces of this abstract machine. Here is the one that
corresponds to the solution to the left of the evaluation at the beginning of
this section:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">redex</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic"><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a></span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[2,2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},add[1,mul[3,2]]]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[4,add[1,mul[3,2]]]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[3,2]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,add[1,{--}]]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[4,add[1,6]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[1,6]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[4,{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[4,7]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,7]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">11</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>final state</p></td></tr></table></blockquote></div><div class="SIntrapara">The first column shows the state of the machine. The machine&rsquo;s first step is to
split the state into a redex and a context, which are shown in the second and
third column, respectively. Conversely, filling the context in the third column
with the redex in the second produces the state. Once it has a redex, the machine
reduces it to a number and plugs the value back into the context, which
constructs the next machine state.</div></p><p><a name="(counter._(exercise._ex~3atrace-asm-arith))"></a><span style="font-weight: bold">Exercise</span>&nbsp;16. Manually check this last claim. &ldquo;Execute&rdquo; the
instruction in the first column. Then fill the hole of <a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a> with the value.
Compare the resulting expression with the state in the row below. <a href="#%28counter._%28exercise._ex~3atrace-asm-arith%29%29" class="ex-end" data-pltdoc="x"></a></p><p><div class="SIntrapara">The solution on the right side (next to <a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a>) uses a
different way of splitting the state of the machine into a context and a
redex:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">redex</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic"><a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a></span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[3,2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[mul[2,2],add[1,{--}]]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[mul[2,2],add[1,6]]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">mul[3,2]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},add[1,6]]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[4,add[1,6]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[1,6]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[4,{--}]</span></p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[4,7]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,7]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">11</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>final state</p></td></tr></table></blockquote></div><div class="SIntrapara">Again, make sure to understand how this trace of states comes about.</div></p><p>When a state machine may randomly choose from several possible transitions,
computer scientists speak of a <span style="font-style: italic">non-deterministic machine</span>. For such
machines, we tend to figure out all possible traces for a given program. Even
though the machine may construct several different ways to get the final answer,
this one arrives at the same final answer&#8212;<wbr></wbr>which isn&rsquo;t a surprise, because we
know that arithmetic problems always don&rsquo;t produce distinct answers.</p><p><a name="(counter._(exercise._ex~3atrace-asm-arith2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;17. Re-do <a href="#%28counter._%28exercise._ex~3atrace-asm-arith%29%29" data-pltdoc="x">exercise&nbsp;16</a> for this second
trace. Check that every <a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a> can be constructed with the grammar of contexts. <a href="#%28counter._%28exercise._ex~3atrace-asm-arith2%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.4<tt>&nbsp;</tt><a name="(part._step2._sec~3astepper-2)"></a>A State Machine for Arithmetic: Determinism</h4><p>While a non-deterministic state machine may simulate the students in a class, it
does not act like hardware from the perspective of a programmer.
<span class="refelem"><span class="refcolumn"><span class="refcontent">Modern hardware doesn&rsquo;t act quite like this; we ignore this point
here.</span></span></span> To them, a computer picks the next instruction to execute according to a
fixed algorithm.  The most common algorithm is to pick the leftmost redex in the
current state of the machine. A reasonably clear alternative is to pick the
rightmost one. Either way we get a <span class="emph">deterministic state machine</span>.</p><p><div class="SIntrapara">A small tweak to the definition of contexts turns the non-deterministic state
machine into a deterministic one. The key idea is to restrict where a hole may
show up in an expression:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._step2._ev)"></a><span style="font-style: italic">Ev</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[Number,</span><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[Number,</span><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">These contexts are referred to as <span style="font-style: italic">evaluation contexts</span> because they
mimic a deterministic machine evaluation.</div></p><p>In contrast to the ordinary context <a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a>, an evaluation context <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> may
cannot have a hole to the right of an arbitrary expression. A hole may only show
up in a place where all pieces of the immediate left are numbers. This point is
a translation of the third and fifth alternative into English. By implication,
the left side of the path to a hole has always been reduced to a number.</p><p>Let&rsquo;s illustrate the difference with a concrete example. Take a look back at
<a href="#%28counter._%28figure._fig~3acontexts%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>. If you follow the path from the root of the context
to hole, you see that the context at the top bypasses <span class="RktPn">mul[2,2]</span>,
which is in the left field of the top-most <span class="RktSym">add</span> node. Hence this context
is in <a href="#%28tech._c%29" class="techoutside" data-pltdoc="x"><span class="techinside">C</span></a> but not in <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>. By contrast, the context at the bottom
<span class="emph">is</span> an evaluation context <span class="RktSym">E</span>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">current state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">next state</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>[<span class="RktPn">add[k,l]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>[<span class="RktSym">n</span> ]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr><tr><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>[<span class="RktPn">mul[k,l]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>[<span class="RktSym">n</span> ]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktSym">k</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">l</span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._step2._(figure._fig~3aarith-c))" x-target-lift="Figure"></a>Figure&nbsp;16: </span>The deterministic transition function for Arithmetic</span></p></blockquote><p><div class="SIntrapara">With this simple change to the set of contexts, it is straightforward to specify
a deterministic abstract state machine for Arithmetic. <a href="#%28counter._step2._%28figure._fig~3aarith-c%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">16</span></a>
displace the two riles. Its table implies the following four-clause description:
</div><div class="SIntrapara"><ul><li><p>all <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> are <span style="font-weight: bold">states</span>;</p></li><li><p>all <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> are <span style="font-weight: bold">initial states</span>;</p></li><li><p>all plain numbers are <span style="font-weight: bold">final states</span>; and</p></li><li><p>determining the result in <span class="emph">the leftmost</span> redex the only kind of
<span style="font-weight: bold">transition</span> between two states.</p></li></ul></div><div class="SIntrapara">Stop! Explain these four points based on the table.</div></p><p><span style="font-weight: bold">Exercises</span> The point of the following exercises is to implement the state
machines and to get a sense of what programming language calls &ldquo;operational
meaning&rdquo; of expressions and programs. While the first exercise is about numeric
Arithmetic, computer science calculates with more than numbers, and the
exercises make this point, too.</p><p><a name="(counter._step2._(exercise._ex~3atrace-asm-arith3))"></a><span style="font-weight: bold">Exercise</span>&nbsp;18. Take a last look at <a href="#%28counter._%28figure._fig~3ahomework%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">12</span></a>.
Use a red pen to mark <span class="emph">the</span> path that the deterministic state machine
takes through this graph. <a href="#%28counter._step2._%28exercise._ex~3atrace-asm-arith3%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._step2._(exercise._ex~3aasm-arith-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;19. Implement the <span class="emph">deterministic</span> transition
function for the language of Arithmetic in your chosen programming language.</p><p>When you have implemented the transition function, including a unit test suite,
design the <span class="RktSym">driver</span> function from your solution of <a href="part_prologue.html#%28counter._%28exercise._ex~3afsm%29%29" data-pltdoc="x">exercise&nbsp;1</a> to
create a complete implementation of the abstract state machine for Arithmetic.</p><p><span style="font-weight: bold">Suggestion</span> You may wish to add an instruction to the driver to display
states in the style of the calculations from above. <a href="#%28counter._step2._%28exercise._ex~3aasm-arith-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._step2._(exercise._ex~3aasm-string-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;20. Recall the abstract syntax
representation for the language of String arithmetic in
<a href="#%28counter._%28exercise._ex~3aparse-arith2%29%29" data-pltdoc="x">exercise&nbsp;10</a>. Then derive a grammar for its evaluation
contexts and use it to implement the deterministic transition function
for this language of String arithmetic.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case. <a href="#%28counter._step2._%28exercise._ex~3aasm-string-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._step2._(exercise._ex~3aasm-string-det-2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;21. Develop an abstract syntax representation for
the language of String arithmetic in <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" data-pltdoc="x">exercise&nbsp;11</a>. Then derive a
grammar for its evaluation contexts and use it to implement the deterministic
transition function for this language of String arithmetic.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case. <a href="#%28counter._step2._%28exercise._ex~3aasm-string-det-2%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.5<tt>&nbsp;</tt><a name="(part._sec~3astack)"></a>A Stack Machine for Arithmetic</h4><p>Like students, the abstract state machine works in mysterious ways. It finds the
exact right split between redex and context in one fell swoop. It computes. It
fills the context with the resulting number, and then the whole process starts
over. This process may work well for small expressions in Arithmetic, but for
large programs, finding the split between a redex and an evaluation context is
work.</p><p>To understand what this work is, it is necessary to separate the state into two
parts: the evaluation context that the machine has discovered thus far and the
&ldquo;code&rdquo; that fills the context. By filling the context with this code, we get
the actual state of the abstract machine. Once the two pieces are pulled apart,
we can explain in a step-by-step fashion how the machine shifts parts of the
expression from the code to the context.</p><p>Instead of immediately looking at the machine, let&rsquo;s start with the running
example and a slow-paced trace that explicates the incremental search for the
redex:</p><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">evaluation context</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">comment</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[mul[2,2],add[1,mul[3,2]]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>look left</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">mul[2,2]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[{--},add[1,mul[3,2]]]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>compute</p></td></tr><tr><td valign="top"><p><span class="RktVal">4</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[{--},add[1,mul[3,2]]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>return</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktPn">add[1,mul[3,2]]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,{--}]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>look right</p></td></tr><tr><td valign="top"><p><span class="RktPn">mul[3,2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[4,add[1,{--}]]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>compute </p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">6</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,add[1,{--}]]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>return</p></td></tr><tr><td valign="top"><p><span class="RktPn">add[1,6]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[4,{--}]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>compute</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">7</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p><span class="RktPn">add[4,{--}]</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace"><p>return</p></td></tr><tr><td valign="top"><p><span class="RktPn">add[4,7]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>compute</p></td></tr><tr><td valign="top" class="trace"><p><span class="RktVal">11</span></p></td><td valign="top" class="trace"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="trace" colspan="3"><p>done</p></td></tr></table></blockquote><p>As stated, the configuration consists of two pieces, dubbed <span style="font-style: italic">control
code</span> and evaluation context. Initially the code is the entire expression, and
the context is empty. By definition of the evaluation context <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>, the
machine must first look at the left field of the top-most node, assuming it is
not in a final state. Here the left field is <span class="emph">not</span> a number, so the hole of
the evaluation context must be there. While the machine may thus focus on
<span class="RktPn">mul[2,2]</span>, it can shift node itself plus the right field to the
evaluation context; technically it fills the existing evaluation context&#8212;<wbr></wbr>which
is just a hole&#8212;<wbr></wbr>with a small evaluation context: <span class="RktPn">add[{--},add[1,mul[3,2]]]</span>.</p><p>The second line presents the machine with a control code that is a redex. So, it
is time to compute. Doing so yields a state whose control code is a number. While
the machine from the preceding section would put this number into the context
and restart the process, we know that the search for the next evaluation context
would start from here anyways, with the next node up to be precise. Thus, a
number in the control code part of the state, cause the machine to look at the
surroundings of the hole in <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> and to peel off the innermost layer. Here
this layer needs an evaluation of the right field of the <span class="RktSym">add</span> node, and
thus the machine swaps the number&#8212;<wbr></wbr>placing it into <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>&rsquo;s hole&#8212;<wbr></wbr> with
the right field.</p><p>When the machine sees the control code of the third line, it may focus on the
right field of the <span class="RktSym">add</span> node, because the left one is already a number.
This shifts <span class="RktPn">add[1,{--}]</span> into <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>&rsquo;s hole.</p><p>From here the rest of the trace proceeds with steps similar to those seen
before. It ends when the control code turns into a number and the <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> part
is just a hole. Once again we get <span class="RktVal">11</span> back.</p><p>By generalizing from the example, we can get an abstract state machine that
explicitly searches for the next redex. Its states consists of two pieces: the
expression in which it is looking for a redex and its evaluation context. When
the expression is just a number, the search failed and the machine returns to
the evaluation context to search there. Technically, the return action swaps the
number and a piece of the immediate surrounds of the hole.</p><p>We use the <span style="font-weight: bold">terminology</span> <span style="font-style: italic">register</span> for each piece of state in a
machine whose state consists of several pieces. This particular two-register
machine is called CC-machine because its registers are the control-code and the
context.</p><p><div class="SIntrapara">Here is the formal description of the CC-machine:
</div><div class="SIntrapara"><ul><li><p>a <span style="font-weight: bold">state</span> consists of two registers: a control code, which is an
<a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a>, and the context, which belongs to <a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a>;</p></li><li><p>an <span style="font-weight: bold">initial state</span> has an expression in the control-code register
and <span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span> in the context register;</p></li><li><p>a <span style="font-weight: bold">final state</span> has a number in the control-code register and <span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span>
in the context register; and</p></li><li><p>the CC-machine&rsquo;s transitions are displayed in <a href="#%28counter._%28figure._fig~3aarith-cc%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a>.</p></li></ul></div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="3"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-weight: bold">next state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">evaluation context</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;" colspan="3"><p><span style="font-style: italic">evaluation context</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[nn1,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">add[nn1,{--}]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>look right</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">ae2</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">mul[nn1,{--}]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>look right</p></td></tr><tr><td valign="top"><p><span class="RktPn">add[ae1,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">add[{--},ae2]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>look left</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[ae1,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">ae1</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">mul[{--},ae2]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>look left</p></td></tr><tr><td valign="top"><p><span class="RktPn">add[nn1,nn2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">nn1</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">nn2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>compute</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,nn2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">nn1</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">nn2</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>compute</p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">add[{--},ae2]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[nn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>return</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">add[nn1,{--}]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">add[nn1,nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>return</p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">mul[{--},ae2]</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[nn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>return</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a> [<span class="RktPn">mul[nn1,{--}]</span>]</p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._step2._ev%29" class="techoutside" data-pltdoc="x"><span class="techinside">Ev</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p>return</p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p></p></td></tr><tr><td><p>&#160;</p></td></tr></table><p><span style="font-weight: bold">Legend</span> (1) <span class="RktSym">ae1</span> is an expression that is <span class="emph">not</span> a number; (2)
<span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions; and (3) <span class="stt">nn1</span>
<span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers</p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aarith-cc))" x-target-lift="Figure"></a>Figure&nbsp;17: </span>A control-code/context machine for Arithmetic</span></p></blockquote><p>The first four transition rules in <a href="#%28counter._%28figure._fig~3aarith-cc%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a> are the search
rules. For each kind of node in the AST, there is one rule for searching on the
right&#8212;<wbr></wbr>namely when the left is already a number&#8212;<wbr></wbr>and another for searching on
the left&#8212;<wbr></wbr>when the left field does not contain a number. The two compute rules
implement the calculations for redexes. When the machine finds a redex&#8212;<wbr></wbr>an AST
node whose two fields are numbers&#8212;<wbr></wbr>the result is put into the control-code
register. At that point, the machine switches to the secondary search rules,
which are labeled &ldquo;return.&rdquo; Conceptually, each of these rules places a number
into the hole of the current context and then places the node to its immediate
top into the control-code register to restart the search.  In short, the machine
either places a small context into the hole or it retrieves such a small context
from the hole.</p><p><span style="font-weight: bold">Evaluation Contexts are Stacks</span> A course on <span style="font-style: italic">Data Structures</span> uses the word
&ldquo;stack&rdquo; to describe a &ldquo;last in, first out&rdquo; policy. The context-oriented view
obscures the stack picture, and perhaps you don&rsquo;t immediately see what the items
are that the machine is pushing onto, and popping, from the stack. So let&rsquo;s take
it slowly, starting with the second aspect.</p><p><div class="SIntrapara">The example at the beginning of the section moves the following pieces from the
control code register to the evaluation context register. Here are three examples:
</div><div class="SIntrapara"><ul><li><p>step 1 fills the hole of the empty context with <span class="RktPn">add[{--},add[1,mul[3,2]]]</span>; </p></li><li><p>step 3 swaps out <span class="RktPn">add[1,mul[3,2]]</span> with <span class="RktPn">add[4,{--}]</span>;</p></li><li><p>step 4 fills the hole of the resulting context with <span class="RktPn">add[1,{--}]</span> with <span class="RktPn">add[4,{--}]</span>;</p></li></ul></div><div class="SIntrapara">In general, the pieces look like one of these four then:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._frame)"></a><span style="font-style: italic">Frame</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">,</span><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[Number,</span><span class="RktPn">{</span><span class="RktSym"><span class="nobreak">--</span></span><span class="RktPn">}</span><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">Programming languages refers to them as (stack) <a href="#%28tech._frame%29" class="techoutside" data-pltdoc="x"><span class="techinside">Frames</span></a>. The stack itself
is just a sequence of frames that a push operation grows to the right and a pop
operation shrinks from the right end:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._k)"></a><span style="font-style: italic">K</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= &#1013; | </span><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a><span class="stt">, </span><a href="#%28tech._frame%29" class="techoutside" data-pltdoc="x"><span class="techinside">Frame</span></a></p></td></tr></table></div><div class="SIntrapara">Here &#1013; indicates an &ldquo;empty sequence,&rdquo; which in this book is written as just a
blank space. A simpler, less mathematical variant of this definition would be
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-style: italic">K</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">= </span><a href="#%28tech._frame%29" class="techoutside" data-pltdoc="x"><span class="techinside">Frame</span></a><span class="stt">, ..., </span><a href="#%28tech._frame%29" class="techoutside" data-pltdoc="x"><span class="techinside">Frame</span></a></p></td></tr></table></div></p><p><div class="SIntrapara">With this bit of notation defined, we can reformulate the abstract state machine
from <a href="#%28counter._%28figure._fig~3aarith-cc%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a> in a way that is more in sync with a conventional
view of data structures in computer science:
</div><div class="SIntrapara"><ul><li><p>a <span style="font-weight: bold">state</span> consists of two registers: a control code, which is an
<a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> and represents the current focus of search, plus a stack
<a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, which represents what is left to compute when the control code has
been reduced to a value;</p></li><li><p>an <span style="font-weight: bold">initial state</span> has an expression in the control-code register
and empty stack in the context register;</p></li><li><p>a <span style="font-weight: bold">final state</span> has a number in the control-code register and an
empty stack in the context register; and</p></li><li><p>the CK-machine&rsquo;s transitions are displayed in <a href="#%28counter._%28figure._fig~3aarith-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a>.</p></li></ul></div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="3"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[nn1,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">add[nn1,{--}]</span></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">ae2</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">mul[nn1,{--}]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[ae1,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">add[{--},ae2]</span></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[ae1,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">ae1</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">mul[{--},ae2]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">add[nn1,nn2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">nn1</span><span class="stt"> </span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">nn2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,nn2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">nn1</span><span class="stt"> </span><span class="RktSym">*</span><span class="stt"> </span><span class="RktSym">nn2</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">add[{--},ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">add[nn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">add[nn1,{--}]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">add[nn1,nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">mul[{--},ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">mul[nn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">mul[nn1,{--}]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">mul[nn1,nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p></p></td></tr><tr><td><p>&#160;</p></td></tr></table><p><span style="font-weight: bold">Legend</span> (1) <span class="RktSym">ae1</span> is an expression that is <span class="emph">not</span> a number; (2)
<span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions; and (3) <span class="stt">nn1</span>
<span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers</p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aarith-ck))" x-target-lift="Figure"></a>Figure&nbsp;18: </span>A control-code/stack machine for Arithmetic</span></p></blockquote><p><span style="font-weight: bold">Exercises</span> This stack-based abstract state machine is one that you want to
implement. For a computer scientist, it feels more concrete than the &ldquo;machine
that acts like a grade-school&rdquo; student. They also get us closer to how real
programming languages organize the execution of programs, meaning we get a more
concrete sense of the meaning of programs.</p><p>While Arithmetic looks so simple that you may question why we spend so much
energy on it, these exercises also prepare you for the introduction of functions
and objects.</p><p><a name="(counter._(exercise._ex~3ack-arith-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;22. Implement the transition function from
<a href="#%28counter._%28figure._fig~3aarith-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a> for the language of Arithmetic in your chosen
programming language.</p><p>When you have implemented the transition function, including a unit test suite,
design the <span class="RktSym">driver</span> function from your solution of <a href="part_prologue.html#%28counter._%28exercise._ex~3afsm%29%29" data-pltdoc="x">exercise&nbsp;1</a> to
create a complete implementation of the abstract state machine for Arithmetic.</p><p><span style="font-weight: bold">Suggestion</span> You may wish to add an instruction to the driver to display
states in the style of the calculations from above. <a href="#%28counter._%28exercise._ex~3ack-arith-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3ack-string-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;23. Derive a stack representation for the
String arithmetic language o of <a href="#%28counter._%28exercise._ex~3aparse-arith2%29%29" data-pltdoc="x">exercise&nbsp;10</a>.  Use it to
implement the deterministic transition function for this language of
String arithmetic.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case. <a href="#%28counter._%28exercise._ex~3ack-string-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3ack-string-det-2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;24. Develop an abstract syntax representation for
the language of String arithmetic in <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" data-pltdoc="x">exercise&nbsp;11</a>. Then derive a
stack representation and use it to implement the deterministic transition
function for this language of String arithmetic.</p><p>Ignore <span class="stt">substring</span> operations whose numeric arguments make no sense
for the given string. Your interpreter should just implement the
behavior of your implementation language in this case. <a href="#%28counter._%28exercise._ex~3ack-string-det-2%29%29" class="ex-end" data-pltdoc="x"></a></p><h5>2.5.1<tt>&nbsp;</tt><a name="(part._.The_.Names_of_.Machines__.C__.C.C__.C.K)"></a>The Names of Machines: C, CC, CK</h5><p><div class="SIntrapara">When people create artifacts, they need names to discuss them efficiently:
</div><div class="SIntrapara"><ul><li><p>&ldquo;the machine that acts like a student&rdquo; is the (non-)deterministic
<span style="font-style: italic">C machine</span>;</p></li><li><p>by splitting the state into a control-code and a context register, we get
the <span style="font-style: italic">CC machine</span>; and</p></li><li><p>replacing the evaluation context with a stack yields the <span style="font-style: italic">CK
machine</span>.</p></li></ul></div><div class="SIntrapara">Yes, K is the last letter of &ldquo;stack,&rdquo; and that is why it is called CK.</div></p><h4>2.6<tt>&nbsp;</tt><a name="(part._sec~3aexceptions)"></a>Division</h4><p>You may have wondered why Arithmetic is <span class="emph">so</span> simplistic. It doesn&rsquo;t even
include subtraction and multiplication. The problem is division, because it is
not a function that always returns a result; not even mathematicians know the
result of <span style="font-style: italic"></span>1<span style="font-style: italic">/</span>0<span style="font-style: italic"></span>.</p><p>So unlike addition and multiplication, division isn&rsquo;t <span class="emph">just</span> a computing
instruction. For the former, and subtraction too, a reduction merely appeals to
mathematics (or a programming language form of mathematics) to compute the
result&#8212;<wbr></wbr>in place. By contrast, division may affect the context, because it
makes no sense to divide by <span class="RktVal">0</span>, and programming languages therefore come
with a <span style="font-style: italic">divide by zero exception</span>.</p><p><div class="SIntrapara">By transition from a the operations of a homework-solving student to a stack
machine, we can now concisely express this idea. Let&rsquo;s start with an abstract
syntax. The first piece we need are additional tree nodes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">sub</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">left</span><span class="RktRdr">,</span><span class="RktSym">right</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">div</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">left</span><span class="RktRdr">,</span><span class="RktSym">right</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">The second is an extended grammar for the abstract syntax:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a name="(tech._ast._f._arithmetic)"></a><span style="font-style: italic">AST-f-arithmetic</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">=</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">// the -f- stands for ``full''</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| add[</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| mul[</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| sub[</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| div[</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">,</span><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a><span class="stt">]</span></p></td></tr></table></div><div class="SIntrapara">Stop! Adjust the concrete JSON grammar to accommodate subtraction and division.</div></p><p><div class="SIntrapara">The final piece is an extension of the abstract machine itself. While the set of
states and initial states are the same (modulo the extended abstract syntax),
the final states and the transitions differ:
</div><div class="SIntrapara"><ul><li><p>a <span style="font-weight: bold">state</span> consists of two registers: a control code, which is an
<a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a>, and a stack <a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>;</p></li><li><p>an <span style="font-weight: bold">initial state</span> has an expression in the control-code register
and empty stack in the context register;</p></li><li><p>a <span style="font-weight: bold">final state</span> has a number in the control-code register or the
marker <span class="stt">division-by-0</span> and an empty stack in the context register; and</p></li><li><p><a href="#%28counter._%28figure._fig~3adiv-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">19</span></a> displays the machine&rsquo;s transitions for division.</p></li></ul></div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td colspan="3"><p><span style="font-weight: bold">current state</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td colspan="3"><p><span style="font-weight: bold">next state</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control code</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">control stack</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">div[nn1,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">ae2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">div[nn1,{--}]</span></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">add[ae1,ae2]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktSym">ae1</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">div[{--},ae2]</span></p></td></tr><tr><td valign="top"><p><span class="RktPn">div[nn1,nn2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">nn1</span><span class="stt"> </span><span class="RktSym">/</span><span class="stt"> </span><span class="RktSym">nn2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>if <span class="RktSym">nn2</span><span class="stt"> </span><span class="RktSym">!=</span><span class="stt"> </span><span class="RktVal">0</span>:</p></td></tr><tr><td valign="top" class="rule"><p><span class="RktPn">div[nn1,0]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="stt">division-by-0</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p></p></td></tr><tr><td valign="top"><p><span class="RktSym">nn</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">div[{--},ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktPn">div[nn,ae2]</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr><tr><td valign="top" class="rule"><p><span class="RktSym">nn</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a>, <span class="RktPn">div[nn1,{--}]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><span class="RktPn">div[nn1,nn]</span></p></td><td valign="top" class="rule"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" class="rule"><p><a href="#%28tech._k%29" class="techoutside" data-pltdoc="x"><span class="techinside">K</span></a></p></td></tr></table><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p></p></td></tr><tr><td><p>&#160;</p></td></tr></table><p><span style="font-weight: bold">Legend</span> (1) <span class="RktSym">ae1</span> is an expression that is <span class="emph">not</span> a number; (2)
<span class="RktSym">ae1</span> <span class="RktSym">ae2</span> <span class="RktSym">ae</span> stand for expressions; and (3) <span class="stt">nn1</span>
<span class="stt">nn2</span> <span class="stt">nn</span> stand for numbers</p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3adiv-ck))" x-target-lift="Figure"></a>Figure&nbsp;19: </span>A control-code/stack machine for Arithmetic with division</span></p></blockquote><p>The key observation is that the second computation rule for division not only
places a non-numeric result into the control-code register, it also leaves the
stack register empty. In principle, the CC-machine can also be equipped with
this kind of transition, though only the deterministic one. If the error message
were  to include the other argument to the division function, the
non-deterministic one may come to different results, depending on the different
random choices it may make.</p><p><span style="font-weight: bold">Exercise</span> The following exercises combine a bit of machine-design work
with implementation exercises that help you gain a precise understanding of how
the CK-machine for <a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a> deals with exceptions in a way that
is compatible with programming free of side effects. Concretely, it explains
exceptions in the language we study&#8212;<wbr></wbr><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a>&#8212;<wbr></wbr><span class="emph">without</span>
using exceptions in the implementation language. So yes, you could choose a
language that comes without exceptions and exception-handling mechanisms.</p><p><a name="(counter._(exercise._ex~3adiv-design))"></a><span style="font-weight: bold">Exercise</span>&nbsp;25. Develop the transition rules for subtraction. <a href="#%28counter._%28exercise._ex~3adiv-design%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3adiv-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;26. Implement the transition function from
<a href="#%28counter._%28figure._fig~3adiv-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">19</span></a> for <a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a> in your chosen programming
language. You need to solve <a href="#%28counter._%28exercise._ex~3adiv-design%29%29" data-pltdoc="x">exercise&nbsp;25</a> first.</p><p>When you have implemented the transition function, including a unit test suite,
design the <span class="RktSym">driver</span> function from your solution of <a href="part_prologue.html#%28counter._%28exercise._ex~3afsm%29%29" data-pltdoc="x">exercise&nbsp;1</a> to
create a complete implementation of the abstract state machine for Arithmetic. <a href="#%28counter._%28exercise._ex~3adiv-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3adiv-string-det))"></a><span style="font-weight: bold">Exercise</span>&nbsp;27. Revise the abstract state machine from
<a href="#%28counter._%28exercise._ex~3ack-string-det%29%29" data-pltdoc="x">exercise&nbsp;23</a> so it deals with bad <span class="stt">substring</span> operations via
exceptions <span class="emph">independently of your implementation language</span>. Specifically,
it raises the exception bad-substring-operation. <a href="#%28counter._%28exercise._ex~3adiv-string-det%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3adiv-string-det-2))"></a><span style="font-weight: bold">Exercise</span>&nbsp;28. Develop an abstract syntax representation for
the language of String arithmetic in <a href="#%28counter._%28exercise._ex~3aparse-arith3%29%29" data-pltdoc="x">exercise&nbsp;11</a>. Then derive a
stack representation and use it to implement the deterministic transition
function for this language of String arithmetic. <a href="#%28counter._%28exercise._ex~3adiv-string-det-2%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.7<tt>&nbsp;</tt><a name="(part._sec~3atheorems1)"></a>Theorems</h4><p>All the exercises treat the machine transition as blueprints for implementing a
physical artifact, a piece of software that moves bits on real hardware. For a
programmer, this point of view is natural. For a programming language
researcher, there is a second, equally important perspective, however. The
transitions specific mathematical relations between states.  What we need,
though, is a relation that determines the answers of complete programs.</p><p><div class="SIntrapara"><span style="font-weight: bold">Definition</span> An <span style="font-style: italic">evaluator</span> is a function that maps elements from
the set of abstract syntax trees (<span style="font-style: italic">AST</span>) to elements of the set of
answers (<span style="font-style: italic">Answer</span>):
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">evaluator : AST </span>&ndash;<span style="font-style: italic">&gt; Answer</span></p></blockquote></div></p><p>This mathematical perspective is useful because researchers wish to prove that a
language blueprint makes guarantees for <span class="emph">all</span> programs. While the tables of
transitions already just state relations, the driver looks like an ordinary
program and not at all like a mathematical function. Fortunately, one bit of
knowledge from a course on <span style="font-style: italic">Discrete Mathematics</span> suffices here:
<span style="font-style: italic">transitive-reflexive closures</span>.</p><p><div class="SIntrapara">Mathematically speaking, evaluators are the transitive-reflexive closures of the
tables of transition relations. Continuing along, a theorem in programming
languages is just like a theorem in mathematics: a statement about &ldquo;properties
&rdquo; that &ldquo;objects&rdquo; in the &ldquo;domain of interest&rdquo; posses:
</div><div class="SIntrapara"><ul><li><p>the objects are evaluators and similar functions;</p></li><li><p>the domains are elements of programming languages and their
implementations; and</p></li><li><p>the properties are stated as relationships among evalutors or between
evaluators and objects.</p></li></ul></div></p><p><div class="SIntrapara">At this point, we can define a number of evaluators and give them names:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">name</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-style: italic">domain</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;" colspan="3"><p><span style="font-style: italic">range</span></p></td></tr><tr><td valign="top"><p><a name="(tech._c._arith)"></a><span style="font-style: italic">c-arith</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._step2._%28figure._fig~3aarith-c%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">16</span></a></p></td></tr><tr><td valign="top"><p><a name="(tech._cc._arith)"></a><span style="font-style: italic">cc-arith</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._%28figure._fig~3aarith-cc%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a></p></td></tr><tr><td valign="top"><p><a name="(tech._ck._arith)"></a><span style="font-style: italic">ck-arith</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28counter._%28figure._fig~3aarith-ck%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a></p></td></tr><tr><td valign="top"><p><a name="(tech._c._arith._f)"></a><span style="font-style: italic">c-arith-f</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number, <span class="stt">division-by-0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td></tr><tr><td valign="top"><p><a name="(tech._cc._arith._f)"></a><span style="font-style: italic">cc-arith-f</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number, <span class="stt">division-by-0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td></tr><tr><td valign="top"><p><a name="(tech._ck._arith._f)"></a><span style="font-style: italic">ck-arith-f</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><a href="#%28tech._ast._f._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-f-arithmetic</span></a></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>Number, <span class="stt">division-by-0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td></tr></table></blockquote></div><div class="SIntrapara">Each of these is the transitive-reflexive closure of the transition relation
defined in the corresponding figure.</div></p><p>If you recall your discrete mathematics, though, the transitive-reflexive closure
of a relation is not necessarily a function. So the very first theorem should
affirm the nature of these relations as functions and thus as proper evaluators.</p><p><span style="font-weight: bold">Basic Theorem</span> The relations <a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a>, <a href="#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a>, and
<a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a> are mathematical functions on their specified domain and range.</p><p>Recall that a function is a relation that for a given input from the domain
produces at most one output from the range. In this particular case, the three
functions always produce exactly one result. Programming languages even has a
special name for this theorem.</p><p><span style="font-weight: bold">Strong Evaluation Theorem</span> The evaluators <a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a>, <a href="#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a>,
and <a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a> are total on their specified domain.</p><p>The final theorem illustrates a property <span class="emph">between</span> evaluators. The very
existence of several evaluators raises the question whether they produce the
same answer for all possible programs in this domain. Given that <a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a>
is based on a more concrete machinery than, say, <a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a>, programming
language researchers speak of &ldquo;correctness theorems&rdquo; in this context. They
consider <a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a> as the easy-to-comprehend&#8212;<wbr></wbr>by a grade school students
in this case&#8212;<wbr></wbr><span class="emph">specification</span> of the language&rsquo;s meaning and
<a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a> as the <span class="emph">implementation</span>&#8212;<wbr></wbr>terms you may recall from
programming courses.</p><p><div class="SIntrapara"><span style="font-weight: bold">Correctness Theorem</span> For all <a href="#%28tech._ast._arithmetic%29" class="techoutside" data-pltdoc="x"><span class="techinside">AST-arithmetic</span></a> expressions
<span class="RktSym">ae</span>,
</div><div class="SIntrapara"><blockquote><p><a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"> = </span><a href="#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"> = </span><a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a><span style="font-style: italic"></span>(<span style="font-style: italic">ae</span>)<span style="font-style: italic"> .</span></p></blockquote></div></p><p>A simpler way of stating the same property is: <a href="#%28tech._c._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith</span></a> = <a href="#%28tech._cc._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith</span></a> = <a href="#%28tech._ck._arith%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith</span></a>.</p><p>In mathematics, a theorem comes with a proof, a chain of stylized (formal)
arguments from first principles&#8212;<wbr></wbr>often called axioms&#8212;<wbr></wbr>and other theorems.
This method is also used in programming languages.</p><p>This book does <span class="emph">not</span> present proofs, because we, the authors, do not
consider proofs appropriate material for a first course on the principles of
programming languages. At the same time, the book states theorems that make
sense given the systematic construction of the functions, like for the
correctness theorem.</p><p><div class="SIntrapara">This book <span class="emph">does</span> state theorems to provide a sense of that people can state
firm mathematical truths about programming languages and what such theorems say.
Without getting into deep philosophical discussions, we say
</div><div class="SIntrapara"><blockquote><p> a theorem in programming language makes a statement
about the theoretical part of the programming language, not its physical one.</p></blockquote></div><div class="SIntrapara">For example, the correctness theorem says that the three implementations of
abstract state machines for the language of Arithmetic produce the same result
when given the same input. Then,
</div><div class="SIntrapara"><ul><li><p>if your implementation translates the transition functions correctly into code,</p></li><li><p>if the compiler for your chosen language correctly translates your code to
the hardware&rsquo;s language,</p></li><li><p>if the hardware functions according to its specification, and</p></li><li><p>if no power outages or cosmic rays or some other natural phenomenon messes
with the physics of the program,</p></li></ul></div><div class="SIntrapara">you can interchange one implementation for another.</div></p><p><a name="(counter._(exercise._ex~3asimple-theorem))"></a><span style="font-weight: bold">Exercise</span>&nbsp;29. State a theorem like the one above for
<a href="#%28tech._c._arith._f%29" class="techoutside" data-pltdoc="x"><span class="techinside">c-arith-f</span></a>, <a href="#%28tech._cc._arith._f%29" class="techoutside" data-pltdoc="x"><span class="techinside">cc-arith-f</span></a>, and <a href="#%28tech._ck._arith._f%29" class="techoutside" data-pltdoc="x"><span class="techinside">ck-arith-f</span></a>. To do so properly,
you need to make sure to construct transition tables like those for the
evaluators of the theorem. <a href="#%28counter._%28exercise._ex~3asimple-theorem%29%29" class="ex-end" data-pltdoc="x"></a></p><h4>2.8<tt>&nbsp;</tt><a name="(part._sec~3a2sum)"></a>Summary</h4><p>Who would have thought that working through the principles of Arithmetic could
teach so much about the work of programming language researchers.</p><p><div class="SIntrapara">Here are the ideas that the rest of book relies on:
</div><div class="SIntrapara"><ul><li><p>The syntax that programmers use is a matter of taste. Programming language
research does not study taste; it focuses on ideas. Hence, people use
<span style="font-weight: bold">abstract syntax</span> (trees) to hide different syntax representations of the
same idea.</p></li><li><p>Plain arithmetic, the kernel of basically every major programming
language, has a relative plain meaning: a number, a string, a boolean value, and
so on. This chapter shows that the <span style="font-weight: bold">mechanical calculations</span> learned in
grade school explain how to get the meaning of expressions. Programmers can use
this idea to think about code.</p></li><li><p>It also shows that two alternative ways of determining the meaning: (1) an
machine that stepping from one program to another in a deterministic fashion and
(2) a stack machine that separates the <span style="font-weight: bold">control code</span> from the rest of
the computation, represented as a <span style="font-weight: bold">stack</span>. The first one is good for
programmers, the second one is closer to how an actual language implementation
computes.</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Project</span> Here is a JSON syntax for an Arithmetic that mixes Booleans and Numbers:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of nested arithmetic expressions uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- Number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- "true"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- "false"</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form ["if", X, Y, Z]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "&gt;", Y]</span></p></td></tr></table></div><div class="SIntrapara">where <span class="stt">X</span>, <span class="stt">Y</span>, and <span class="stt">Z</span> are JSON representations of Boolean arithmetic
expressions.</div></p><p>Numbers stand for themselves, while <span class="stt">"true"</span> and <span class="stt">"false"</span> represent
Booleans. Addition works as always. An <span class="stt">if</span> arrays picks <span class="stt">Y</span> if <span class="stt">X</span>
evaluates to true, <span class="stt">Z</span> otherwise. The last array denotes the usual numeric
comparison.</p><p><div class="SIntrapara">Develop a program in your chosen language that reads valid JSON expressions from
standard input and prints one of three possible results to standard output:
</div><div class="SIntrapara"><ul><li><p><span class="stt">"syntax error"</span> if the JSON text is not formed according to the grammar;</p></li><li><p><span class="stt">"run-time error"</span> if the program gets stuck because of an ill-defined
redex; or</p></li><li><p>a JSON number if the syntax is correct and everything evaluates correctly.</p></li></ul></div></p><p>Develop an abstract syntax representation and document it. Also explain which
interpretation method you choose and why: interpretation, a C-machine, a
CC-machine, or a CK-machine.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ch_pl.html" title="backward to &quot;1 Programming Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_algebra.html" title="forward to &quot;3 Algebra, Your Second Programming
Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
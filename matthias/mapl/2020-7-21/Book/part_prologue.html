<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Prologue</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Machines and Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Prologue</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="ch_pl.html" class="tocviewlink" data-pltdoc="x">Programming Languages</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ch_arith.html" class="tocviewlink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="ch_algebra.html" class="tocviewlink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="ch_lambda.html" class="tocviewlink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ch_mutation.html" class="tocviewlink" data-pltdoc="x">Mutable Objects</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="ch_cc.html" class="tocviewlink" data-pltdoc="x">Full Control</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="ch_express.html" class="tocviewlink" data-pltdoc="x">The Dimensions</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="ch_space.html" class="tocviewlink" data-pltdoc="x">Space</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="ch_types.html" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="ch_futures.html" class="tocviewlink" data-pltdoc="x">Futures</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Prologue</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8.0.1</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_preface.html" title="backward to &quot;Preface&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_pl.html" title="forward to &quot;1 Programming Languages&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._part~3aprologue)"></a>Prologue</h3><a name="(part._chap~3apart~3aprologue)"></a><p>The book relies on two programming techniques. First, it explains many ideas in
programming languages with state machines and their implementations. Second, a
programming language and its pieces consist of data drawn from complicated data
types, that is, types of data whose definitions are self-referential and
mutually referential. This prologue presents this basic background.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3aabstract-machines%29" class="toclink" data-pltdoc="x">Abstract Machines</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3aimpl-am%29" class="toclink" data-pltdoc="x">Implementing Abstract Machines</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3atx-dat%29" class="toclink" data-pltdoc="x">Text versus Data</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3asys-des%29" class="toclink" data-pltdoc="x">Systematic Program Design: The Idea</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3asys-des-ex%29" class="toclink" data-pltdoc="x">Systematic Program Design: A Worked Example</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._pro~3aprogramming%29" class="toclink" data-pltdoc="x">Programmnng, Debugging Systematically</a></p></td></tr></table><h4><a name="(part._pro~3aabstract-machines)"></a>Abstract Machines</h4><p>A traffic light can be in about three major states: red, yellow, and green
(plus blinking yellow or red plus turned off). It transitions from red to
green, from green to yellow, and from yellow to read. These transitions are
triggered by the passage of time.</p><p>A soda machine also comes with two states. In the first state it is ready
to accept your selection. When you select a &ldquo;classic foobar,&rdquo; it
transitions to the second state&#8212;<wbr></wbr>waiting for your money. The transition
back to the first state takes place when you have paid the required sum or
canceled the transaction (which may happen because too much time passed).</p><p>Every state machine comes with states&#8212;<wbr></wbr>which is where the name comes
from&#8212;<wbr></wbr>and transitions from states to states. These transitions can be
triggered by various things: an input, the passage of time, the state of
the machine itself, and so on.  If the number of possible states is
finite&#8212;<wbr></wbr>like for traffic lights or soda machines&#8212;<wbr></wbr>we speak of a
<span style="font-style: italic">finite state machine</span>; otherwise we just say <span style="font-style: italic">state
machine</span>.</p><p><div class="SIntrapara">Based on the informal description, the essence of a state machine is
</div><div class="SIntrapara"><ul><li><p>the set of states a machine can be in;</p></li><li><p>the state(s) in which a machine starts&#8212;<wbr></wbr>called <span style="font-style: italic">initial state</span>(s);</p></li><li><p>the state(s) in which a machine shuts down&#8212;<wbr></wbr>called <span style="font-style: italic">final state</span>(s); and</p></li><li><p>transitions that take a machine from one state to another.</p></li></ul></div></p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">By showing red, a traffic light causes traffic to stop
and thus prevents potential accidents. It is therefore called a fail-safe
state. When machines misfunction they also tend to be engineered to go into
a fail-safe state.</span></span></span>
The soda machine, for example, goes into a &ldquo;waiting for your selection&rdquo;
state when turned on. A well-designed traffic light will go into a &ldquo;red&rdquo;
state.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="542.8" height="146.8"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afsm))" x-target-lift="Figure"></a>Figure&nbsp;3: </span>A finite-state machines as a diagram</span></p></blockquote><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A &ldquo;lexer&rdquo; is the piece of a language parser that recognizes
and differentiates individual words. Remember that in this book we leave
this task to your JSON library.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">A lexer is also a finite state machine. Its states are &ldquo;have seen this
sequence of letters&rdquo;, starting in a state where no letters have been
recognized. It ends when an expected word has been seen. So a &ldquo;machine&rdquo;
for recognizing the word <span class="RktVal">"raise"</span> from Python&rsquo;s syntax can be
characterized like this:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">states</span> <span class="RktVal">""</span> (no letter seen), <span class="RktVal">"r"</span> (just &ldquo;r&rdquo;),
<span class="RktVal">"ra"</span>, <span class="RktVal">"rai"</span>, <span class="RktVal">"rais"</span>, <span class="RktVal">"raise"</span> and <span class="RktSym">FAILED</span>;</p></li><li><p>the only <span style="font-weight: bold">initial</span> state is <span class="RktVal">""</span>;</p></li><li><p>the two <span style="font-weight: bold">final</span> states are <span class="RktVal">"raise"</span> (signaling success) and
<span class="RktSym">FAILED</span> (signaling failure).; and</p></li><li><p><span style="font-weight: bold">transitions</span> when the letter <span class="RktVal">"r"</span> shows up and the machine is
in state <span class="RktVal">""</span>, it transitions to <span class="RktVal">"r"</span>; for any other letter,
it moves to <span class="RktSym">FAILED</span>.</p><p>Stop! Figure out the remaining transitions.</p></li></ul></div><div class="SIntrapara">The above is a typical description and, usually, works reasonably well.</div></p><p>In addition to the above, people also use two other means to specify state
machines: diagrams and tables.</p><p><a href="#%28counter._%28figure._fig~3afsm%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">3</span></a> shows how to turn this natural-language description
into a diagram with a relatively obvious interpretation. The white node is
an initial state, the black ones are final states, and the gray ones are
intermediate states. The labels on the arrows specify when the lexer
transitions from one state to another. Although every intermediate state
connects to two successor states, the machine is deterministic because the
transition labels are mutually exclusive.</p><p>Here is a table representation of the same finite machine:</p><p><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>current state</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>transition</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>next state</p></td></tr><tr><td valign="top"><p><span class="RktVal">""</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>r</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">"r"</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">"r"</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>a</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">"ra"</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">"ra"</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>i</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">"rai"</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">"rai"</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>s</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">"rais"</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">"rais"</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>e</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">"raise"</span></p></td></tr></table></blockquote></div><div class="SIntrapara">While the set of initial and final states are left implicit, it is easy to
infer them from such a table. Because <span class="RktVal">""</span> never shows up in the
right column and <span class="RktVal">"raise"</span> never in the left one, the two are
the initial and final states, respectively. The FAILED state is left
implicit in such tables; it is assumed to exist because the machine must
also transition somewhere when it is in the first state and the
letter a shows up.</div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_2.png" alt="image" width="599.27125" height="146.8"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asm))" x-target-lift="Figure"></a>Figure&nbsp;4: </span>An infinite-state machine as a diagrams</span></p></blockquote><p><div class="SIntrapara">State machines do not have to come with a finite set of states or even a
finite number of reasons for transition from one state to another. Let&rsquo;s
look at a toy example:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">states</span> all natural numbers;</p></li><li><p>0 is the <span style="font-weight: bold">initial</span> state;</p></li><li><p>FAILED is a <span style="font-weight: bold">final</span> state; and</p></li><li><p><span style="font-weight: bold">transitions</span> when the machine is in state <span style="font-style: italic">n</span> and its &ldquo;input&rdquo;
within a certain time interval is <span style="font-style: italic">n + </span>1<span style="font-style: italic"></span>, it transitions to state
<span style="font-style: italic">n + </span>1<span style="font-style: italic"></span>; otherwise it goes to a FAILED state.</p></li></ul></div><div class="SIntrapara">Yes, this machine cannot succeed, which is why we call it &ldquo;toy.&rdquo;</div></p><p><div class="SIntrapara"><a href="#%28counter._%28figure._fig~3asm%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">4</span></a> shows how such a machine might be specified as a
diagram. The dots at the end of the top are suggestive and perhaps not good
enough for someone who wishes to implement the machine. The following
is a literal translation of the diagram into a table format:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>current state</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>transition</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>next state</p></td></tr><tr><td valign="top"><p><span class="RktVal">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>1</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">1</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>2</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">2</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>3</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">3</span></p></td></tr><tr><td valign="top"><p><span class="RktVal">3</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>4</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">4</span></p></td></tr><tr><td valign="top"><p>...</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>...</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>...</p></td></tr></table></blockquote></div><div class="SIntrapara">As before, the FAILED state is left implicit. Here is a truly concise
tabular specification:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>current state</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>transition</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>next state</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span style="font-style: italic">n</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">n + </span>1<span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">n + </span>1<span style="font-style: italic"></span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>for all <span style="font-style: italic">n &#8712; N</span></p></td></tr><tr><td valign="top"><p><span style="font-style: italic">n</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="font-style: italic">k</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>FAILED</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>for <span style="font-style: italic">k &#8800; n + </span>1<span style="font-style: italic"></span></p></td></tr></table></blockquote></div><div class="SIntrapara">And it is also complete.</div></p><h4><a name="(part._pro~3aimpl-am)"></a>Implementing Abstract Machines</h4><p>From a high-level perspective, a state machine is a relatively simple
program. It consumes some input, creates an initial state from this input,
computes a next state until it reaches a final one, and then produces some
output from this last state of the machine. Historically, the first steps  is
dubbed <span style="font-style: italic">loading</span>, the intermediate step <span style="font-style: italic">transitioning</span>,
and the last one <span style="font-style: italic">unloading</span>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">//</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">the</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">`</span><span class="RktSym">main</span><span class="RktSym">`</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">method</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">Output</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">driver</span><span class="RktPn">(</span><span class="RktSym">Input</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">in</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">initial_state</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">load</span><span class="RktPn">(</span><span class="RktSym">in</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">current</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">initial_state</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">while</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">!</span><span class="RktPn">(</span><span class="RktSym">final_state_huh</span><span class="RktPn">(</span><span class="RktSym">current</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">current</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">transition</span><span class="RktPn">(</span><span class="RktSym">current</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Output</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">out</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">unload</span><span class="RktPn">(</span><span class="RktSym">current</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">return</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">out</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">//</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">turning</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">input</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">`</span><span class="RktSym">in</span><span class="RktSym">`</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">into</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">an</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">initial</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">state</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">load</span><span class="RktPn">(</span><span class="RktSym">Input</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">in</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">return</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">initial_state</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">//</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">computing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">the</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">next</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">state</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">given</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">the</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">`</span><span class="RktSym">current</span><span class="RktSym">`</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">one</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">transition</span><span class="RktPn">(</span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">current</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">next</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">return</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">next</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">//</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">is</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">this</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">state</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">`</span><span class="RktSym">s</span><span class="RktSym">`</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">final</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">state?</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">Boolean</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">final_state_huh</span><span class="RktPn">(</span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Boolean</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">what_is_it</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">return</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">what_is_it</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">//</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">turning</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">final</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">state</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">into</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">some</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">output</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">Output</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">unload</span><span class="RktPn">(</span><span class="RktSym">State</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Output</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">out</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">return</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">out</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3amachine-outline))" x-target-lift="Figure"></a>Figure&nbsp;5: </span>A template for an abstract machine implementation</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3amachine-outline%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">5</span></a> displays the complete program, using
pseudo-code similar to what readers should know from a first or second course on
<span style="font-style: italic">Programming</span>.  The program&rsquo;s entry point is the <span class="RktSym">driver</span> method, which
refers to four helper methods: <span class="RktSym">load</span><span class="RktMeta"></span> for turning the given input into an
initial state; <span class="RktSym">transition</span><span class="RktMeta"></span> for creating the next state from the current
state; <span class="RktSym">final_state_huh</span><span class="RktMeta"></span> for recognizing whether a state belongs to the set
of final ones; and <span class="RktSym">unload</span><span class="RktMeta"></span> for creating some output from the final machine
state.</p><p>If a state machine reacts to notions other than its current state, the
<span class="RktSym">driver</span><span class="RktMeta"></span> method must consume this input and hand it to
<span class="RktSym">transition</span><span class="RktMeta"></span> so that this method can compute the next state from the
current one and the input.</p><p>If a state machine generates output for (some of) its transitions, the
<span class="RktSym">transition</span><span class="RktMeta"></span> method should return two result values: the next state
and the output. The <span class="RktSym">driver</span><span class="RktMeta"></span> method can then display the output as
appropriate.</p><p>By isolating the processing of external stimuli and output in the
<span class="RktSym">driver</span><span class="RktMeta"></span> method, the remaining <span class="emph">functions</span> and remain easy to
test in isolation. And this point brings us to the topic of programming in
general.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="../Notes/note_0-asm.html" data-pltdoc="x">Implementing
Abstract State Machines</a> in the notes explain how to solve these
exercises.</span></span></span></p><p><a name="(counter._(exercise._ex~3afsm))"></a><span style="font-weight: bold">Exercise</span>&nbsp;1. Implement the finite state machine from this
section in your favorite programming language. <a href="#%28counter._%28exercise._ex~3afsm%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3ainf-sm))"></a><span style="font-weight: bold">Exercise</span>&nbsp;2. Implement the infinite state machine from this
section. <a href="#%28counter._%28exercise._ex~3ainf-sm%29%29" class="ex-end" data-pltdoc="x"></a></p><h4><a name="(part._pro~3atx-dat)"></a>Text versus Data</h4><p>The <span class="RktSym">driver</span><span class="RktMeta"></span> of our abstract machines consumes an input, which <span class="RktSym">load</span><span class="RktMeta"></span>
turns into an initial machine state.  When the machine stops in a final state,
<span class="RktSym">unload</span><span class="RktMeta"></span> renders this state as an output.</p><p>Now you may wonder what these inputs and outputs are. In this book, the input is
a data representation of a program; the output is the data representation of the
program&rsquo;s result. But, you mat wonder, programs are just text, sequences of
keyboard characters that you enter into an IDE or text editor. And results are
obviously just numbers, strings, and such &ldquo;things.&rdquo;</p><p>While this view of programming may work for simple application domains, the
domain of abstract machines for programming languages demands a nuanced view of
programming. It demands a systematic design approach. This section walks you
through the rudimentary ideas. If you are intrigued, consider studying our book
<a href="https://htdp.org/"><span style="font-style: italic">How to Design Programs</span></a>.</p><p><div class="SIntrapara">Let&rsquo;s start with what you enter into your favorite IDE: text. And let&rsquo;s
immediately focus on programming language ideas. Every programming languages has
a way of adding numbers, and perhaps several at once:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">1 + 2</span></p></td></tr></table></div><div class="SIntrapara">Although you might never enter the exact arithmetic expression above into your
IDE, you could. In Racket, you would write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(+ 1 2)</span></p></td></tr></table></div><div class="SIntrapara">And, there are even languages in which you write this addition in yet another
way.</div></p><p>So, we have to settle on how to write this kind of expression in a standard
way. This book uses JSON notation for the programming languages we wish to
create and study via abstract machines.</p><p>JSON is a simple data notation that permits people to write down four different
kind of values: numbers, strings (character sequences enclosed in quotes),
arrays of JSON values, and objects (which combine strings with JSON values via
<span class="stt">":"</span>). Most of the time, we use only the first three.</p><p><div class="SIntrapara">One way of writing the above addition in JSON is this:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[1, "+", 2]</span></p></td></tr></table></div><div class="SIntrapara">This JSON array consists of three elements: the number <span class="stt">1</span>, the string
<span class="stt">"+"</span>, and the number <span class="stt">2</span>. But, it is still just text in a file.</div></p><p><div class="SIntrapara">Fortunately, your favorite programming language comes with a library for reading
JSON files. &ldquo;Reading&rdquo; means that the library opens the file, reads the text,
breaks it down into JSON values, and chooses data that your favorite language
understands to represent these values. In Racket, the above JSON would yield a
list:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">If your chosen language is Java, the library might build an equivalent
JsonArray:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">JsonArray ja = new JsonArray();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">ja.add(new Integer(1));</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">ja.add("+");</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">ja.add(new Integer(2));</span></p></td></tr></table></div><div class="SIntrapara">You should have no trouble relating these pieces of data to the JSON array and
vice versa.</div></p><p>The key is, though, that text in a file is <span class="emph">not</span> data in your programming
languages. Libraries read this text and create data in your programming
language. Indeed, the same libraries often also provide the functionality for
converting data into text again.</p><p>But, it is dealing with  <span class="emph">data</span> that makes for systematic program design.</p><h4><a name="(part._pro~3asys-des)"></a>Systematic Program Design: The Idea</h4><p>Procedural or functional programs consist of functions, with one designated as
the entry point. Object-oriented programs consist of classes with methods, and
one of these is instantiated first by the run-time system. For simplicity, this
section presents the systematic design of procedural programs; the notes discuss
an object-oriented approach.</p><p>With the reading of JSON inputs and the writing of JSON outputs out of the way,
systematic program design focuses on dealing with the data. For example, a
Racket program deals only with lists (that represent JSON arrays) and a Java
program would deal only with <span class="stt">JsonArray</span>s.</p><p>From a procedural perspective, a program thus transforms data to data. A design
method must hence start from a description of all possible data that a program
may consume and produce. Beyond this, a program may have to deal with additional
forms of data at intermediate steps, which are represented as separate functions,
and their design can therefore be viewed as the design of mini-programs.</p><p>This section presents our suggested approach to the design of functions in this
domain as an abstract six-step recipe. The next two sections illustrate how to
create complete programs with this approach.</p><p><div class="SIntrapara"><ol><li><p>Your first task is to precisely <span style="font-weight: bold">describe the data</span>, both inputs and
outputs.</p><p>A precise data description helps you <span style="font-weight: bold">create example</span>, check whether a
piece of data belongs or doesn&rsquo;t, and directs the rest of the design. Testing
your understanding of the data definition means <span style="font-weight: bold">interpreting</span> examples as
JSON values and <span style="font-weight: bold">representing</span> feasible JSON inputs as data.</p><p>If your favorite programming language comes without types, use stylized English,
acting as if you were describing sets of data. As a matter of fact, being
precise in this context and meticulously maintaining this comment is critical
for getting things right.</p><p>If your language comes with types, make the type definitions as precise as
possible.</p><p>If you are working with an object-oriented language, keep in mind that
interfaces describe sets of data and classes signal disjoint subsets
(<span style="font-style: italic">variants</span>).</p></li><li><p>Next, state a <span style="font-weight: bold">function signature</span> and the <span style="font-weight: bold">purpose</span> of the
function in your own words.</p><p>Type signatures plus well-chosen names often provide enough clues to understand
what a function computes. In the context of untyped languages, it is still
important to write down signatures as comments and to make sure that every
&ldquo;type&rdquo; mentioned in the comment is defined in step 1.</p><p>Your well-articulated purpose statement of a method is probably the second most
important part of this design recipe. First, articulating the function&rsquo;s purpose
in your words&#8212;<wbr></wbr>even if gleaned from a written task specification&#8212;<wbr></wbr>greatly
clarifies your thinking. Second, it helps with all remaining steps, especially
the coding step.</p></li><li><p>Every problem solver must <span style="font-weight: bold">work through examples</span>.</p><p>Once you have clarified the function&rsquo;s purpose in your mind, you can work
through examples. For small programs, you may wish to start from the examples in
step 1. You definitely want to cover &ldquo;extreme&rdquo; cases. For example, if you are
working with numeric intervals, you want to cover both end points and a point in
the middle. For complex projects, software engineers work through use cases,
which play the same role as working thru small examples.</p><p>Working through examples solidifies your understanding of <span class="emph">what</span> the
function must compute, though not necessarily how it accomplishes its
goal. Thus, the starting and end points of worked examples become unit tests.</p></li><li><p>The data descriptions dictate the <span style="font-weight: bold">outline</span> (also known as
<span style="font-weight: bold">template</span>) of your program.</p><p>In basically every contemporary programming language, you can match the layout
of the function to the description of the input data. If the description takes
note of three distinct subsets (variants), your function will use conditionals
to separate out the three cases. The designer can then deal with each in
isolation.</p><p>For each variant, you want to list the pieces of data that are available in this
case. The result will be computed from these pieces plus constant definitions
plus, on rare occasions, global variables.</p><p>Then you want to note where the data definition refers to itself. In simple
domains, these self-references are often hidden behind special-case data
structures. In complex domains, such as programming languages, you need to think
through these self-references. When you understand where the data definition
refers to itself, you know where the function will, in all likelihood, have to
call itself. Yes, if data descriptions refer to themselves, functions that
process instances of this data recursive.</p><p>Finally, in the domain of programming languages, you will encounter data
definitions that refer to themselves; that refer to others, which refer back to
the original; and so on. Dealing with such data definitions is a straightforward
generalization of what this step. The book will provide additional hints when
the time is ripe.</p></li><li><p>Now it is time to <span style="font-weight: bold">code</span>.</p><p><div class="SIntrapara">In principle, all you have to do now is combine the expressions in each separate
case of the template. To do so, you remind yourself what the purpose of the
function is; see step 2. This is what the recursive calls compute for the pieces
of the given data, in one fell swoop. And then there&rsquo;s some other pieces of
data. Your challenge is to
</div><div class="SIntrapara"><ul><li><p>either find a function in your favorite language, or its libraries, that
combines the data you can get into the desired result.</p><p><div class="SIntrapara">Finding this &ldquo;combiner&rdquo; may pose a challenge on occasion. Here is the best
advice we can give:
</div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">use the worked examples, to make examples for these cases.</span></p></blockquote></div><div class="SIntrapara">In our experience, given a sufficient number of examples tailored to these
special cases, will almost directly suggest an answer. If it doesn&rsquo;t move to the
second alternative.</div></p></li><li><p>or develop a helper function that performs the combination.</p><p>To understand what this helper function must compute, use the worked examples to
find examples for this function. This will help with the first few design steps
for this new function. And it will ensure that the function contributes to the
overall goal.</p></li></ul></div></p></li><li><p>Finally turn the worked examples into <span style="font-weight: bold">unit tests</span>.</p><p>In many cases, this is the simplest of all steps. Sometimes it is so simple that
you can create unit tests while you work through examples. But if you don&rsquo;t have
a test suite, you will spend way too much time of your life finding bugs instead
of being productive.</p></li></ol></div><div class="SIntrapara">It may feel like this procedure is a lot of work for writing some program, which
is &ldquo;just writing some lines of code in X&rdquo; for your choice of X. But good
programming is a lot more. Most importantly, it is about articulating thoughts
as clearly so that the recipient&#8212;<wbr></wbr>another programmer or you, five weeks
older&#8212;<wbr></wbr>can understand these thoughts quickly and add to the functionality of
the code base.</div></p><h4><a name="(part._pro~3asys-des-ex)"></a>Systematic Program Design: A Worked Example</h4><p>Let&rsquo;s make this concrete. Every programming language comes with a notation for
plain arithmetic or, even simpler, plain addition expressions. Writing a
program that produces the result of such addition expressions perfectly
illustrates the notion of systematic program design.</p><p><div class="SIntrapara">To begin with, we need to figure out how to write addition expressions down in
JSON, our one and only textual input language. Clearly we can generalize the
above JSON notation to deal with all possible addition expressions.  Here is a
precise description of the kind of JSON text file the program should expect:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">A JSON representation of nested addition expressions uses</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- numbers as literal constants</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- JSON arrays of the form [X, "+", Y]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where X and Y are JSON representation of addition expressions.</span></p></td></tr></table></div><div class="SIntrapara">In a sense this is just a rigorous description of the kinds of expressions all
<span class="refelem"><span class="refcolumn"><span class="refcontent">Yes, we use fully parenthesized notation here to simplify the
illustration.</span></span></span>
of us encounter in grade school. Consider these instances:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[1,"+",1]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[[1,"+",1],"+",2]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[[1,"+",2],"+",[3,"+",4]]</span></p></td></tr></table></div><div class="SIntrapara">Now this is text but in this section we wish to work with data.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">The Data Description</span> Racket&rsquo;s JSON reader turns arrays into list, and
so these three examples look like this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">To get a full data description of all possible addition expressions, we start
by hiding the numbers and saying that they must be expressions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">An </span><span style="font-style: italic">addition expression</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is one of:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-- a number</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-- ...</span></p></td></tr></table></div><div class="SIntrapara">The first two examples turn into these:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span style="font-style: italic">an expression</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span style="font-style: italic">an expression</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span style="font-style: italic">an expression</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span style="font-style: italic">an expression</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span style="font-style: italic">an expression</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Stop! Deal with the third one in an analogous manner.</div></p><p><div class="SIntrapara">Now we can recognize the pattern. The alternative to a number is a list of
three pieces: an <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a>, the string <span class="RktVal">"+"</span>, and another <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a>.
And this yields a full-fledged data description:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">An </span><a name="(tech._addition._expression)"></a><span style="font-style: italic">addition expression</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">is one of:</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-- an integer</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-- (list </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">"+" </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="stt">)</span></p></td></tr></table></div></p><p>At this point, we have a description of the complete set of data that our
functions must process, we have additional examples, and we have thus almost
completed the first step of the design. The missing pieces are
&ldquo;interpretation&rdquo; and &ldquo;representation,&rdquo; that is, ways of going from Racket
data examples to JSON text and from JSON text to Racket data. We know you can
do it, and so we leave this to an exercise.</p><p><a name="(counter._(exercise._ex~3ainterpretation))"></a><span style="font-weight: bold">Exercise</span>&nbsp;3. Make up three more Racket examples of
<a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expressions</span></a> and <span class="emph">interpret</span> them as JSON. Then write
down a sentence that states the general method. Most JSON libraries come with
a function that renders a list representation as JSON text. Check out yours. <a href="#%28counter._%28exercise._ex~3ainterpretation%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3arepresentation))"></a><span style="font-weight: bold">Exercise</span>&nbsp;4. Make up three more JSON examples of addition
expressions and <span class="emph">represent</span> them as Racket data (<a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a>). This is what
the task that the JSON reader performs in every language. Finally, write down
a sentence that states the general method. <a href="#%28counter._%28exercise._ex~3arepresentation%29%29" class="ex-end" data-pltdoc="x"></a></p><p><span style="font-weight: bold">The Signature and the Purpose</span> The purpose of the desired function is to
determine the result of the <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a>. By implication, the
function consumes an <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a> and produces a number.</p><p><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Instructors of first-semester courses who ask for &ldquo;comments&rdquo;
often see phrases such as &ldquo;takes an addition expression, produces a number,&rdquo;
which repeats the signature and doesn&rsquo;t inform a reader of what the function
is all about.</span></span></span>  Here is how you say these things in Racket code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="RktCmt"> -&gt; </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">given an </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="RktCmt"> </span><span class="RktSym">ae</span><span class="RktCmt">, adds up all the numbers in it</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">As you may know, the first line is dubbed a <span style="font-style: italic">signature</span>, the second a
<span style="font-style: italic">comment</span> a <span style="font-style: italic">doc string</span>, or whatever different programming
cultures call it. We prefer the term <span style="font-style: italic">purpose statement</span> because this
term tells us that this line of text must say what the function computes. The
third line is a <span style="font-style: italic">function header</span>; it gives the function and its
argument(s) names that can be used in the purpose statement. And the last line
is a feasible result value.</div></p><p>For simple functions such as <span class="RktSym">sum</span>, adding a properly articulate
purpose statement looks like &ldquo;busy work.&rdquo; The signature and the function&rsquo;s
name seem to say it all. The coding step below gives a first hint why this
isn&rsquo;t really true.</p><p><div class="SIntrapara"><span style="font-weight: bold">Functional Examples</span> The data description step includes three examples
of <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expressions</span></a>, just as its abstract description says. Working
through examples can start from those and the purpose statement. Let&rsquo;s deal
with example in turn:
</div><div class="SIntrapara"><ul><li><p>if the function is given <span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span>, it must obviously
return <span class="RktVal">2</span>;</p></li><li><p>for <span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">]</span>, it produces
<span class="RktVal">4</span>&#8212;<wbr></wbr>because we already know that the nested expression yields
<span class="RktVal">2</span> and the rest is just adding <span class="RktVal">2</span> and <span class="RktVal">4</span>; and</p></li><li><p><span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">"+"</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">]</span> should yield
<span class="RktVal">10</span> by an argument similar to the previous one.</p></li></ul></div><div class="SIntrapara">Of course, arguments are somewhat unnecessary because you know that the
function just adds up all the numbers that occur in the <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition
expression</span></a>.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">The Outline</span> For most functions, the description of the input data
completely determines the outline of the function.<span class="refelem"><span class="refcolumn"><span class="refcontent">One exception
is &ldquo;parsing&rdquo; a sub-area of the compilers and programming languages area;
another exception is algorithms.</span></span></span> To demonstrate this point, we construct the
outline of <span class="RktSym">sum</span> in a somewhat pedantic fashion, using four steps, each
of which starts with a question:
</div><div class="SIntrapara"><ul><li><p>How many different kinds of <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expressions</span></a> are there?</p><p>If a data description lists <span style="font-style: italic">N</span> different cases, your function
definition should (initially) differentiate these cases from each other. Here
<span style="font-style: italic">N = </span>2<span style="font-style: italic"></span>, so <span class="RktSym">sum</span> can use a two-pronged conditional.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></li><li><p>How can we express the distinction with code?</p><p>Next, you work out a Boolean expression involving the parameter that
distinguishes these cases from each other. In the case of <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition
expression</span></a>, the first sub-set consists of just numbers, meaning the Boolean
expression asks whether <span class="RktSym">ae</span> is a number. For the last case of any
conditional, we can usually cheat and say &ldquo;else&rdquo; but here we ask whether
<span class="RktSym">ae</span> is a list.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><span style="font-weight: bold">Note</span> The set of numbers and lists are disjoint sets, even for an
untyped language such as Racket. So the two cases are now independent of each
other; we could even switch them if wanted to. On occasion, though, it is
acceptable to rely on the order in which a conditional operates.</p></li><li><p>Is it necessary to extract pieces of the given expression?</p><p><div class="SIntrapara">Once the <span style="font-style: italic">N</span> cases are clearly separated, you can think through each of
them in isolation. So when we ask a question such as this one, we can deal
with each case one at a time:
</div><div class="SIntrapara"><ul><li><p>for the case of numbers, there are no pieces to consider. A number is
like an atom.</p></li><li><p>By contrast, all the lists in the description of <span class="RktSym">addition</span><span class="stt"> </span><span class="RktSym">expression</span> consist of three pieces: two sub-expressions separated by the
string <span class="RktVal">"+"</span>. And it is obviously the two sub-expressions that
<span class="RktSym">sum</span> may need to compute its result&#8212;<wbr></wbr>the string never changes
anyways.</p></li></ul></div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">third</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></li><li><p>Are any of these pieces <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expressions</span></a>?</p><p>Again, because the cases are identified and distinct from each other, we can
focus on one case at a time. For the first case, there are no pieces, and the
data definition does not refer to itself. For the second case, the data
definition refers to itself for the first and third element of the list. In a
function outline, we express this by calling the function recursively on the
corresponding pieces in this case.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">third</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></li></ul></div></p><p><div class="SIntrapara">Every programming language allows a developer to articulate an outline in
several different and differently convenient ways. For example, Racket
supplies a conditional called <span class="RktSym">match</span> that combines the differentiation
and extraction aspects of an outline into one functionality:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">In this variant, the second case, for example, tells a reader that the data
must have the shape of a list of three pieces, that the middle piece must be
<span class="RktVal">"+"</span>, and that the first and third will be named <span class="RktSym">left</span> and
<span class="RktSym">right</span> for the rest of the case.</div></p><p>Stop! Explain <span class="RktPn">(</span><span class="RktSym">sum</span><span class="stt"> </span><span class="RktSym">left</span><span class="RktPn">)</span> and <span class="RktPn">(</span><span class="RktSym">sum</span><span class="stt"> </span><span class="RktSym">right</span><span class="RktPn">)</span> before reading on.</p><p>Stop! Reflect on the four questions. Are any specific to the problem at hand?</p><p>None of the four questions mention the specific programming problem or even
the specific data description. Hence it is possible to use these questions for
<span class="emph">any</span> programming problem; indeed they even work for many non-programming
problems. What these questions do is translate the &ldquo;input&rdquo; you have into a
template for action. If you can solve the problem, these are the pieces that
you have. If the function can compute the desired result, it must involve
the material laid out here.</p><p><div class="SIntrapara"><span style="font-weight: bold">The Actual Code</span> The rest is a mere matter of closing the few gaps left
in the outline. For this step, too, we proceed pedantically, also asking four
questions:
</div><div class="SIntrapara"><ul><li><p>Which cases are easy to deal with?</p><p>In the case of <span class="RktSym">sum</span>, the first case is the easy one. When <span class="RktSym">sum</span>
is given a single number, this number is the result.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">third</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">..</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></li><li><p>What do the pieces of the outline compute in each complex case?</p><p>Once again, remember that you can deal with each case in isolation now
because the conditional separates them.</p><p><div class="SIntrapara">The key is to remember the purpose statement. For every recursive
function call, the purpose statement tells us what the result is.
Let&rsquo;s walk through this idea carefully:
</div><div class="SIntrapara"><ul><li><p><span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span> extracts the first piece from <span class="RktSym">ae</span>,
and it is an <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a>.</p></li><li><p>Here is the purpose statement again:</p><blockquote class="SubFlow"><p><span style="font-style: italic">given an <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition
expression</span></a> <span class="RktSym">ae</span>, adds up all the numbers in it.</span></p></blockquote></li><li><p>So the function is now <span class="emph">given <span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span></span>. Hence,
, according to the purpose statement <span class="RktPn">(</span><span class="RktSym">sum</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span>, adds
up all the numbers in <span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span>. All of them. No questions
asked.</p></li></ul></div><div class="SIntrapara">You will see in a moment how much we just learned.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">..</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">the </span><span class="RktSym">sum</span><span class="RktCmt"> of all numbers in </span><span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">..</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">third</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">the </span><span class="RktSym">sum</span><span class="RktCmt"> of all numbers in </span><span class="RktPn">(</span><span class="RktSym">third</span><span class="stt"> </span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">..</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></li><li><p>Is there a function that combines these values into the desired result?</p><p>When <span class="RktSym">sum</span> is given an <a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a> <span class="RktSym">ae</span>
that is a list, it contains numbers in the first piece and the third
piece. But we already have the sum of all the numbers in these two
pieces. So to get the sum of <span class="emph">all</span> numbers in <span class="RktSym">ae</span>, we
just need to add those two numbers.</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">read as </span><span class="RktCmt">&ldquo;</span><span class="RktCmt">conditional</span><span class="RktCmt">&rdquo;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">third</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">That&rsquo;s it.</div></p></li></ul></div><div class="SIntrapara">Going through these steps so carefully might again look like overkill,
but when things get complicated, remember these steps will safe you a
lot of time.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Unit Tests</span> The solution is not complete. No software is
complete without some unit tests. At this point, reach back to the
second step and turn the examples into unit tests:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Now you&rsquo;re done with the <span class="RktSym">sum</span> function.</div></p><p>But, you still have to write the program.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename">program.rkt</span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">provide</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="RktCmt"> -&gt; </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">given an </span><a href="#%28tech._addition._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">addition expression</span></a><span class="RktCmt"> </span><span class="RktSym">ae</span><span class="RktCmt">, adds up all the numbers in it</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ae</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">module+</span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">"+"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asum))" x-target-lift="Figure"></a>Figure&nbsp;6: </span>The <span class="RktSym">sum</span> module</span></p></blockquote><h4><a name="(part._pro~3aprogramming)"></a>Programmnng, Debugging Systematically</h4><p><a href="#%28counter._%28figure._fig~3asum%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">6</span></a> shows the entire <span class="RktSym">sum</span> module: its export
(<span class="RktSym">sum</span>), the function definition, and the unit test sub-module (which is
loaded and run only on demand).</p><p><div class="SIntrapara">What we really want, though, is a program that runs from the command line, reads
JSON expression, computes, and writes a JSON answer.  On a Mac or Linux box, we
want to be able to write
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[/Users/MAPL/Code/] $ ./test-harness</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[1, "+", 1]</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">2</span></p></td></tr></table></div><div class="SIntrapara">The first line is the command, the second our input, and the third one the program&rsquo;s
output.</div></p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename">test-harness</span></p><blockquote class="Rfilecontent"><p><div class="SIntrapara"><span class="stt">#! /usr/bin/env racket</span>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">EFFECT </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- read JSON test for an addition expression from STDIN, </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- run </span><span class="RktCmt">&lsquo;</span><span class="RktCmt">program</span><span class="RktCmt">&lsquo;</span><span class="RktCmt"> on this data </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- write result to STDOUT as JSON number </span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">provide</span><span class="hspace">&nbsp;</span><span class="RktSym">main</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">json</span><span class="hspace">&nbsp;</span><span class="RktVal">"program.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">main</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">write-json</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">read-json</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">module+</span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">json1</span><span class="hspace">&nbsp;</span><span class="RktVal">"[1,\"+\",1]"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">with-output-to-string</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">with-input-from-string</span><span class="hspace">&nbsp;</span><span class="RktSym">json1</span><span class="hspace">&nbsp;</span><span class="RktSym">main</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">"a basic integration test"</span><span class="RktPn">)</span></td></tr></table></div></p></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aprog-vs-test))" x-target-lift="Figure"></a>Figure&nbsp;7: </span>The program</span></p></blockquote><p><div class="SIntrapara"><a href="#%28counter._%28figure._fig~3aprog-vs-test%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">7</span></a> displays the entire program, which also serves as a
template for all the test harnesses expected for the exercises in this book. Some of
it is formulaic, for example:
</div><div class="SIntrapara"><ul><li><p>the first line, which turns the rest of the module into a command-line program;</p></li><li><p>the second line, which makes the <span class="RktSym">main</span> function available outside;</p></li><li><p>the third line, which imports the <a href="http://docs.racket-lang.org/json/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">json</span></a> library and <span class="RktSym">sum</span>.</p></li></ul></div></p><p>The most interesting part is the definition of <span class="RktSym">main</span>. In this simple case,
<span class="RktSym">main</span> reads JSON text from <span class="stt">STDIN</span>, sends the resulting data into
<span class="RktSym">sum</span>, and writes the resulting number as JSON text to <span class="stt">STDOUT</span>. For the
given problem, this plain function composition is just enough to accomplish the
desired purpose.</p><p>The second interesting part is the test sub-module. Just like the module defining
<span class="RktSym">sum</span>, the <span class="RktSym">main</span> module can also come with tests. Here it is
appropriate to speak of an <span style="font-style: italic">integration test</span> because it checks the
collaboration among several different components, from the very entry point to the
exit.</p><p><span style="font-weight: bold">Test Harnesses and Programs</span> This book uses the terminology program and test
harness. A <span style="font-style: italic">program</span> operates on language-internal data structures of the
programming language.  By contrast, a <span style="font-style: italic">test harness</span> reads external, textual
information} defers to a program for computation on the resulting data structure, and
renders the value of the computation as JSON.</p><p><div class="SIntrapara"><span style="font-weight: bold">Debugging</span> As already mentioned in the context of abstract state machines, the
separation of programs from test harnesses greatly facilitates the testing of
programs, especially if their code avoids assignment statements as much as possible.
When (not if) you discover that your program is buggy, you can follow these steps:
</div><div class="SIntrapara"><ul><li><p>formulate the buggy behavior as a failing test case, possibly starting at the
level of the test harness;</p></li><li><p>translate the test case into internal data for the entry point of your
program;</p></li><li><p>derive test cases for <span class="emph">all</span> suspicious functions that the entry point
calls.</p><p>Some of those will succeed, and one or more will fail. Repeat the process until you
have located the logical mistake and all tests pass.</p><p>For <span class="RktSym">sum</span>, there are no helper functions. For <span class="RktSym">driver</span> from
<a href="#%28part._pro~3aimpl-am%29" data-pltdoc="x">Implementing Abstract Machines</a>, there are several: <span class="RktSym">load</span><span class="RktMeta"></span>, <span class="RktSym">transition</span><span class="RktMeta"></span>,
<span class="RktSym">unload</span><span class="RktMeta"></span>, and <span class="RktSym">final_state</span><span class="RktMeta"></span>. One of these must have an error if the overall
code misbehaves.</p></li></ul></div><div class="SIntrapara">While this style of programming is not always feasible, it will serve you well for
the exercises in the rest of the book.</div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_preface.html" title="backward to &quot;Preface&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="ch_pl.html" title="forward to &quot;1 Programming Languages&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
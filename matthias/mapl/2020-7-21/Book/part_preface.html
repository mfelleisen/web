<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Preface</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Machines and Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="ch_pl.html" class="tocviewlink" data-pltdoc="x">Programming Languages</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ch_arith.html" class="tocviewlink" data-pltdoc="x">Arithmetic,
Your First Programming Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="ch_algebra.html" class="tocviewlink" data-pltdoc="x">Algebra, Your Second Programming
Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="ch_lambda.html" class="tocviewlink" data-pltdoc="x">First-<wbr></wbr>Class Functions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ch_mutation.html" class="tocviewlink" data-pltdoc="x">Mutable Objects</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="ch_cc.html" class="tocviewlink" data-pltdoc="x">Full Control</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="ch_express.html" class="tocviewlink" data-pltdoc="x">The Dimensions</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="ch_space.html" class="tocviewlink" data-pltdoc="x">Space</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="ch_types.html" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="ch_futures.html" class="tocviewlink" data-pltdoc="x">Futures</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Preface</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8.0.1</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_prologue.html" title="forward to &quot;Prologue&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._part~3apreface)"></a>Preface</h3><a name="(part._chap~3apart~3apreface)"></a><p>Programming languages is the most important area of college specialization for
any future software developer. With a  programming language a developer turns
thoughts into messages to future developers&#8212;<wbr></wbr>including an older version of the
devloper&#8212;<wbr></wbr>who will add functionality, fix bug, and take care of it in other
ways. Only the clearest possible articulation of thoughts enables these future
developers to comprehend and act easily; everything else requires a large
investment of time and makes people feel unproductive. Understanding the chosen
language and having the tools to understand all of the several languages that
make up a system is hence critical. The programming languages area provides
exactly those tools.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3apl%29" class="toclink" data-pltdoc="x">Programming Languages</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3amachine%29" class="toclink" data-pltdoc="x">Abstract State Machines</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3achoice%29" class="toclink" data-pltdoc="x">Programming</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3ainstructor%29" class="toclink" data-pltdoc="x">To the Instructor</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aackn%29" class="toclink" data-pltdoc="x">Acknowledgment</a></p></td></tr></table><h4><a name="(part._sec~3apl)"></a>Programming Languages</h4><p>In this day and age, almost every software developer uses several programming
language to construct a single software system. One language directs the server,
which connects to a database, a component with its own language. A different
language makes up the client. If this client component is code for a web browser,
it alone may use HTML, CSS, JacaScript or languages that compile to JavaScript,
plus JavaScript frameworks, which to many people &ldquo;feel&rdquo; like programming
languages, too. In short, an effective software developer is a multi-lingual
developer.</p><p>As the world has grown smaller due to faster travel and closer integration, many
people have become multi-lingual. A nephew may grow up in Germany, work in England
and France, and communicate with his Moroccan girl friend in broken Arabic. While
French and English came to him easily because they belong to the same language
family as German, Arabic was a challenge even if the Moroccan variant uses a lot of
Spanish words.</p><p>Linguists study this idea of language families. They tease out the commonalities
and the differences. They try to figure out what makes a language and how do people
use it. They look for the principles of what makes up languages, and studying these
principles helps them understand and teach how natural languages function.</p><p>Programming language researchers are linguists of artificial languages. Like
ordinary linguists, they study the fundamental, cross-cutting principles that
groups programming languages share and ideas that set those groups apart. To get to
this point, though, a student of programming languages must start with the very
basic concepts that make up a language: vocabulary, grammar, meaning, and
pragmatics also known as idioms.</p><p>This book is an introduction to the very basics of this area of research. It
explains how to discuss the different parts of a language, how to understand them,
and relate them to each other. By contrast to other books on this topic, it uses
abstract (not hardware) machines to explain how programs work and what concepts
mean in terms of such machines. Also unlike other texts, the book does <span class="emph">not</span>
prescribe a programming language in which readers must solve the problems; the
choice is left to the instructor and the students.</p><h4><a name="(part._sec~3amachine)"></a>Abstract State Machines</h4><p>If you ever bought a soda or a candy or anything else from a vending machine,
you have encountered a state machine. It sits there and waits; when a customer
enters a choice, it displays the price; once enough money is deposited, it
dispenses the chosen item and goes back to waiting for the next customer. People
say that the machine is in a &ldquo;state&rdquo; when it is waiting for an action by a
customer, and an action causes a transition from one state to the next.</p><p>You may also have taken a course that deals with &ldquo;finite state machines.&rdquo; Then
you know that they play an important role in understanding computation.</p><p>No matter what, you have used a computer, and a computer is a finite state
machine.  This piece of hardware consists of a memory and a computational
circuitry that can change what is in the memory. While this memory is quite
large in this day and age, it is finite Each piece of memory is also finite; it
consists of &ldquo;yeah many&rdquo; bits&#8212;<wbr></wbr>the famous 0s and 1s. So think of the settings
of all these bits as a particular state. Two states differ is any of these bit
settings differ. When the computational unit executes an instruction, it changes
some bit settings. The computer transitions to in a different state. The
sequence of all such states is a complete representation of a program
execution&#8212;<wbr></wbr>though it won&rsquo;t be easy to store it anywhere not to speak of
understanding it.</p><p>But looking at this trace to understand what a program in any high-level
programming language means is useless.</p><p>Two points obscure the understanding. When a finite-state machine has as many
states as your computer, you might as well think of it as an infinite-state
machine. This change should be easy to accept; there is no difference between
two gazillions and infinity. The real problem is that a mile-long sequence of
bits is not easy to grasp and comparing two of those to understand that an
instruction really just added two numbers is way too much work. If the goal is
to understand the meaning of entire programming languages&#8212;<wbr></wbr>an infinite
collection of programs&#8212;<wbr></wbr>this approach is hopeless.</p><p>Over time programming language research has developed a number of ways to
articulate what a machine does when it runs a program: enriching a programming
language with logical statements, interpreters, mathematical (denotational and
operational) semantics, and many more. Most are quite mathematical because many
programming language researchers wish to prove theorems about all the programs
in a language.</p><p>This book uses abstract machines, an intermediate point between real machines
and purely mathematical descriptions. Like a finite-state machine, an abstract
machine may assume a usually infinite number of states, and the machine
transitions from one state to another to represent the meaning of an
instruction. In contrast to a finite-state machine, the states of an abstract
machine are data structures that resemble programs and ordinary data structures
such as stacks, trees, dictionaries, and so on.</p><p><div class="SIntrapara">Settling on abstract machines has the advantage of expressing in one framework
the dual nature of a programming language:
</div><div class="SIntrapara"><ul><li><p>On one hand, a programming language is a real-world product that
manipulates the real bits of a computer, accepts finger swipes, and changes the
display in response.</p></li><li><p>On the other hand, a programming language is an artificial object that can
be studied with the tools of mathematics and logic.</p></li></ul></div><div class="SIntrapara">Key is that it is easy to develop abstract machines into concrete real-world
low-level software or hardware and yet it is equally easy to state and prove
mathematical theorems about them. And programming language researchers do both,
all the time.</div></p><p>Hence a student equipped with the basics of abstract machines has many
advantages. The act of studying abstract machines alone provides a rich practice
ground for developing good programming habits. Once these machines are
understood, a student can easily build a realistic implementation of a new
language. At the same time, this very same student is ready to read papers in
the research literature.</p><h4><a name="(part._sec~3achoice)"></a>Programming</h4><p>In the past, researchers have used two approaches to understand the world:
hands-on experimentation and mathematical thinking. Computer science adds a
third tool: programming. A program codifies knowledge as an active artifact and
thus enables a new form of experimentation and communication.</p><p>Hence this book comes with many exercises on turning the presented ideas into
code.  Project suggestions in late chapters introduce complete alternatives. A
reader will get the most out of the book by solving these problems with running,
testable programs.</p><p>Yes, this means we want you to program, and it is best to program in your
favorite language. Transferring ideas into something you know already will
improve your understanding a lot.</p><p>Yes, and this really means you will create programs that deal with programs.
<a href="part_prologue.html" data-pltdoc="x">Prologue</a> will sketches what this means and provides hints on how
to program effectively in this realm. The <a href="part_prologue.html" data-pltdoc="x">Prologue</a> is the
<span class="emph">only</span> part in which this book uses a programming language, Racket, which
is our second favorite one. Racket is a descendant of Lisp and therefore uses
lots of parentheses. Don&rsquo;t let this scare you off, the code is rather
conventional once you get over the parens. The point of using Racket is that you
learn to read code in programming languages that you aren&rsquo;t as familiar with as
your favorite one.</p><p>The presentation of ideas uses data-structure notation: representation of
statements and expressions, stacks, trees, and so on&#8212;<wbr></wbr>concepts needed to
express the states of abstract machines. As for transitions between states, the
book uses tables of <span class="emph">before</span> and <span class="emph">after</span> states. We expect that that
readers with basic programming skills can easily translate this notation into
into code for experimentation and exploration.</p><p><div class="SIntrapara">An auxiliary set of on-line notes shows how to turn the material in each
chapter into Racket code. Indeed, the notes present <span class="emph">four</span> different
implementation approaches to each part:
</div><div class="SIntrapara"><blockquote><table cellspacing="0" cellpadding="0" class="boxed"><tr><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p></p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p>class-based object-oriented</p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p>procedural or functional</p></td></tr><tr><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p>explicitly, statically typed</p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p></p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p></p></td></tr><tr><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p>dynamically (un)typed</p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p></p></td><td valign="top" width="280" style="border-collapse: collapse; border: 1px solid black; padding: 5px;"><p></p></td></tr></table></blockquote></div><div class="SIntrapara">The four approaches are representative of what programmers encounter in industry
today. Readers should first code up ideas in their favorite programming language.
Compare with one of our programs later; one of the four is likely to be
comparable.</div></p><p>Finally, we urge instructors to follow this approach, too. Students who use
their favorite language will appreciate this freedom, learn more (easily), and
relate concepts from class to a language they think they know deeply. In the
process that will discover how ideal principles become rough realities.</p><p>Additionally, we have found it highly educational to have some students
present solutions to weekly problem sets in class. Such presentations raise
the presenters&rsquo; technical articulation skills, and the audience learns to
read code in a potentially &ldquo;foreign&rdquo; language&#8212;<wbr></wbr> which is part of the
point of studying the principles of programming languages.</p><p>To accommodate this freedom of language choice, the book uses
<a href="https://json.org">JSON</a> as a data language for writing subject
programs. Every contemporary programming language comes with a library
for reading JSON and turning it into an internal data
structure&#8212;<wbr></wbr>parsing. From there, running the programs on abstract
machines is independent of their external representation.</p><p>The choice of JSON also allows the free exchange of test cases among
students. We routinely require students to submit test cases for a project and
then run all student solutions through all test cases. Students get extra credit
for submitting &ldquo;tricky&rdquo; test cases, an aspect that encourages students to
explore the project language in some depth.</p><h4><a name="(part._sec~3ainstructor)"></a>To the Instructor</h4><p>The book consists of ten chapters, plus a prologue. We strongly recommend
working through the Prologue in class <span class="emph">after</span> starting with the content of
chapter 1 as an introductory lecture.</p><p>The summary sections of chapters 2 through 10 come with a project that can be
used as a weekly homework assignment. Each chapter also assigns numerous
exercises that can supplement the project and/or be used to modify the
project. All of these exercises will help students understand the material in
the corresponding sections.</p><h4><a name="(part._sec~3aackn)"></a>Acknowledgment</h4><p>We, the authors, have spent several decades developing the research behind this
material. We have taught it in undergraduate, graduate, and professional
courses, and this teaching has greatly helped us improve this presentation. We
are grateful to everyone who suffered through these trials.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Machines and Programming Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_prologue.html" title="forward to &quot;Prologue&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
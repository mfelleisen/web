<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Church Rosser</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="thoughts.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Thoughts</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="technical">Church Rosser</span></a></td></tr><tr><td align="right"></td><td><a href="Science___Science.html" class="tocviewlink" data-pltdoc="x"><span class="personal">Science &amp; Science</span></a></td></tr><tr><td align="right"></td><td><a href="Modular_Programming.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Modular Programming</span></a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="The_Rational_Programmer.html" class="tocviewlink" data-pltdoc="x">The Rational Programmer</a></td></tr><tr><td align="right"></td><td><a href="The_Design_Recipe.html" class="tocviewlink" data-pltdoc="x"><span class="technical">The Design Recipe</span></a></td></tr><tr><td align="right"></td><td><a href="Apology.html" class="tocviewlink" data-pltdoc="x"><span class="personal">Apology</span></a></td></tr><tr><td align="right"></td><td><a href="All_As.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">All As</span></a></td></tr><tr><td align="right"></td><td><a href="Teaching_PL.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Teaching PL</span></a></td></tr><tr><td align="right"></td><td><a href="NSF.html" class="tocviewlink" data-pltdoc="x"><span class="politics">NSF</span></a></td></tr><tr><td align="right"></td><td><a href="The_Laffer_Curve_of_Types.html" class="tocviewlink" data-pltdoc="x"><span class="technical">The Laffer Curve of Types</span></a></td></tr><tr><td align="right"></td><td><a href="Referential_Transparency.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Referential Transparency</span></a></td></tr><tr><td align="right"></td><td><a href="Why_How_do_I_get_a_PhD.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Why/<span class="mywbr"> &nbsp;</span>How do I get a Ph<span class="mywbr"> &nbsp;</span>D</span></a></td></tr><tr><td align="right"></td><td><a href="Free_Speech.html" class="tocviewlink" data-pltdoc="x"><span class="politics">Free Speech</span></a></td></tr><tr><td align="right"></td><td><a href="Developing_Developers.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Developing Developers</span></a></td></tr><tr><td align="right"></td><td><a href="Growing_a_Programmer.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Growing a Programmer</span></a></td></tr><tr><td align="right"></td><td><a href="Unions_for_PhD_Students_.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Unions for Ph<span class="mywbr"> &nbsp;</span>D Students?</span></a></td></tr><tr><td align="right"></td><td><a href="Racket_is____.html" class="tocviewlink" data-pltdoc="x"><span class="technical"><span class="emph">Racket</span> is ...</span></a></td></tr><tr><td align="right"></td><td><a href="why-pl2.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Why teach Ph<span class="mywbr"> &nbsp;</span>D core courses, with programming languages</span></a></td></tr><tr><td align="right"></td><td><a href="Danger__unsafe_languages.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Danger:<span class="mywbr"> &nbsp;</span> unsafe languages</span></a></td></tr><tr><td align="right"></td><td><a href="What_should_the_core_achieve_.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">What should the core achieve?</span></a></td></tr><tr><td align="right"></td><td><a href="Python_for_Asset-Backed_Securities.html" class="tocviewlink" data-pltdoc="x"><span class="politics">Python for Asset-<wbr></wbr>Backed Securities</span></a></td></tr><tr><td align="right"></td><td><a href="Measuring_education.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Measuring education</span></a></td></tr><tr><td align="right"></td><td><a href="Refereed_conferences__not_.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Refereed conferences, not!</span></a></td></tr><tr><td align="right"></td><td><a href="what-is-pl.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Why teach programming languages</span></a></td></tr><tr><td align="right"></td><td><a href="_.html" class="tocviewlink" data-pltdoc="x"><span class="special">.</span></a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="technical">Church Rosser</span></a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="#%28part._.Church_and_.Rosser_.Prove_that_their_.Calculus_is_.Sound%29" class="tocviewlink" data-pltdoc="x">Church and Rosser Prove that their Calculus is <span class="emph">Sound</span></a></td></tr><tr><td align="right"></td><td><a href="#%28part._.From__-.Calculus_to_.Programming_.Languages%29" class="tocviewlink" data-pltdoc="x">From λ-<wbr></wbr>Calculus to Programming Languages</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Call-by-name__.Call-by-value_and_the__-calculus%29" class="tocviewlink" data-pltdoc="x">Call-<wbr></wbr>by-<wbr></wbr>name, Call-<wbr></wbr>by-<wbr></wbr>value and the λ-<wbr></wbr>calculus</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.What_is_the_.Role_of_.Church-.Rosser_in_this_.Context_%29" class="tocviewlink" data-pltdoc="x">What is the Role of Church-<wbr></wbr>Rosser in this Context?</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.What_is_.The_.Truth_%29" class="tocviewlink" data-pltdoc="x">What is The Truth?</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Don_t_.We_.Want_.Equations_for_.Optimizing_.Compilers_%29" class="tocviewlink" data-pltdoc="x">Don&rsquo;t We Want Equations for Optimizing Compilers?</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Don_t_.We_then_.Get_.Nondeterministic_.Compilers_%29" class="tocviewlink" data-pltdoc="x">Don&rsquo;t We then Get Nondeterministic Compilers?</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Is_it_a_.Good_.Idea_to_.Define_a_.Semantics_via_.Church-style_.Axioms_%29" class="tocviewlink" data-pltdoc="x">Is it a Good Idea to Define a Semantics via Church-<wbr></wbr>style Axioms?</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.And_.What_.About_.Nondeterminism_%29" class="tocviewlink" data-pltdoc="x">And What About Nondeterminism?</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Church_and_.Rosser_.Prove_that_their_.Calculus_is_.Sound%29" class="tocsubseclink" data-pltdoc="x">Church and Rosser Prove that their Calculus is <span class="emph">Sound</span></a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.From__-.Calculus_to_.Programming_.Languages%29" class="tocsubseclink" data-pltdoc="x">From λ-<wbr></wbr>Calculus to Programming Languages</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Call-by-name__.Call-by-value_and_the__-calculus%29" class="tocsubseclink" data-pltdoc="x">Call-<wbr></wbr>by-<wbr></wbr>name, Call-<wbr></wbr>by-<wbr></wbr>value and the λ-<wbr></wbr>calculus</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.What_is_the_.Role_of_.Church-.Rosser_in_this_.Context_%29" class="tocsubseclink" data-pltdoc="x">What is the Role of Church-<wbr></wbr>Rosser in this Context?</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.What_is_.The_.Truth_%29" class="tocsubseclink" data-pltdoc="x">What is The Truth?</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Don_t_.We_.Want_.Equations_for_.Optimizing_.Compilers_%29" class="tocsubseclink" data-pltdoc="x">Don&rsquo;t We Want Equations for Optimizing Compilers?</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Don_t_.We_then_.Get_.Nondeterministic_.Compilers_%29" class="tocsubseclink" data-pltdoc="x">Don&rsquo;t We then Get Nondeterministic Compilers?</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Is_it_a_.Good_.Idea_to_.Define_a_.Semantics_via_.Church-style_.Axioms_%29" class="tocsubseclink" data-pltdoc="x">Is it a Good Idea to Define a Semantics via Church-<wbr></wbr>style Axioms?</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.And_.What_.About_.Nondeterminism_%29" class="tocsubseclink" data-pltdoc="x">And What About Nondeterminism?</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.14.0.2</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Thoughts&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Thoughts&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Science___Science.html" title="forward to &quot;Science &amp; Science&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h3 class="heading"><a name="(part._.Church_.Rosser)"></a><span class="technical">Church Rosser</span><span class="button-group"><a href="#(part._.Church_.Rosser)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Matthias Felleisen</p></span></div><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Jun 2 2024</p></blockquote></blockquote></blockquote><p class="SHistory">Changed in version 1.0: Sun Jun  2 14:04:32 EDT 2024, initial release</p><p>Over the past couple of months, several people have brought up the Church-Rosser
property in conversation, and I was somewhat amazed at the uninformed opinions
that these people reported.</p><p>As someone who has worked out his fair share of Church-Rosser theorems for
several variants of &#955;-calculus-based language , I figured I would write down
what I learned in this regard over the course of 40 years.</p><h4 class="heading"><a name="(part._.Church_and_.Rosser_.Prove_that_their_.Calculus_is_.Sound)"></a>Church and Rosser Prove that their Calculus is <span class="emph">Sound</span><span class="button-group"><a href="#(part._.Church_and_.Rosser_.Prove_that_their_.Calculus_is_.Sound)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Neither Church nor Rosser designed a programming language.  The &#955;-calculus per
se is a programming language only as much as Turing machines are. So when
someone says &ldquo;people in 1936 knew how to deal with property X in programming
languages via the Church-Rosser theorem&rdquo; then this statement is (1)
anachronistic and (2) wrong as history showed 40 years later.</p><p><div class="SIntrapara">Church and Rosser understood that writing down <span style="font-style: italic">n</span> axioms <span style="font-style: italic">A</span> to
generate an equational proof system did not imply that working out proofs in
this system would make sense. They had to show that
</div><div class="SIntrapara"><blockquote class="SCentered"><p>&lsquo;A &#8866; true = false&rsquo; is impossible.</p></blockquote></div><div class="SIntrapara">Because once we can prove this equation, we can prove every other equation. But,
a proof system is about discriminating falsehoods from truths, so we don&rsquo;t want
this equation.</div></p><p>A proof system that validates only true statements is <span class="emph">sound</span>.</p><p>Church and his colleagues had come up with several such systems, which
Barendregt (North Holland, 1980) labels as &#955;I, &#955;K, &#955;&#946;, &#955;&#946;&#951;, and so on.  Also,
orienting these axioms into notions of reduction generates the same set of
equations as using a plain proof system starting from equational axioms.</p><h4 class="heading"><a name="(part._.From__-.Calculus_to_.Programming_.Languages)"></a>From &#955;-Calculus to Programming Languages<span class="button-group"><a href="#(part._.From__-.Calculus_to_.Programming_.Languages)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>In the late 1950s and 1960s our colleagues started to realize that the
&#955;-calculus is an interesting basis for discussing aspects of programming
languages. One aspect was scope; when is a variable occurrence <span style="font-style: italic">x</span> bound by
a <span style="font-style: italic">&#955; x.</span> in its context&#8212;<wbr></wbr>or what is lexical scope vs dynamic
scope. Another one is language syntax; why not include functions as values in a
programming language and mark them with the keyword &#955; or <span style="font-weight: bold">lambda</span>. Once
Scott had figured out how to construct a mathematical model <span class="refelem"><span class="refcolumn"><span class="refcontent">For a
short while, PL mistook Scott domains as The Truth behind &#955;-calculus, but the
equations valid in typical Scott domains are also just a part of The Truth. See
below.</span></span></span> of the syntactic &#955;-calculus, Strachey could use the &#955; notation as a
framework for writing down a semantics of (pieces of) existing programming
laguages&#8212;<wbr></wbr>but the meta-notation really just referred to elements of
domains. (Yes, this is where store-passing and continuation-passing comes from,
as well as plain &ldquo;direct&rdquo; semantics.)</p><p>And finally, Bohem, McCarthy, Landin, Reynolds, Morris, and others decided to
design programming languages directly based on the &#955;-calculus. They added
literal constants and libraries of functions, plus various conditionals and
other forms. They were clever in explaining the meaning of their programs: they
used <span class="emph">evaluation functions</span> (interpreters) often based on abstract
machines; Landin&rsquo;s SECD machine is a well-known example.</p><p>Notably they did <span class="emph">not</span> use Church&rsquo;s axioms to specify
the semantics of their designs.</p><h4 class="heading"><a name="(part._.Call-by-name__.Call-by-value_and_the__-calculus)"></a>Call-by-name, Call-by-value and the &#955;-calculus<span class="button-group"><a href="#(part._.Call-by-name__.Call-by-value_and_the__-calculus)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>This last step&#8212;<wbr></wbr>designing languages based on &#955; but using abstract machines to
define the semantics&#8212;<wbr></wbr>raises the obvious question how these languages relate
to the systems of equations generated by Church&rsquo;s axioms.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Algol&rsquo;60 implements call-by-value as a compiler transformation,
adding an assignment statement to the parameter at the entry of the procedure.</span></span></span>
The question had become interesting because some language designs used
Algol&rsquo;60&rsquo;s call-by-name regime, evaluating argument expressions for every
parameter occurrence.  Others used call-by-value, meaning the argument
expression was evaluated once and for all to a value before the actual function
call took place.</p><p><div class="SIntrapara">Plotkin (1975, TCS) answered this question in a definitive manner. Here is the
essence of his finding:
</div><div class="SIntrapara"><ul><li><p>it is possible to define the meaning of a language via
a set of Church-style axioms;</p></li><li><p>but, these notions of reduction are not <span class="emph">the</span> semantics;</p></li><li><p>the semantics is a function from programs to values,
meaning it is always necessary to identify the subset of
values in a language&rsquo;s set of expressions;</p></li><li><p>different systems of axioms define different evaluation functions;</p></li><li><p>one system of axioms (<span style="font-style: italic">&#955;</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">n</span></span><span style="font-style: italic"></span>), similar to Church&rsquo;s, defines what language researchers
label a language with a call-by-<span class="emph">name</span> convention;</p></li><li><p>a different set of axioms (<span style="font-style: italic">&#955;</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">v</span></span><span style="font-style: italic"></span>) defines what language researchers
label a language with a call-by-<span class="emph">value</span> convention;</p></li><li><p>the functions defined via sets of axioms (notions of reduction) are equal to
the functions defined by abstract machines that implement the various call-by
regimes.</p></li></ul></div></p><h4 class="heading"><a name="(part._.What_is_the_.Role_of_.Church-.Rosser_in_this_.Context_)"></a>What is the Role of Church-Rosser in this Context?<span class="button-group"><a href="#(part._.What_is_the_.Role_of_.Church-.Rosser_in_this_.Context_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><span class="refelem"><span class="refcolumn"><span class="refcontent">To extract an efficient evaluation function, Plotkin proves that
both calculi also satisfy the Curry-Feys Standardization property.</span></span></span>
A semantics generated from notions of reduction is a relation. To prove that it
is a function&#8212;<wbr></wbr>that evaluating the same program on the same input consistently
produces the same result&#8212;<wbr></wbr>requires a mathematical proof.</p><p>One of several lemmas in this proof is a variant of Church and Rosser&rsquo;s lemma.
That&rsquo;s it.</p><h4 class="heading"><a name="(part._.What_is_.The_.Truth_)"></a>What is The Truth?<span class="button-group"><a href="#(part._.What_is_.The_.Truth_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>From Church and Rosser&rsquo;s work, we know that &#955; &#8866; <span style="font-style: italic">e = e</span>&prime;<span style="font-style: italic"></span> is a proof that
<span style="font-style: italic">e = e</span>&prime;<span style="font-style: italic"></span> is a true statement. But what is The Truth in the context of
programming languages?</p><p>Following Morris&rsquo;s dissertation (MIT 1968), Plotkin goes on to define
<span class="emph">observational equivalence</span> for each semantics, a congruent equivalence
relation on expressions.  Two expressions <span style="font-style: italic">e</span> and <span style="font-style: italic">e</span>&prime;<span style="font-style: italic"></span> are
observationally equal, written <span style="font-style: italic">e &#8776; e</span>&prime;<span style="font-style: italic"></span>, if after plugging <span style="font-style: italic">e</span> and
<span style="font-style: italic">e</span>&prime;<span style="font-style: italic"></span> into any arbitrary program context <span style="font-style: italic">C</span>&#8212;<wbr></wbr>an expression with a
hole&#8212;<wbr></wbr>the evaluation function applied to the programs <span style="font-style: italic">C</span>[<span style="font-style: italic">e</span>]<span style="font-style: italic"></span> and
<span style="font-style: italic">C</span>[<span style="font-style: italic">e</span>&prime;<span style="font-style: italic"></span>]<span style="font-style: italic"></span> yields the same outcome.</p><p>Observational equivalence is the largest such relation, and as such it is
recognized as The Truth.  The Truth for any programming language is vastly
larger than the set of equations of an axiomatic syntactic calculus. Indeed, The
Truth for such &#955;-ish languages cannot be axiomatized. Period.</p><h4 class="heading"><a name="(part._.Don_t_.We_.Want_.Equations_for_.Optimizing_.Compilers_)"></a>Don&rsquo;t We Want Equations for Optimizing Compilers?<span class="button-group"><a href="#(part._.Don_t_.We_.Want_.Equations_for_.Optimizing_.Compilers_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Sure. We want <span class="emph">true</span> equations in the compiler. A &#955;-style calculus might be
one way to validate such equations. But, given that
</div><div class="SIntrapara"><ul><li><p>The Truth (<span style="font-style: italic">e &#8776; e</span>&prime;<span style="font-style: italic"></span>) is so much larger than this one particular proof
system (&#955; &#8866; <span style="font-style: italic">e &#8776; e</span>&prime;<span style="font-style: italic"></span>),</p></li><li><p>and we want powerful optimizing passes,</p></li></ul></div><div class="SIntrapara">the axioms play a minor role in the design of an optimizing compiler.</div></p><p>Instead, weq want as many true equations <span style="font-style: italic">e &#8776; e</span>&prime;<span style="font-style: italic"></span> turned into
transformations <span style="font-style: italic">e &#10230; e</span>&prime;<span style="font-style: italic"></span> if they can somehow improve the performance of a
program (without changing its outcome). So what we really want are proof
techniques for establishing The Truth between two expressions, one improving on
the other.</p><p>Church-Rosser and notions of reductions are too simplistic for this job.</p><p>Use denotational semantics if you want lots of equations.  Use logical relations
to validate your favorite transformations. Use bisimulations. Use any proof
technique that works.</p><p>Church-Rosser for axioms of notions of reduction is way too weak.</p><h4 class="heading"><a name="(part._.Don_t_.We_then_.Get_.Nondeterministic_.Compilers_)"></a>Don&rsquo;t We then Get Nondeterministic Compilers?<span class="button-group"><a href="#(part._.Don_t_.We_then_.Get_.Nondeterministic_.Compilers_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Yes.</p><p>Depending on when a transformation kicks in, we get different object code. But
because they are validated elements of The Truth, running any of these outcomes
produces the same value.</p><p>And that&rsquo;s true in reality. I conjecture that all large compilers are
non-deterministic translators.</p><h4 class="heading"><a name="(part._.Is_it_a_.Good_.Idea_to_.Define_a_.Semantics_via_.Church-style_.Axioms_)"></a>Is it a Good Idea to Define a Semantics via Church-style Axioms?<span class="button-group"><a href="#(part._.Is_it_a_.Good_.Idea_to_.Define_a_.Semantics_via_.Church-style_.Axioms_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>No.</p><p>Ploktin&rsquo;s work shows that we want an evaluation function first. Define it via an
abstract machine. Use relations on the surface syntax. Write an interpreter. But
define the function first.</p><p>If, for some reason, you want a simple calculus such as &#955;, develop it
<span class="emph">after</span> you have worked out the semantic function. Then use Church-Rosser
to prove consistency of the reduction-axiom-based function and the original
one.</p><p><div class="SIntrapara">Does this really work? Yes. Starting in 1985, I followed this program, developed
&#955;-style systems for existing semantics, and proved a Church-Rosser theorem for
these calculi:
</div><div class="SIntrapara"><ol><li><p>for call/cc-style continuations (LICS &rsquo;86, with Kohlbecker, Duba, and Friedman);</p></li><li><p>a simpler calculus than the one in item 1 (TCS &rsquo;92, with Hieb);</p></li><li><p>for delimited continuations (POPL &rsquo;88);</p></li><li><p>for assignable variables in a &#955;-calculus-based language (POPL &rsquo;87, with Friedman);</p></li><li><p>a simpler calculus than the one in item 4 (TCS &rsquo;92, with Hieb);</p></li><li><p>for a language with exceptions (Info &amp; Comp &rsquo;94, with Wright); and</p></li><li><p>for call-by-need (JFP &rsquo;97, with Ariola; ESOP &rsquo;12, with Chang).</p></li></ol></div><div class="SIntrapara">Items 2, 5, and 7 really show that Church-Rosser is a brittle syntatic property,
and we can come up with several different axiom system, for each of which it is
more or less elegant to prove Church-Rosser.</div></p><p>I also had one for futures (POPL &rsquo;95, with Flanagan; but it&rsquo;s not in the paper).</p><h4 class="heading"><a name="(part._.And_.What_.About_.Nondeterminism_)"></a>And What About Nondeterminism?<span class="button-group"><a href="#(part._.And_.What_.About_.Nondeterminism_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>A nondeterministic language may evaluate the same program (and input) to distinct
values. The semantics is <span class="emph">not</span> a function but a relation.</p><p>Designing a Church-Rosser calculus for such a language should be possible, using
reduction on sets instead of expressions directly. But, this is just a boring
exercise in proving some people wrong about the relationship between
Church-Rosser and programming-language research. I don&rsquo;t have time for this and
there aren&rsquo;t enough bits in this laptop to write the proof down in the margin.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Thoughts&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Thoughts&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Science___Science.html" title="forward to &quot;Science &amp; Science&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
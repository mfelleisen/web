<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>The Laffer Curve of Types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="thoughts.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Thoughts</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="Modular_Programming.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Modular Programming</span></a></td></tr><tr><td align="right"></td><td><a href="trp.html" class="tocviewlink" data-pltdoc="x"><span class="technical">The Rational Programmer</span></a></td></tr><tr><td align="right"></td><td><a href="The_Design_Recipe.html" class="tocviewlink" data-pltdoc="x"><span class="technical">The Design Recipe</span></a></td></tr><tr><td align="right"></td><td><a href="Apology.html" class="tocviewlink" data-pltdoc="x"><span class="personal">Apology</span></a></td></tr><tr><td align="right"></td><td><a href="All_As.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">All As</span></a></td></tr><tr><td align="right"></td><td><a href="Teaching_PL.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Teaching PL</span></a></td></tr><tr><td align="right"></td><td><a href="NSF.html" class="tocviewlink" data-pltdoc="x"><span class="politics">NSF</span></a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="technical">The Laffer Curve of Types</span></a></td></tr><tr><td align="right"></td><td><a href="Referential_Transparency.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Referential Transparency</span></a></td></tr><tr><td align="right"></td><td><a href="Why_How_do_I_get_a_PhD.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Why/<span class="mywbr"> &nbsp;</span>How do I get a Ph<span class="mywbr"> &nbsp;</span>D</span></a></td></tr><tr><td align="right"></td><td><a href="Free_Speech.html" class="tocviewlink" data-pltdoc="x"><span class="politics">Free Speech</span></a></td></tr><tr><td align="right"></td><td><a href="Developing_Developers.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Developing Developers</span></a></td></tr><tr><td align="right"></td><td><a href="Growing_a_Programmer.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Growing a Programmer</span></a></td></tr><tr><td align="right"></td><td><a href="Unions_for_PhD_Students_.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Unions for Ph<span class="mywbr"> &nbsp;</span>D Students?</span></a></td></tr><tr><td align="right"></td><td><a href="Racket_is____.html" class="tocviewlink" data-pltdoc="x"><span class="technical"><span class="emph">Racket</span> is ...</span></a></td></tr><tr><td align="right"></td><td><a href="why-pl2.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Why teach Ph<span class="mywbr"> &nbsp;</span>D core courses, with programming languages</span></a></td></tr><tr><td align="right"></td><td><a href="Danger__unsafe_languages.html" class="tocviewlink" data-pltdoc="x"><span class="technical">Danger:<span class="mywbr"> &nbsp;</span> unsafe languages</span></a></td></tr><tr><td align="right"></td><td><a href="What_should_the_core_achieve_.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">What should the core achieve?</span></a></td></tr><tr><td align="right"></td><td><a href="Python_for_Asset-Backed_Securities.html" class="tocviewlink" data-pltdoc="x"><span class="politics">Python for Asset-<wbr></wbr>Backed Securities</span></a></td></tr><tr><td align="right"></td><td><a href="Measuring_education.html" class="tocviewlink" data-pltdoc="x"><span class="curriculum">Measuring education</span></a></td></tr><tr><td align="right"></td><td><a href="Refereed_conferences__not_.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Refereed conferences, not!</span></a></td></tr><tr><td align="right"></td><td><a href="what-is-pl.html" class="tocviewlink" data-pltdoc="x"><span class="sci-pol">Why teach programming languages</span></a></td></tr><tr><td align="right"></td><td><a href="_.html" class="tocviewlink" data-pltdoc="x"><span class="special">.</span></a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="technical">The Laffer Curve of Types</span></a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="#%28part._.The_.Original_.Laffer_.Curve_.Story%29" class="tocviewlink" data-pltdoc="x">The Original Laffer Curve Story</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Applying_the_.Laffer_.Curve__.Story__to_.Types_and_.Type_.Systems%29" class="tocviewlink" data-pltdoc="x">Applying the Laffer Curve (Story) to Types and Type Systems</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Expressiveness_and_.Effectiveness_in_.Migratory_.Typing%29" class="tocviewlink" data-pltdoc="x">Expressiveness and Effectiveness in Migratory Typing</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.We_.Need_a_.Laffer_.Curve_of_.Migratory_.Typing%29" class="tocviewlink" data-pltdoc="x">We Need a Laffer Curve of Migratory Typing</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.The_.Original_.Laffer_.Curve_.Story%29" class="tocsubseclink" data-pltdoc="x">The Original Laffer Curve Story</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Applying_the_.Laffer_.Curve__.Story__to_.Types_and_.Type_.Systems%29" class="tocsubseclink" data-pltdoc="x">Applying the Laffer Curve (Story) to Types and Type Systems</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Expressiveness_and_.Effectiveness_in_.Migratory_.Typing%29" class="tocsubseclink" data-pltdoc="x">Expressiveness and Effectiveness in Migratory Typing</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.We_.Need_a_.Laffer_.Curve_of_.Migratory_.Typing%29" class="tocsubseclink" data-pltdoc="x">We Need a Laffer Curve of Migratory Typing</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.4.0.4</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="NSF.html" title="backward to &quot;NSF&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Thoughts&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Referential_Transparency.html" title="forward to &quot;Referential Transparency&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._.The_.Laffer_.Curve_of_.Types)"></a><span class="technical">The Laffer Curve of Types</span></h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Matthias Felleisen</p></span></div><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Apr 21 2019</p></blockquote></blockquote></blockquote><p class="SHistory">Changed in version 1.4: Sat May 18 12:29:49 EDT 2019,
<br/> <span class="hspace">&nbsp;&nbsp;&nbsp;</span> feedback and types from Robby</p><p class="SHistory">Changed in version 1.3: Tue Apr 30 14:14:45 EDT 2019,
<br/> <span class="hspace">&nbsp;&nbsp;&nbsp;</span> Shriram proposed  eliminating language potentially offending to liberals</p><p class="SHistory">Changed in version 1.2: Mon Apr 29 10:20:00 EDT 2019, prelude</p><p><div class="SIntrapara"><p class="SHistory">Changed in version 1.1: Wed Apr 24 12:41:46 EDT 2019, feedback and typos from
<br/> <span class="hspace">&nbsp;&nbsp;&nbsp;</span> Sam Caldwell
<br/> <span class="hspace">&nbsp;&nbsp;&nbsp;</span> Ben Greenman</p></div><div class="SIntrapara"><p class="SHistory">Changed in version 1.0: Sat Apr 13 19:06:32 EDT 2019, initial release</p></div></p><p><span style="font-weight: bold">Acknowledgments</span> This &rsquo;thought&rsquo; benefited a lot from talking to Sam
Tobin-Hochstadt, Asumu Takikawa, and Ben Greenman, PhD students who
directly worked on Typed Racket with me. Ben also commented on an early
draft of this write-up.</p><p><span style="font-weight: bold">Prelude</span></p><blockquote><p>&ldquo;I started with Typed Racket, but I found hard to freely explore while
having to satisfy the compiler.&rdquo; &ndash; Guimaraes Wanderley on
the Racket Users mailing list on April 28, 2019</p></blockquote><p>Dynamically typed programming languages are here to stay, whether
programming language researchers like it or not. What we can do is help
people migrate from that world to the typed one, once they know they wish
to keep and maintain some code.</p><p><span style="font-weight: bold">The Idea</span> Most of my research colleagues think of types as a language
of theorems about the expressions of a program language and the type system
as a proof system that proves type-theorems about expressions in a
particular program. These people are also trained as proto-logicians, and
thus they immediately turn to soundness when they are confronted with a new
typed programming language.</p><p>Over the past 20 or so years, I have slowly changed my mind about
soundness. While I still appreciate its relevance, I have come to think of it as
only one of several equally important questions. The problem is that the other
questions are much more difficult to answer.</p><p>Work on <a href="https://www2.ccs.neu.edu/racket/pubs/#typed-racket"><span class="emph">migratory typing</span></a> changed my mind.
<span class="refelem"><span class="refcolumn"><span class="refcontent">I prefer <span class="emph">migratory typing</span> over <span class="emph">gradual typing</span>, even
though the latter is clearly a better marketing slogan.</span></span></span>  I started working on
this topic in 1998 (after working on soft typing for the previous eight or nine
years). Through the design of a migratory type system, I have come to consider
type system design as an exercise in engineering, specifically engineering the
interface between programming languages and human beings (HLI).</p><p>In search of assessment methods for the quality of the type systems, I have come
across the Laffer curve and its origin story. All of us programming language
researchers know the idea behind the Laffer curve from engineering and
mathematics courses. Concisely, engineering is an optimization process, that is,
the maximization of some function subject to constraints. The Laffer curve
spells out this insight for the vague discipline of economics. Since type-system
design is equally vague at this point, I think we can learn a lot form this
analogy.</p><p><span class="emph">Note</span> I have explained the ideas in this &ldquo;thought&rdquo; to a small
number of visitors over the years. Many of these academics dismiss the
Laffer curve simply because it is associated with economic policies favored
by conservatives. Most don&rsquo;t even know that President Kennedy also
proposed a tax rate decrease to stimulate the economy and increase the tax
income of the federal government but without public reference to this
curve. So just because &ldquo;they&rdquo; thought of it does not mean it may not come
with a kernel of truth; just as much as liberal ideas about taxation may
also say something acceptable.</p><h4><a name="(part._.The_.Original_.Laffer_.Curve_.Story)"></a>The Original Laffer Curve Story</h4><p>The Laffer curve of taxation dates back centuries. It became widely known
under this name in the 1980s when US President Reagan&rsquo;s economists based
their proposal for tax rate decreases on this idea. <a href="https://en.wikipedia.org/wiki/Laffer_curve#Origin">Rumor</a>
has it that Laffer, an economist, explained the idea on a napkin over a
dinner with members of President Ford&rsquo;s White House staff, and that a
<span class="emph">Wall Street Journal</span> journalist present during dinner named the
drawing &ldquo;Laffer curve.&rdquo;</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="pict_13.png" alt="image" width="150.0" height="150.0"/>
<img src="pict_14.png" alt="image" width="150.0" height="150.0"/>
<img src="pict_15.png" alt="image" width="150.0" height="150.0"/>
<img src="pict_16.png" alt="image" width="150.0" height="150.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atax))" x-target-lift="Figure"></a>Figure&nbsp;20: </span>The Laffer Curve of Taxation</span></p></blockquote><p>Simplistically the idea goes as follows. If a government reduces the tax rate to
<span style="font-style: italic"></span>0<span style="font-style: italic">%</span>, its tax income will be <span style="font-style: italic">$</span>0<span style="font-style: italic"></span>. Along similar lines, if the
government imposes a <span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic">%</span> tax rate, people will refuse to work, won&rsquo;t
earn any income, and won&rsquo;t pay taxes. This suggests the left-most graph in
<a href="#%28counter._%28figure._fig~3atax%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">20</span></a> with the two red dots on the <span style="font-style: italic">x</span> axis recording these
first two observations about the function of income over rates. The next graph
records the evidence that a tax rates in the middle between these two
extremes actually produces a positive income for the government.  Laffer seems
to have drawn a simple-minded upside-down parabola through these points and
suggested that raising tax rates beyond a certain point <span class="emph">decreases</span> the tax
income of the government.</p><p>The right-most graph represents the thoughts of a mathematician who may or may
not have any insights into taxation. First, the red dot on the right should not
be on the <span style="font-style: italic">x</span> axis because people will work even if the government imposes
a <span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic">%</span> tax rate. In return for giving up their entire income, they might
receive sufficiently large hand-outs to survive. Or, their work might not be
motivated by income; we all know such people.  Second, there is no reason to
believe that there is a single maximum; the curve might have several local
maxima.</p><p><span class="emph">Note</span> What the last graph does not bring across is that the income
function might not even be continuous with respect to tax rates. Indeed,
what&rsquo;s worse is that the shape of the curve may change over time as people
adjust to tax systems and economic conditions.&#8212;<wbr></wbr>But this
thought isn&rsquo;t about the Laffer curve per se, so let&rsquo;s move on.</p><p><span class="emph">The Idea</span> One of the big problems with the Laffer function-curve is
that we have little evidence to articulate it properly. A second problem is
that it is too uni-dimensional; it relates two pieces of information,
leaving out elements that policy makers of various stripes wish to factor
into their decisions, too. So anybody who wishes to use the vague curve for
some action on tax rates may do so with imagined arguments. Although I
doubt that a truly precise and universal formulation is possible,
improving the existing evidence could usefully inform policy makers.</p><p>The point of my &ldquo;thought&rdquo; is that the discipline of programming language
design is in a similar position, and my goal is to spell out some ideas on
this state of affairs for a small sub-area of recent interest (mine and
that of many other academic and industrial researchers).</p><h4><a name="(part._.Applying_the_.Laffer_.Curve__.Story__to_.Types_and_.Type_.Systems)"></a>Applying the Laffer Curve (Story) to Types and Type Systems</h4><p>Now let&rsquo;s replace &ldquo;tax&rdquo; with &ldquo;type system,&rdquo; &ldquo;rate&rdquo; with
&ldquo;expressiveness,&rdquo; and &ldquo;income&rdquo; with &ldquo;effectiveness.&rdquo;</p><p>The design of a static type system often comes with claims that it
identifies and eliminates potentially erroneous program. I have often
referred to this as the &ldquo;negative&rdquo; expressive power of a type system.
For this section and the next, I am going to adopt this view, but as
<a href="https://www2.ccs.neu.edu/racket/pubs/#scp91-felleisen">my paper on expressiveness</a> points out, power always comes
with two sides&#8212;<wbr></wbr>positive and negative&#8212;<wbr></wbr>and I am going to broaden this
view for the final two sections.</p><p>With &ldquo;expressiveness&rdquo; of a type system tentatively clarified, let me turn
to &ldquo;effectiveness,&rdquo; which has several different aspects. At a minimum,
effectiveness covers the prevention of run-time exceptions and
measures the ease to get programs to run and run fast enough. The two ideas
are in conflict, as making type systems more effective comes at the expense
of making them easily usable.</p><p>It&rsquo;s all pretty vague but it allows me to begin drawing fragments of the
Laffer curves of types:</p><blockquote class="SCentered"><p><img src="pict_17.png" alt="image" width="150.0" height="150.0"/></p></blockquote><p>The left-most point represents dynamic typing, which tags all values and
uses these tags to check at run time whether a primitive operation may
operate on some given arguments.  In this world, there is only one
expressible &ldquo;theorem&rdquo; and all expressions satisfy it. Of course, such a
simplistic type system does not prevent any run-time exceptions, so we
should not consider it an effective type system. By contrast, there is an
&ldquo;extremist&rdquo; type system that is guaranteed to identify all potentially
erroneous programs, and it is represented by the red dot on the right. It
simply doesn&rsquo;t bless <span class="emph">any</span> programs as correct, meaning no program is
ever allowed to run. Hence, it is appropriate to assign this type system a
score of <span style="font-style: italic"></span>0<span style="font-style: italic"></span> effectiveness, too, because effectiveness also implies
&ldquo;getting programs to run easily.&rdquo;</p><p>Empirical evidence suggests that there are effective type systems. Let&rsquo;s record
this observation as red dots between the two extreme one:</p><blockquote class="SCentered"><p><img src="pict_18.png" alt="image" width="150.0" height="150.0"/></p></blockquote><p>For example, many programmers consider Java&rsquo;s type system an improvement over
C++&rsquo;s. Similarly, type system experts think of Haskell&rsquo;s type system as yet more
effective than Java&rsquo;s. But also note that far fewer programmers master Haskell&rsquo;s
type system than Java&rsquo;s, so it isn&rsquo;t just all pluses and no minuses.</p><p>In short, we may wish to imagine the graph of the effectiveness function of
types as follows:</p><blockquote class="SCentered"><p><img src="pict_19.png" alt="image" width="150.0" height="150.0"/></p></blockquote><p>It ignores the stupid type system that prevents all programs from running. Thus,
its right-most red dot is placed a bit above the <span style="font-style: italic">x</span> axis. Think of a
refinement or a dependent type system that is effective in preventing almost all
run-time exceptions. But, because such a type system also imposes a much higher
burden on the developer than Java&rsquo;s or even Haskell&rsquo;s, the pay-off is much lower
than for those and the dot is below theirs.</p><h4><a name="(part._.Expressiveness_and_.Effectiveness_in_.Migratory_.Typing)"></a>Expressiveness and Effectiveness in Migratory Typing</h4><p>The design of a migratory typing system has, among others, the same goal in
mind as that of static type systems, but it does not start from a blank
state. Instead the designers must study how programmers have used the
dynamically typed language to which they are adding types. These
programmers don&rsquo;t just create code in a willy-nilly fashion; they think
about it, and any observant researcher can recognize type-like reasoning in
these programs. <span class="refelem"><span class="refcolumn"><span class="refcontent">Also see <a href="https://medium.com/@samth/on-typed-untyped-and-uni-typed-languages-8a3b4bedf68c">Sam Tobin-Hochstadt&rsquo;s</a>
explanation.</span></span></span> Hence the designers of migratory type systems must ask what
&ldquo;expressiveness&rdquo; and &ldquo;effectiveness&rdquo; mean in the context of migratory
typing and how they are related.</p><p><span style="font-weight: bold">Expressiveness</span></p><p>If we accept that developers working with dynamically typed languages use
type-like reasoning, the purpose of adding a migratory type system is to
turn (possibly un)documented type annotations into explicit ones and to
check them. Here is a simple example from the <a href="https://docs.racket-lang.org/ts-guide/">(Typed) Racket</a>
world:</p><p><table cellspacing="0" cellpadding="0"><tr><td valign="top"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename">untyped.rkt</span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.plt-scheme.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.plt-scheme.org/reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Natural -&gt; Natural </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">the factorial function </span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></td><td valign="top"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename">typed.rkt</span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.plt-scheme.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.plt-scheme.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktSym">typed/rackunit</span></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">:</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">!</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types-extra..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="RktPn">)</span></span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">the factorial function </span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.plt-scheme.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></td></tr></table></p><p>On the left we see how a <a href="https://www.htdp.org">conscientious</a> Racket
programmer writes the factorial function, with an unchecked but documented type
signature, a basic comment, and an example formulated as a unit test. The right
side shows how little has to change to turn this module into a fully typed and
type-checked one.</p><p>The example demonstrates two important points.  First, the type of this
factorial function uses <span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span>, not just <span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span>. Second, the function
definition does not have to change for the type checker to bless the
module. This precision and this simplicity do not come for free,
however. We, the designers of Typed Racket, intentionally provide <span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span>
and a whole set-based hierarchy of numeric types. Also, our type system
checks <span class="RktSym"><a href="http://docs.plt-scheme.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span> expressions so as to confirm the induction scheme for
<span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span> and similar set-based type definitions.</p><p>A different team of designers might not have bothered with support for
<span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span>. They might have expected programmers to switch to
<span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Integer%29%29" class="RktStxLink" data-pltdoc="x">Integer</a></span>. Similarly, such a team might not have added a modicum of dependent
typing to avoid the need for Java-like casts in the branches of an
<span class="RktSym"><a href="http://docs.plt-scheme.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29" class="RktStxLink" data-pltdoc="x">if</a></span> expression that discerns the different parts of a union type.</p><blockquote><p><span style="font-weight: bold">Research Results</span> For Typed Racket, we adopt metrics to make the
above observations measurable. For example, we report for a substantial
corpus of Racket programs how many type annotations have to be added to
migrate the code, how many lines of code have to change to accommodate the
type checker, and so on. These numeric results significantly differ between
the functional part of Racket and the object-oriented one, suggesting that
migrating the former will be much easier than the latter.</p><p>At first glance, these results may suggest that more expressiveness is
better for migration but this clearly isn&rsquo;t obviously true. Using <span class="RktSym"><a href="http://docs.plt-scheme.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Natural%29%29" class="RktStxLink" data-pltdoc="x">Natural</a></span> as
the input type for <span class="stt">!</span> means that programmers may have to write
additional code to accommodate the type checker when they wish to use the
function. More generally, numeric code may often fail to type check for
obscure syntactic reasons, with one code variant working well and another
one not working out at all. Shriram Krishnamurthi noticed this tension
first and responded with the design of a <a href="http://cs.brown.edu/research/plt/dl/progressive-types/progressive-types.pdf">progressive type
system</a>. I consider this work a symptom of the flaws of the &ldquo;more
expressiveness is better&rdquo; perspective on expressiveness.</p></blockquote><p><span style="font-weight: bold">Granularity</span></p><p>So let&rsquo;s say we belong to a team that owns a code base written in some
dynamically typed language and wishes to migrate this code to a typed sister
language.</p><p>If the code were in Typed Racket, our developers would have to add type
annotations to entire modules at once.  I coined the phrase <span class="emph">macro</span>
migratory typing for this degree of granularity.</p><p>The designers of <a href="https://github.com/mvitousek/reticulated">Reticulated Python</a>, Siek and Vitousek,
made a rather different choice, and I refer to this as the <span class="emph">micro</span>
approach to migratory typing. Reticulated allows developers to annotate
individual function and method parameters, their return types, individual
fields in classes, or individual variables.  Just because one such feature
is annotated with a type does not mean that others have to be annotated.</p><p>Yet another approach, dubbed <span class="emph">concrete</span> and implemented as
<a href="https://plg.uwaterloo.ca/~dynjs/strongscript/">StrongScript</a> for example, fits neither the micro nor macro
approach. From an implementation perspective, the concrete generalizes the
idea of run-time tags to run-time type-tags so that the run-time system can
check whether methods are called properly, not just language
primitives. The price for the StrongScript developer is that migrating a
single method is hard if a derived class overrides this
method. All overriding methods must also be annotated with types at the
same time, and further extensions must use types for this method, too. By
contrast, other features of the class do not need to be typed.</p><blockquote><p><span style="font-weight: bold">Research Conjectures</span> This micro approach requires much less
work from the developer than a macro based one.  <span class="refelem"><span class="refcolumn"><span class="refcontent">Yes we did
violate good coding practices in the past, for good reasons at the time and
for reasons that illustrate why we are programming language researchers.</span></span></span>
For a small module, such as the factorial one above, adding a type
annotation is not an onerous task; but, some Racket modules are thousands
of lines long, and migrating such a large module into the typed world all
at once is clearly a heavy burden. Also, the developer of a rather complex
algorithm for an otherwise mundane piece of code may wish to annotate this
algorithm with types to express some basic design ideas&#8212;<wbr></wbr>and leave the
rest of the code alone.</p><p>As for the concrete approach, I consider it fatally flawed. It forces a
programmer to migrate too many methods at once, even if someone else is
responsible for the derived ones and might belong to someone else.</p><p>Hence, developers are probably more likely to use micro-migratory typing
than macro-migratory. I do not yet know how to formulate these conjectures
in a testable manner.</p></blockquote><p><span style="font-weight: bold">Granularity and <span class="stt">type Dynamic</span></span></p><p>The presence or absence of <span class="stt">type Dynamic</span> is a second factor concerning
granularity. Some migratory type systems map every missing type annotation
to <span class="stt">Dynamic</span>. To make this viable, the compiler inserts run-time casts
from <span class="stt">Dynamic</span> to appropriate types for primitive operations
automatically, that is, they explicate the workings of a dynamically typed
language. The designers of such type systems don&rsquo;t speak of &ldquo;migration&rdquo;
but &ldquo;refinement,&rdquo; meaning a developer replaces an occurrence of
<span class="stt">Dynamic</span> with a more precise type.</p><p>In principle, the choice of adding <span class="stt">type Dynamic</span> to a migratory type system
is orthogonal to the choice of macro, micro, or concrete granularity. In
practice, micro migratory typing always comes with <span class="stt">type Dynamic</span> but
currently there is no implementation of a macro migratory type system with this
universal type.</p><blockquote><p><span style="font-weight: bold">Research Conjecture</span> The inclusion of <span class="stt">Dynamic</span> in the type
language seems to make it convenient for a programmer to omit a type
annotation when it is considered unnecessary or perhaps too time-consuming
to re-construct.</p><p>Again, I don&rsquo;t even know how to ask the question precisely but once I/we can, we
still need a good method for tackling it.</p></blockquote><p><span style="font-weight: bold">Error Prevention, Debugging</span></p><p>One purpose of types is to prevent certain classes of mistakes. This holds
for both sound and unsound type systems.  There&rsquo;s little need to elaborate
on this idea for static typing; there is enough literature out there.</p><blockquote><p><span style="font-weight: bold">Research Conjecture</span> In the context of migratory typing, the
effectiveness of error prevention clearly depends on the expressiveness of
the migratory type system.  For the macro approach, expressiveness
determines which run-time exceptions are prevented, e.g. <span class="RktPn">(</span><span class="RktSym">!</span><span class="stt"> </span><span class="RktVal"><span class="nobreak">-1</span></span><span class="RktPn">)</span>.
By comparison, the micro approach combined with <span class="stt">type Dynamic</span> seems to
prevent fewer run-time exceptions.</p><p>Strangely enough, nobody has investigated this conjecture even though its
answer should help us address the key question, namely, what the benefits
of code migration are.</p></blockquote><p>A related but different question is how to debug when a run-time exception
is raised. As I have argued many times in public settings, a sound type
system narrows down the search for the source of such exceptions a lot more
than unsound ones.</p><p>While soundness is an obvious concept in the logical context, people seem to
accept that it exists on a gray-scale even in implementations of statically
typed languages. Java seems to be less type-sound than Haskell in peoples&rsquo; mind.</p><p><div class="SIntrapara">In the world of migratory typing, soundness is much less obvious both in terms
of acceptance and in logical terms:
</div><div class="SIntrapara"><ul><li><p>There are migratory type systems, such as TypeScript, that are
intentionally unsound for mixtures of typed and untyped code. While these
typed languages may prevent some run-time exceptions, they open the door
for insidious mistakes due to bad interactions between typed and untyped
code.</p></li><li><p>There are sound migratory type systems but soundness means different
theorems to different designers. All of them equate soundness with the
idea that typed code can&rsquo;t be violated by misuse in untyped context. But
then there are details.</p><p>Ben Greenman&rsquo;s ICFP 2018 paper shows there is a spectrum of soundness. Max
New, at POPL 2019, shows that if we accept basic axioms about the
operational semantics of migratory type systems, there is only one sound
one, the one that uses Typed Racket&rsquo;s &ldquo;wrapper&rdquo; approach.</p></li><li><p>Finally, <span class="refelem"><span class="refcolumn"><span class="refcontent">I&rsquo;ll expand on this line in a revision.</span></span></span> type
soundness describes only one side of the coin. Some migratory type systems
don&rsquo;t protect untyped code from mistakes in type annotations. Ben Greenman
has dubbed this dimension <span class="emph">completeness</span>, a new concept in
the world of types.</p></li></ul></div></p><blockquote><p><div class="SIntrapara"><span style="font-weight: bold">Research Conjecture</span> Migratory typing should help developers
with debugging a run-time exception. All of the above factors matter for
the debugging task:
</div><div class="SIntrapara"><ul><li><p>The size of statically checked region of code
helps developers narrow down from where exceptions may originate.</p></li><li><p>The presence of <span class="stt">Dynamic</span> in the middle of a large region of
statically typed code obscures the source of a run-time exception. So it
might be a bad idea to add it to the macro approach of migratory typing.</p></li><li><p>The preceding bullets assume soundness. But, are all forms of
soundness created equal?</p></li><li><p>Completeness ought to help developers, too, because exceptions
originating from untyped code might be due to mistakes in type
annotations. Assuming the absence of mistakes in types may cause wild-goose
chases.</p></li></ul></div></p><p>How are we going to study the relationship among these factors?</p></blockquote><p><span style="font-weight: bold">Performance</span></p><p>If the addition of types causes a program to become so slow to become
unusable, migratory typing is a failure.</p><p>I conjecture that the designers of all compromised migratory type systems
chose the weakened guarantees for the sake of performance. They guessed
that properly protecting code is too expensive.</p><p>When Sam Tobin-Hochstadt and I started designing Typed Racket, I knew we
needed run-time checks. Therefore I wanted to convert modules so that
execution would spend a lot of time in code generated from typed fragments
and untyped fragments with rarely executed run-time checks in the middle.</p><blockquote><p><span style="font-weight: bold">Research Results</span>  And even with such foresight, I failed to get
a Typed Racket with proper performance.  In the meantime, <a href="https://www2.ccs.neu.edu/racket/pubs/#gtnffvf-jfp19">our
research confirmed</a> that sound and complete migratory typing might be
brutally expensive.</p></blockquote><p>So, over the last couple of years performance has emerged as a major
dimension of effectiveness in the world of sound migratory typing&#8212;<wbr></wbr>because
it&rsquo;s something we <a href="https://www2.ccs.neu.edu/racket/pubs/#gtnffvf-jfp19">now know</a> how to measure.</p><p><span style="font-weight: bold">The Benefits of Adding Types</span></p><p>All of us in this research area take it for granted that migrating
dynamically typed code to a typed sister language is a &ldquo;good thing.&rdquo; We
have abstract arguments. We show concrete examples of how the addition of
types revealed hidden bugs (that never bothered anybody before). We allude to the
benefits of type annotations for interactions with the IDE. We believe that
type annotations help with maintenance tasks down the line.</p><blockquote><p><span style="font-weight: bold">Research Criticism</span> I have seen some <a href="#%28elem._%28gentag._0%29%29" data-pltdoc="x">papers</a> that
measure the pros and cons of similar programs <span class="refelem"><span class="refcolumn"><span class="refcontent">It also isn&rsquo;t clear
to me whether the research methodology is properly developed, and an experiment
in the setting of migratory typing would help to develop this method further.</span></span></span>
written in distinct statically and dynamically typed programming languages.</p><p>The context of migratory typing supplies a much better test bed than a pair of
unrelated programming languages. Key is, research on migratory typing has made
these questions truly relevant for the working developer, and it enables novel
ways of studying the relationship between the various aspects of expressiveness
and effectiveness. The syntax of statically and dynamically typed program
phrases barely differ. It is thus easy to write programs in either one of these
dialects, and a study does not have to account for differences in programming
language.  In most cases, these dynamically typed languages also have a
(reasonably) large developer community that has created many code
repositories. A researcher can study these repos to understand the programming
idioms of the language and the needs of code migration.</p></blockquote><h4><a name="(part._.We_.Need_a_.Laffer_.Curve_of_.Migratory_.Typing)"></a>We Need a Laffer Curve of Migratory Typing</h4><p>The &ldquo;we&rdquo; here is the community of programming language researchers,
including myself; and the &ldquo;curve&rdquo; part denotes the desire to understand
the relationship between the various aspects of &ldquo;expressiveness&rdquo; and
&ldquo;effectiveness.&rdquo;</p><p>My students and I have tackled some aspects of the above research
questions, with results that are somewhat satisfying and that
simultaneously just raise more questions than they answer.  So there&rsquo;s a
lot to be done.</p><p>The challenge concerning performance was the easiest to address&#8212;<wbr></wbr>because
it lent itself to quantitative statements. Yet, we did not do well even for
this easily quantifiable area. For the first decade of migratory typing,
none of us provided good answers, and many still don&rsquo;t.  We lacked a
performance-evaluation method, and it took time and labor to develop
one. Sadly, people at first didn&rsquo;t understand that we had developed a
generally applicable method; all they saw were the negative performance
results for Typed Racket&#8212;<wbr></wbr>though this says more about how people read
papers than what we did.</p><p>Of the remaining challenges, none come with easily quantifiable answers,
and we lack research methods for all of them. Some of these questions will
also require that we dive into the messy area of user studies.  And that&rsquo;s
why we probably don&rsquo;t address these questions.</p><p>This state of the world is a real problem, especially considering how many
of us and how many of our aspiring PhD students in programming languages
wish to improve the daily lives of working software
developers. Unfortunately, we find it easier to continue the work we have
been doing all along, and PhD applicants perceive our publications as what
we think will help developers&#8212;<wbr></wbr>even those with some work
experience<span class="refelem"><span class="refcolumn"><span class="refcontent">This is not to deny that some of this research
will also change the future of software development.</span></span></span>. Nobody seems to
understand the disconnect between those two. I have come to think that we,
the community, act like the drunks who look for their car keys under the
lamp posts because that&rsquo;s where the light is, even though we know that this
not where we dropped them.</p><p>So I am calling for some of us to develop methods for the above
questions. The answers will help us point our research into directions that
will make our work directly relevant to the working developers out there.,
And I think this would be a good thing for us and them.</p><p><span style="font-weight: bold">Other Papers</span></p><p>One group of researchers, with various collaborators, has actively
investigated various aspects of the relationship between static types and
<a name="(elem._(gentag._0))"></a><a href="https://users.dcc.uchile.cl/~rrobbes/p/ICSE2014-docstypes.pdf">API usability</a> (which uses Dart, arguably a programming
 language with a modicum of migratory typing),
<a href="https://pleiad.cl/papers/2012/kleinschmagerAl-icpc2012.pdf">software maintainability</a>, and
<a href="https://www.dcc.uchile.cl/TR/2012/TR_DCC-20120418-005.pdf">usability of undocumented software</a>.
Interested readers can also follow links from these papers to somewhat
related topics in this direction.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p><span style="font-weight: bold">Postscript</span> I served as a reviewer of
<a href="https://jyx.jyu.fi/bitstream/handle/123456789/47698/978-951-39-6388-0_vaitos04122015.pdf?sequence=1">Antti-Juhani Kaijanaho</a>&rsquo;s dissertation, which explained, argued
for, and illustrated &ldquo;evidence-based programming language design.&rdquo; I do not
have this particular research direction in mind with my thought, but such
research should serve us all as inspiration to look for the correct methods and
to develop methodologies for studying the usefulness of these methods. Also, by
coincidence, Viera Proulx pointed me to an <a href="https://pdfs.semanticscholar.org/e075/4c27f9b9beca3973f19f4e1c026ef047b7db.pdf">opinion piece</a> (by
Stefik and Hanenberg, whom I mentioned above) that seems to argue a similar
point more broadly, just as I was writing up this thought.

As indicated with a margin note, I conjecture that these researchers and I
strongly differ on what we could consider an adequate method and, worse, what we
would consider evidence in support for a programming language or a even just a
language construct. For example, I am afraid that due the chosen method and its
particular use, people might reject <span class="RktSym"><a href="http://docs.plt-scheme.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> in a programming language
because the <a href="http://www.cs.kent.edu/~jmaletic/cs63902/Papers/Merlin16.pdf"> user study</a> of <span class="stt">lambda</span> in C++ expressions
supplies &ldquo;evidence&rdquo; that closures are unusable features. </p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr><tr><td><p>&#160;</p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="NSF.html" title="backward to &quot;NSF&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Thoughts&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Referential_Transparency.html" title="forward to &quot;Referential Transparency&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
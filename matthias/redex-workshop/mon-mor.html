<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>1&nbsp;The Theoretical Framework</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Redex Summer School</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">The Theoretical Framework</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="mon-aft.html" class="tocviewlink" data-pltdoc="x">Syntax and Metafunctions</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="lab-mon-aft.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Designing Metafunctions</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="tue-mor.html" class="tocviewlink" data-pltdoc="x">Reductions and Semantics</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="lab-tue-mor.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Designing Reductions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="tue-aft.html" class="tocviewlink" data-pltdoc="x">Types and Property Testing</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="lab-tue-aft.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Type Checking</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="wed-mor.html" class="tocviewlink" data-pltdoc="x">Imperative Extensions</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="lab-wed-mor.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Contexts and Stores</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="wed-aft.html" class="tocviewlink" data-pltdoc="x">Abstract Machines</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="lab-wed-aft.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Machine Transitions</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="thu-mor.html" class="tocviewlink" data-pltdoc="x">Abstracting Abstract Machines I</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="lab-thu-mor.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Abstracting Abstract Machines I</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="thu-aft.html" class="tocviewlink" data-pltdoc="x">Abstracting Abstract Machines II</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="lab-thu-aft.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Abstracting Abstract Machines II</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="fri-mor.html" class="tocviewlink" data-pltdoc="x">Your Turn</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">The Theoretical Framework</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part._1928__approximately%29" class="tocviewlink" data-pltdoc="x">1928, approximately</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._1958--1972%29" class="tocviewlink" data-pltdoc="x">1958&ndash;1972</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part._1974%29" class="tocviewlink" data-pltdoc="x">1974</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#%28part._1986--1992%29" class="tocviewlink" data-pltdoc="x">1986&ndash;1992</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="#%28part._1999--2010%29" class="tocviewlink" data-pltdoc="x">1999&ndash;2010</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._1928__approximately%29" class="tocsubseclink" data-pltdoc="x">1928, approximately</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._1958--1972%29" class="tocsubseclink" data-pltdoc="x">1958&ndash;1972</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._1974%29" class="tocsubseclink" data-pltdoc="x">1974</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._1986--1992%29" class="tocsubseclink" data-pltdoc="x">1986&ndash;1992</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._1999--2010%29" class="tocsubseclink" data-pltdoc="x">1999&ndash;2010</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">6.2.900.4</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Redex Summer School&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Redex Summer School&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="mon-aft.html" title="forward to &quot;2 Syntax and Metafunctions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._mon-mor)"></a>The Theoretical Framework</h3><p><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Goals</span></p></td></tr><tr><td><p> &#8212;<wbr></wbr> abstract syntax</p></td></tr><tr><td><p> &#8212;<wbr></wbr> notions of reduction, substitution</p></td></tr><tr><td><p> &#8212;<wbr></wbr> reductions and calculations</p></td></tr><tr><td><p> &#8212;<wbr></wbr> semantics</p></td></tr><tr><td><p> &#8212;<wbr></wbr> standard reduction</p></td></tr><tr><td><p> &#8212;<wbr></wbr> abstract register machines</p></td></tr><tr><td><p> &#8212;<wbr></wbr> types</p></td></tr></table></p><h4>1.1<tt>&nbsp;</tt><a name="(part._1928__approximately)"></a>1928, approximately</h4><p>The lambda calculus: most familiar, still misunderstood</p><blockquote><p><span class="stt">e = x | (\x.e) | (e e)</span></p></blockquote><p>Terms vs trees, abstract over concrete syntax</p><p>Encode some forms of primitives: numbers, booleans &ndash; good for theory of
computation; mostly irrelevant for PL. extensions with primitive data</p><blockquote><p><span class="stt">e = x | (\x.e) | (e e) | tt | ff | (if e e e)</span></p></blockquote><p>What we want: develop LC as a <span style="font-style: italic">model</span> of a PL. Because of history,
this means two things: a simple logic for calculating with the terms of the
language <span class="stt">e == e</span><span class="stt">&rsquo;</span><span class="stt"></span> and a system for determining the value of a
program. The former is the <a name="(tech._calculu)"></a><span style="font-style: italic">calculus</span>, the latter is the
<a name="(tech._semantic)"></a><span style="font-style: italic">semantics</span>.</p><p><div class="SIntrapara">Both start with basic notions of reduction (axioms). they are just relation
on terms: </div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>People tend to make a mess and mix the two
notations</p></blockquote></blockquote></blockquote></div></p><p><div class="SIntrapara"><blockquote><p><span class="hspace">&nbsp;</span><span class="stt">((\x.e) e</span><span class="stt">&rsquo;</span><span class="stt">) beta e[x=e</span><span class="stt">&rsquo;</span><span class="stt">] </span></p></blockquote></div><div class="SIntrapara"> pronounced: e with x replaced by e&rsquo;
</div><div class="SIntrapara"><blockquote><p><span class="hspace">&nbsp;</span><span class="stt">((\x.e) e</span><span class="stt">&rsquo;</span><span class="stt">) beta [e</span><span class="stt">&rsquo;</span><span class="stt">/x]e</span></p></blockquote></div><div class="SIntrapara"> pronounced substitute e&rsquo; for x in e</div></p><p><span style="font-weight: bold">Think</span> substitution via tree surgery, preserving bindings</p><p>Here are two more, often done via external interpretation functions (&#948;)</p><p><div class="SIntrapara"><blockquote><p><span class="stt">(if tt e e</span><span class="stt">&rsquo;</span><span class="stt">) if-tt e</span></p></blockquote></div><div class="SIntrapara"><blockquote><p><span class="stt">(if ff e e</span><span class="stt">&rsquo;</span><span class="stt">) if-ff e</span><span class="stt">&rsquo;</span><span class="stt"></span></p></blockquote></div></p><p>If this is supposed to be a theory of functions (and if expressions) we
need to be able to use this relations <span style="font-style: italic">in context</span></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e xyz e'</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">=</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">e'</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e = e'</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e = e'</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e = e'</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------	</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e e'' = e' e''</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e'' e = e'' e'	</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\x.e</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">= \x.e'</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">plus reflexivity, symmetry, and transitivity</span></p></td></tr></table></div><div class="SIntrapara">for any relation <span class="stt">xyz</span></div></p><p>Now you have an equational system. what&rsquo;s it good for? you can prove such
facts as</p><blockquote><p><span class="stt">e (Y e) = (Y e)</span></p></blockquote><p>meaning <span style="font-style: italic">every single term has a fixpoint</span></p><p>All of the above is mathematics but it is just that, mathematics. It might
be considered theory of computation, but it is <span style="font-style: italic">not</span> theory of
programming languages. But we can use these ideas to create a theory of
programming languages.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._1958--1972)"></a>1958&ndash;1972</h4><p>Many people brought the lambda calculus into PL. They had good intuition,
but they did not know what to make of it all. Most used the syntax, some
appealed to the equations. The latter did not know what they were doing.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Mathematicians, too, had an idea that the lambda calculus was
a bit misconceived. They tried requiring that every lambda-bound variable
shows up at least once in the function&rsquo;s body. This doesn&rsquo;t address the
problem.</p></blockquote></blockquote></blockquote><p>One of the sticky points was Algol 60&rsquo;s introduction in 1958 of
call-by-value versus call-by-name, and the acknowledgment of others that
there was a real distinction. But they couldn&rsquo;t figure it out.</p><p>Instead they proposed that call-by-value was a mere strategy of
implementing the lambda calculus, often dubbed applicative-order evaluation
(strategy). People considered the above the <span style="font-style: italic">true</span> idea of lambda
calculus. <span style="font-weight: bold">Anybody who uses this word does not know what he&rsquo;s talking
about.</span></p><p>Sadly, just when the issue was about to be resolved once and for all,
several different practitioners took off and engraved this ill-defined
terminology on the broad communities mind.</p><p>A decade=plus later, others invented the almost equally silly terminology
of weak head reduction, resurrecting the head-reduction idea from
mathematics and somehow trying to construct a PL theory from that. Again,
people who use this terminology&#8212;<wbr></wbr>and the closely related
small-step/big-step stuff&#8212;<wbr></wbr>do not understand the rest of this framework
and never bothered to read the literature properly.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._1974)"></a>1974</h4><p>Plotkin&rsquo;s 1974 TCS paper on call-by-name versus call-by-value shows how to
resolve this problem once and for all.</p><p>In addition, Plotkin&rsquo;s paper also sketches several research programs,
mostly on scaling up his ideas to the full spectrum of languages but also
on the precise connection between by-value and by-name their relationship,
both at the proof-theoretical level as well as at the model-theoretic
level.</p><p><div class="SIntrapara">Here is Plotkin&rsquo;s idea as a quasi-algorithm:
</div><div class="SIntrapara"><ol><li><p>Start from an abstract syntax, plus notions of scope and
scope-preserving substitution. Consider closed terms <a name="(tech._program)"></a><span style="font-style: italic">Program</span>s.</p></li><li><p>Identify a subset of expressions as <a name="(tech._value)"></a><span style="font-style: italic">Value</span>s. Use <span class="stt">v</span> to
range over <a href="#%28tech._value%29" class="techoutside" data-pltdoc="x"><span class="techinside">Value</span></a>s.</p><p><span style="font-weight: bold">Note</span> The complement of this set was (later) dubbed
<a name="(tech._computation)"></a><span style="font-style: italic">computations</span>, due to Moggi&rsquo;s work under Plotkin.</p></li><li><p>Define basic notions of reduction (axioms). Examples:</p><p><div class="SIntrapara"><blockquote><p><span class="stt">((\x.e) e</span><span class="stt">&rsquo;</span><span class="stt">) beta-name e[x=e</span><span class="stt">&rsquo;</span><span class="stt">]</span></p></blockquote></div><div class="SIntrapara"><blockquote><p><span class="stt">((\x.e) v) beta-value e[x=v]</span></p></blockquote></div></p></li><li><p>Inductively generate an equational theory from the basic notions of
reduction.</p></li><li><p>This theory defines a semantics, that is, a relation <span style="font-style: italic">eval</span>
from programs to values:</p><p><div class="SIntrapara"><blockquote><p><span class="stt">eval : Program x Value</span></p></blockquote></div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">def</span><span class="stt"> e eval v iff e = v</span></p></blockquote></div></p></li><li><p>Prove that <span style="font-style: italic">eval</span> is a function, and you have got yourself a
<span style="font-style: italic">specification</span> of an interpreter.</p><p><div class="SIntrapara"><blockquote><p><span class="stt">eval : Program -&gt; Value</span></p></blockquote></div><div class="SIntrapara"><blockquote><p><span class="stt">eval(e) = v</span></p></blockquote></div></p><p><span style="font-weight: bold">Note</span> This step often reuses a variant of the Church-Rosser theorem
of the mathematical theory of lambda calculus.</p></li><li><p>Prove that the calculus satisfies a Curry-Feys standard reduction
property. This gives you a second semantics:</p><p><div class="SIntrapara"><blockquote><p><span class="stt">eval-standard : Program -&gt; Value</span></p></blockquote></div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">def</span><span class="stt"> eval-standard(e) = v iff e standard reduces to v</span></p></blockquote></div></p><p><div class="SIntrapara">The new semantics is correct:
</div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">Theorem</span><span class="stt"> eval-standard = eval</span></p></blockquote></div></p><p><a name="(tech._standard._reduction)"></a><span style="font-style: italic">Standard reduction</span> is a strategy for the lambda calculus, that
is, a function that picks the next reducible expression (called
<a name="(tech._redex)"></a><span style="font-style: italic">redex</span>) to reduce. Plotkin specifically uses the
leftmost-outermost strategy but others may work, too.</p></li></ol></div><div class="SIntrapara">Plotkin also shows&#8212;<wbr></wbr>on an ad hoc basis&#8212;<wbr></wbr>that this evaluator function is
equivalent to Landin&rsquo;s evaluator based on the SECD machine, an abstract
register machine.</div></p><p><div class="SIntrapara">Plotkin (following Morris, 1968) uses step 6 from above to add two ideas:
</div><div class="SIntrapara"><ul><li><p>The interpreter of a programming language (non-constructively)
 generates a theory of equivalence on phrases.</p><blockquote><p><span style="font-weight: bold">def</span><span class="stt"> e ~ e</span><span class="stt">&rsquo;</span><span class="stt"> iff placing e and e</span><span class="stt">&rsquo;</span><span class="stt"> into any context yields</span><span class="stt">
</span><span class="stt">programs that produce the same observable behavior according to eval</span></p></blockquote><p><span style="font-weight: bold">Theorem</span> <span class="stt">~</span> is the coarsest equivalence theory and thus unique.</p><p>Let&rsquo;s call <span class="stt">~</span> the <a name="(tech._truth)"></a><span style="font-style: italic">Truth</span>.</p></li><li><p><span style="font-weight: bold">Theorem</span> e = e&rsquo; implies e ~ e&rsquo;. Naturally the reverse doesn&rsquo;t hold.</p></li></ul></div></p><h4>1.4<tt>&nbsp;</tt><a name="(part._1986--1992)"></a>1986&ndash;1992</h4><p><div class="SIntrapara">Matthias&rsquo;s (post)dissertation research extends Plotkin&rsquo;s work in two
directions:
</div><div class="SIntrapara"><ol><li><p>Plotkin&rsquo;s &ldquo;algorithm&rdquo; applies to imperative programming language,
 especially those extending the lambda calculus syntax with (variable)
 assignment and non-local control operators.</p><p><a href="wed-mor.html" data-pltdoc="x">Imperative Extensions</a> explains how two of these work.</p></li><li><p>It is possible to derive useful abstract register machines from the
standard reduction semantics of the programming language</p><p><div class="SIntrapara">Each machine <span class="stt">M</span> defines a new semantics:
</div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">def</span><span class="stt"> eval-M(e) = v iff load M with e, run, unload, yields v</span></p></blockquote></div></p><p>For each of these functions, we can prove an equivalence theorem.</p><blockquote><p><span style="font-weight: bold">Theorem</span><span class="stt"> eval-M = eval-standard = eval</span></p></blockquote></li></ol></div><div class="SIntrapara">His work also shows how this approach greatly simplifies proofs of
consistency for the semantics of programming languages and especially
so-called type soundness theorems.</div></p><h4>1.5<tt>&nbsp;</tt><a name="(part._1999--2010)"></a>1999&ndash;2010</h4><p>Matthew maintains and extends the monograph that collects the above ideas.</p><p>Robby creates, implements, and maintains Redex with his PhD students.</p><p>While Redex was developed to facilitate the development of PL models
according to the above framework, it has become useful above and beyond
this application domain. David Van Horn will demonstrate one such
application, just one step beyond the framework. Others have gone much
further still.</p><p>Feel encouraged to stretch the limits of Redex.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Redex Summer School&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Redex Summer School&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="mon-aft.html" title="forward to &quot;2 Syntax and Metafunctions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
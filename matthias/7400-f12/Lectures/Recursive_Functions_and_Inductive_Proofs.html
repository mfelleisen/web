<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>3&nbsp;Recursive Functions and Inductive Proofs</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="racket.css" title="default" /><link rel="stylesheet" type="text/css" href="figure.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x">Working with Redex</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Languages_and_Metafunctions.html" class="tocviewlink" pltdoc="x">Languages and Metafunctions</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="More_Languages__More_Design.html" class="tocviewlink" pltdoc="x">More Languages, More Design</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Recursive Functions and Inductive Proofs</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Recursive Functions and Inductive Proofs</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#(part._.Conjectures)" class="tocviewlink" pltdoc="x">Conjectures</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#(part._.Inductive_.Proofs)" class="tocviewlink" pltdoc="x">Inductive Proofs</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#(part._.Improving_.Claims)" class="tocviewlink" pltdoc="x">Improving Claims</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#(part._.Conjectures)" class="tocsubseclink" pltdoc="x">Conjectures</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#(part._.Inductive_.Proofs)" class="tocsubseclink" pltdoc="x">Inductive Proofs</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#(part._.Improving_.Claims)" class="tocsubseclink" pltdoc="x">Improving Claims</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="More_Languages__More_Design.html" title="backward to &quot;2 More Languages, More Design&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Working with Redex&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._.Recursive_.Functions_and_.Inductive_.Proofs)"></a>Recursive Functions and Inductive Proofs</h3><p>On many occasions, programming language researchers formulate claims about
programming languages as relations between functions. Since the collection
of terms in a language is usually defined in an inductive (self-referential)
manner, they design recursive functions to process terms. To prove claims
about functions (and relations), they then use <span style="font-style: italic">structural
induction</span>.  <span class="refelem"><span class="refcolumn"><span class="refcontent">If you don&rsquo;t, find reading material to supplement
the lectures.</span></span></span>  This last introductory lecture summarizes what you are
expected to know about structural induction and strengthening claims from
your undergraduate curriculum.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Conjectures)"></a>Conjectures</h4><p>Say you have a language and you have defined some functions on the
language:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Languages.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-language))" class="RktStxLink" pltdoc="x">define-language</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">for the results </span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">determine the area of a shape </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">we leave off the optional contract because there is no specification for the domain </span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktSym">x_min</span><span class="hspace">&nbsp;</span><span class="RktSym">x_max</span><span class="hspace">&nbsp;</span><span class="RktSym">y_min</span><span class="hspace">&nbsp;</span><span class="RktSym">y_max</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_max</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_min</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_max</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_min</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">compute the bounding rectangle of a shape </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">auxiliary function: </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">bb-aux</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">bb-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktSym">x_min1</span><span class="hspace">&nbsp;</span><span class="RktSym">x_max1</span><span class="hspace">&nbsp;</span><span class="RktSym">y_min1</span><span class="hspace">&nbsp;</span><span class="RktSym">y_max1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktSym">x_min2</span><span class="hspace">&nbsp;</span><span class="RktSym">x_max2</span><span class="hspace">&nbsp;</span><span class="RktSym">y_min2</span><span class="hspace">&nbsp;</span><span class="RktSym">y_max2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rectangle</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">min</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_min1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_min2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">max</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_max1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x_max2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">min</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_min1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_min2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">max</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_max1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y_max2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">You can experiment with these functions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal">1.1</span><span class="hspace">&nbsp;</span><span class="RktVal">2.7</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-7</span>.2</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-2</span>.0</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(rectangle<span class="stt"> </span><span class="nobreak">-7</span>.2<span class="stt"> </span>4.1<span class="stt"> </span><span class="nobreak">-5</span>.0<span class="stt"> </span>2.7)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal">1.1</span><span class="hspace">&nbsp;</span><span class="RktVal">2.7</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-7</span>.2</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-2</span>.0</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">87.01</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal">1.1</span><span class="hspace">&nbsp;</span><span class="RktVal">2.7</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">9</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">square</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-7</span>.2</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-2</span>.0</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">9</span></p></td></tr></table></blockquote></div><div class="SIntrapara">From experiments such as these and/or inspiration, you may come up with
 conjectures such as
</div><div class="SIntrapara"><blockquote><p>the area of the bounding area of some shape <span style="font-style: italic">s</span> is always larger than the area of the <span style="font-style: italic">s</span></p></blockquote></div><div class="SIntrapara">in English or, with Redex,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><p><div class="SIntrapara">It turns out that Redex comes with a <span style="font-style: italic">random testing</span> tool that can
help you check such conjectures:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Testing.html#(form._((lib._redex%2Freduction-semantics..rkt)._redex-check))" class="RktStxLink" pltdoc="x">redex-check</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0"><tr><td><p><span class="RktOut">redex-check: counterexample found after 1 attempt:</span></p></td></tr><tr><td><p><span class="RktOut">(square 2 0 1)</span></p></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">The <span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Testing.html#(form._((lib._redex%2Freduction-semantics..rkt)._redex-check))" class="RktStxLink" pltdoc="x">redex-check</a></span> facility generates examples of <span class="RktSym">s</span> with
 respect to language <span class="RktSym">Shapes</span> and checks whether the
 conjecture&#8212;<wbr></wbr>formulated as a Boolean expression&#8212;<wbr></wbr> <span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">area</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">area</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span> produces true. If so, great. If not, it has
 found a counter-example, and in this case it has. A square&rsquo;s bounding box
 is itself, and the area of the two are <span style="font-style: italic">equal</span>. So we revise our
 conjecture to use <span class="RktSym">&gt;=</span> and not just <span class="RktSym">&gt;</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Testing.html#(form._((lib._redex%2Freduction-semantics..rkt)._redex-check))" class="RktStxLink" pltdoc="x">redex-check</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Shapes</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bb</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0"><tr><td><p><span class="RktOut">redex-check: counterexample found after 7 attempts:</span></p></td></tr><tr><td><p><span class="RktOut">(overlay (square 2 0 1) (square 2 1 2))</span></p></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">But again, <span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Testing.html#(form._((lib._redex%2Freduction-semantics..rkt)._redex-check))" class="RktStxLink" pltdoc="x">redex-check</a></span> finds a counter-example. This time, the
 counter-example consists of a combination of two squares that
 overlap. While the area of the bounding box is just the area of the
 surrounding rectangle, the <span class="RktSym">area</span> function computes the area of an
 overlay construction as the <span style="font-style: italic">sum</span> of the two.</div></p><p>Draw the situation on a grid to figure out why the conjecture fails.</p><p><div class="SIntrapara">To fix the conjecture, we need to change the <span class="RktSym">area</span>
function. Specifically, we need to subtract the overlap between the two
shapes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">overlay</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">=</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">area</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">intersection</span><span class="hspace">&nbsp;</span><span class="RktSym">s_top</span><span class="hspace">&nbsp;</span><span class="RktSym">s_bot</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">meaning we also need to define the <span class="RktSym">intersection</span> function.</div></p><p>In short, before you try to prove conjectures it is often helpful to have
them checked so that minor typos or real misunderstandings are eliminated
before you invest effort in a full-fledged proof.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Inductive_.Proofs)"></a>Inductive Proofs</h4><p>It is time to study the structure of proofs for claims about inductive
functions and sets. Here is a mathematical statement of the claim:</p><blockquote><p><span style="font-weight: bold">Claim</span>: for all Shapes <span style="font-style: italic">s</span>, <span style="font-style: italic">area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= area</span>(<span style="font-style: italic">s</span>)<span style="font-style: italic"></span></p></blockquote><p>The claim is about the elements of an infinitely large set. When such a set
is defined by induction, we can usually (but not always) use mathematical
induction, specifically, a modification called structural induction. The key
to structural induction is that you may assume that the claim holds for all
pieces of a compound structure. This is similar to plain mathematical
induction where you assume that the claim holds for <span style="font-style: italic">n</span> and then prove
it for <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span>. Also, such proofs are usually organized in analogy to the
definition. That is, the proof proceeds by case analysis that includes as
many cases as the inductive definition and the same kind of shapes.</p><p>Here is an outline of the proof of the above claim according to these two
principles.</p><p><span style="font-weight: bold">Proof Organization</span> By induction on the structure of the definition of
Shapes and by case analysis on the construction of <span style="font-style: italic">s</span>:</p><p><div class="SIntrapara"><ol><li><p><span style="font-style: italic">s = square</span>(<span style="font-style: italic">x,y,r</span>)<span style="font-style: italic"></span> In this so-called <span style="font-style: italic">base case</span>, you
must prove that <span style="font-style: italic">area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">square</span>(<span style="font-style: italic">x,y,r</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= area</span>(<span style="font-style: italic">square</span>(<span style="font-style: italic">x,y,r</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>,
without any further assumptions.</p></li><li><p><div class="SIntrapara"><span style="font-style: italic">s = overlay</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span> Here you may assume that
</div><div class="SIntrapara"><ol><li><p><span style="font-style: italic">area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></li><li><p><span style="font-style: italic">area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></li></ol></div><div class="SIntrapara">These two statements are called <span style="font-style: italic">induction hypotheses</span>.
From these induction hypotheses, you must prove that
     <span style="font-style: italic">area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">overlay</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= area</span>(<span style="font-style: italic">overlay</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>
 and you may use the definitions of the functions.</div></p></li></ol></div><div class="SIntrapara">The outer (numeric) enumeration sets up the case analysis for <span style="font-style: italic">s</span>;
 the inner (alphabetical) enumeration is the essence of the induction proof
 strategy.  <span style="font-weight: bold">End of organization</span></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Proof</span> Let us fill in the gaps:
</div><div class="SIntrapara"><ol><li><p>If <span style="font-style: italic">s</span> is a square, its bounding box is the <span style="font-style: italic">same</span> square,
meaning the areas of the two shapes are the same. You can perform an
algebraic computation using the function definitions for <span class="RktSym">bb</span> and
<span class="RktSym">area</span>.</p></li><li><p>From the two induction hypotheses, you get</p><p><div class="SIntrapara"><blockquote><p><span style="font-style: italic">   area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> + area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p><p><span style="font-style: italic">&gt;= area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> + area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span></p><p><span style="font-style: italic">&gt;= area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> + area</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> - area</span>(<span style="font-style: italic">intersection</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p><p><span style="font-style: italic">= area</span>(<span style="font-style: italic">overlay</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></blockquote></div><div class="SIntrapara">because <span style="font-style: italic">area</span>(<span style="font-style: italic">intersection</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> &gt;= </span>0<span style="font-style: italic"></span>. (An area is positive!)</div></p><p><div class="SIntrapara">Using the definitions of <span class="RktSym">area</span> and <span class="RktSym">bb</span>, you also get
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">   area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">overlay</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic">,s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p><p><span style="font-style: italic">&gt;= area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">top</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> + area</span>(<span style="font-style: italic">bb</span>(<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">bot</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></blockquote></div><div class="SIntrapara">with some reasonably straightforward simple claims about <span class="RktSym">max</span> and <span class="RktSym">min</span>.</div></p><p>If you now compose these two calculations, you get the desired conclusion.</p></li></ol></div></p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Improving_.Claims)"></a>Improving Claims</h4><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Languages.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-language))" class="RktStxLink" pltdoc="x">define-language</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">a simple demonstration of a syntax rule </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define-syntax-rule</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">==&gt;&gt; (rewrite to)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">act like </span><span class="RktSym">cons</span><span class="RktCmt"> for Redex </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">mcons</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">mcons</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Terms.html#(form._((lib._redex%2Freduction-semantics..rkt)._term))" class="RktStxLink" pltdoc="x">term</a></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">act like </span><span class="RktSym">+</span><span class="RktCmt"> for Redex </span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">m+</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">m+</span><span class="hspace">&nbsp;</span><span class="RktSym">n_1</span><span class="hspace">&nbsp;</span><span class="RktSym">n_2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">n_1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">n_2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote><table cellspacing="0" align="center" border="0" cellpadding="0"><tr><td width="250" align="center" valign="top"><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">abs.v1</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">abs.v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">abs.v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n_h</span><span class="hspace">&nbsp;</span><span class="RktSym">n_r</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mcons</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">n_h</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+*</span><span class="hspace">&nbsp;</span><span class="RktSym">n_h</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">abs.v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n_r</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">+*</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">+*</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">map</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p></td><td width="250" align="center" valign="top"><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">abs.v2</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">abs.v2</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://pre.racket-lang.org/docs/html/redex/Other_Relations.html#(form._((lib._redex%2Freduction-semantics..rkt)._define-metafunction))" class="RktStxLink" pltdoc="x">define-metafunction</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Lon</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n_h</span><span class="hspace">&nbsp;</span><span class="RktSym">n_r</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mcons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m+</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">n_h</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n_r</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m+</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">n_h</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._lord-2-versions))"></a>Figure&nbsp;3: Two ways of computing absolute distances</span></p></blockquote><p>On occasion, structural induction is not quite enough. To illustrate this
point, let us study the claim that the two versions of the <span class="RktSym">abs</span>
function in <a href="#(counter._(figure._lord-2-versions))" pltdoc="x">figure&nbsp;3</a>&#8212;<wbr></wbr>one plain structural, one in
accumulator-style&#8212;<wbr></wbr>are equal. That is, given the same list of relative
distances they produce the same list of absolute distances.</p><blockquote><p><span style="font-weight: bold">Claim</span>: for all Lists of numbers <span style="font-style: italic">l</span>, <span style="font-style: italic">abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic">l</span>)<span style="font-style: italic"> = abs.v</span>2<span style="font-style: italic"></span>(<span style="font-style: italic">l</span>)<span style="font-style: italic"></span></p></blockquote><p><div class="SIntrapara">Since <span style="font-style: italic">abs.v</span>2<span style="font-style: italic"></span>(<span style="font-style: italic">l</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>0<span style="font-style: italic"></span></span><span style="font-style: italic"></span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic">l</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>0<span style="font-style: italic"></span></span><span style="font-style: italic">,</span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span>, we really mean
</div><div class="SIntrapara"><blockquote><p><span style="font-weight: bold">Claim</span>: for all Lists of numbers <span style="font-style: italic">l</span>, <span style="font-style: italic">abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic">l</span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic">l,</span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></blockquote></div></p><p><div class="SIntrapara">What you may not see from the definition of <span class="RktSym">Lon</span> is that lists have
an inductive definition. Here it is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A </span><a name="(tech._lon)"></a><span style="font-style: italic">Lon</span><span class="RktCmt"> (list of numbers) is one of: </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&ndash;</span><span class="RktCmt"> empty or ()</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&ndash;</span><span class="RktCmt"> (cons Number #, </span><a href="#(tech._lon)" class="techoutside" pltdoc="x"><span class="techinside">Lon</span></a><span class="RktCmt">)</span></td></tr></table></blockquote></div><div class="SIntrapara">It has the two obvious clauses, and it is inductive in the expected case
 (the <span class="RktSym">cons</span> case) and position (<span class="RktSym">cons</span> consumes a number and
 a list). Hence we can adapt the proof organization from above:</div></p><p><span style="font-weight: bold">Proof Organization</span> By induction on the structure of the definition of
Lists and by case analysis on the construction of <span style="font-style: italic">l</span>:</p><p><div class="SIntrapara"><ol><li><p><span style="font-style: italic">l = </span>(<span style="font-style: italic"></span>)<span style="font-style: italic"></span> In this so-called <span style="font-style: italic">base case</span>, you
must prove that <span style="font-style: italic">abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic"></span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic"></span>)<span style="font-style: italic"> ,</span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span>,
without any further assumptions.</p></li><li><p><div class="SIntrapara"><span style="font-style: italic">s = </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"></span> Here you may assume that
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic"> abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic"></span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic">, </span>0<span style="font-style: italic"></span>)<span style="font-style: italic"> </span></p></blockquote></div><div class="SIntrapara">which is the induction hypothesis for an inductive definition with a
single self-reference.</div></p><p>From the inductive hypothesis, you must prove that
  <span style="font-style: italic"> abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic"></span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic">, </span>0<span style="font-style: italic"></span>)<span style="font-style: italic"> </span>
 and you may use the definitions of the functions.</p></li></ol></div><div class="SIntrapara">Again, the enumeration sets up the case analysis for <span style="font-style: italic">l</span>;
 the nested math display enumeration is the essence of the induction proof
 strategy.  <span style="font-weight: bold">End of organization</span></div></p><p><div class="SIntrapara">You can probably see that the first item follows from a trivial
calculation. The problem is the second item, the inductive step. Let us
start by simplifying the left side of the goal:
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">  abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"></span></p><p><span style="font-style: italic">  = cons</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,+*</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">, abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span></p><p><span style="font-style: italic">  = cons</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,+*</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">, aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic">, </span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span></p></blockquote></div><div class="SIntrapara">The last step of the calculation follows from the induction
 hypothesis. But as you can easily see from any example, this last line is
 not equational equal to <span style="font-style: italic">aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic">, </span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span> because it
 unfolds like this:
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">    aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic">, </span>0<span style="font-style: italic"> </span>)<span style="font-style: italic"> </span>
<span style="font-style: italic"> = cons </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">, aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span></p></blockquote></div></p><p><div class="SIntrapara">What this means that we need to improve our claim so that the induction goes through:
</div><div class="SIntrapara"><blockquote><p>for all lists <span style="font-style: italic">l</span> and for any number <span style="font-style: italic">n</span>,
 <span style="font-style: italic">+*</span>(<span style="font-style: italic">n,abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic">l</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic">l,n</span>)<span style="font-style: italic"> </span></p></blockquote></div></p><p>The first case, <span style="font-style: italic">l = </span>(<span style="font-style: italic"></span>)<span style="font-style: italic"></span> works out easily again.</p><p><div class="SIntrapara">The second case, <span style="font-style: italic">l = </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"></span> relies on the induction
hypothesis:
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic"> +*</span>(<span style="font-style: italic">n,abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span></p><p><span style="font-style: italic"> = +*</span>(<span style="font-style: italic">n,cons</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,+*</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span> by def. of <span class="RktSym">abs.v1</span></p><p><span style="font-style: italic"> = cons</span>(<span style="font-style: italic">n+n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,+*</span>(<span style="font-style: italic">n,+*</span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span> by &rsquo;laws&rsquo; of <span class="RktSym">+*</span></p><p><span style="font-style: italic"> = cons</span>(<span style="font-style: italic">n+n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,+*</span>(<span style="font-style: italic">n+n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,abs.v</span>1<span style="font-style: italic"></span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ...</span>)<span style="font-style: italic"> </span>)<span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span> by &rsquo;laws&rsquo; of <span class="RktSym">+*</span></p><p><span style="font-style: italic"> = cons</span>(<span style="font-style: italic">n+n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic">,aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ... </span>)<span style="font-style: italic">,n+n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> </span> by IH</p><p><span style="font-style: italic"> = aux</span>(<span style="font-style: italic"> </span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">first</span></span><span style="font-style: italic"> n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">rest</span></span><span style="font-style: italic"> ... </span>)<span style="font-style: italic">,n</span>)<span style="font-style: italic"> </span> by def. if <span class="RktSym">aux</span></p></blockquote></div><div class="SIntrapara">Naturally, what we called &rsquo;laws&rsquo; of <span class="RktSym">+*</span> are claims about this auxiliary function,
 and these claims deserve a proof. They are good practice proof and follow from
 straightforward structural induction.</div></p><p><div class="SIntrapara">P.S. Yes, an alternative way to proceed would have been to prove
</div><div class="SIntrapara"><blockquote><p><span style="font-style: italic">+*</span>(<span style="font-style: italic">n,aux</span>(<span style="font-style: italic">l</span>)<span style="font-style: italic"></span>)<span style="font-style: italic"> = aux</span>(<span style="font-style: italic">l,n</span>)<span style="font-style: italic"></span></p></blockquote></div></p><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="More_Languages__More_Design.html" title="backward to &quot;2 More Languages, More Design&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Working with Redex&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>3&nbsp;Design with Accumulators</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="figure.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x">How to Design Programs (Crash Course)</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Some_Racket__First_Design.html" class="tocviewlink" pltdoc="x">Some Racket, First Design</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Some_More_Design__Some_More_Racket.html" class="tocviewlink" pltdoc="x">Some More Design, Some More Racket</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Design with Accumulators</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Design with Accumulators</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#(part._.Structural_.Problems)" class="tocviewlink" pltdoc="x">Structural Problems</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#(part._.Accumulators)" class="tocviewlink" pltdoc="x">Accumulators</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#(part._.One_.Function_per_.Task)" class="tocviewlink" pltdoc="x">One Function per Task</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#(part._.Structural_.Problems)" class="tocsubseclink" pltdoc="x">Structural Problems</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#(part._.Accumulators)" class="tocsubseclink" pltdoc="x">Accumulators</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#(part._.One_.Function_per_.Task)" class="tocsubseclink" pltdoc="x">One Function per Task</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="Some_More_Design__Some_More_Racket.html" title="backward to &quot;2 Some More Design, Some More Racket&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs (Crash Course)&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Some_Racket__First_Design.html" title="forward to &quot;1 Some Racket, First Design&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._.Design_with_.Accumulators)"></a>Design with Accumulators</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Structural_.Problems)"></a>Structural Problems</h4><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered"><table cellspacing="0"><tr><td><p><span class="stt">#lang racket </span><br /><span class="stt"></span><br /><span class="stt">(require rackunit)</span><br /><span class="stt"></span><br /><span class="stt">;; [Listof Number] -&gt; [Listof Number]</span><br /><span class="stt">;; Given a list of relative distances (lord), </span><br /><span class="stt">;; produce a list of absolute distances</span><br /><span class="stt"></span><br /><span class="stt">;; EXAMPLE: given (1 10 3 7), produce (1 11 14 21)</span><br /><span class="stt"></span><br /><span class="stt">(define (absolute lord)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(empty? lord) </span><span class="stt">&rsquo;</span><span class="stt">()]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else (cons (first lord)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(add2all (first lord)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(absolute (rest lord))))]))</span><br /><span class="stt"></span><br /><span class="stt">;; Number [Listof Number] -&gt; [Listof Number]</span><br /><span class="stt">;; add n to all numbers on lon </span><br /><span class="stt">(define (add2all n lon)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(empty? lon) </span><span class="stt">&rsquo;</span><span class="stt">()]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else (cons (+ (first lon) n) (add2all n (rest lon)))]))</span><br /><span class="stt"></span><br /><span class="stt">(check-equal? (absolute </span><span class="stt">&rsquo;</span><span class="stt">(1 2 3)) </span><span class="stt">&rsquo;</span><span class="stt">(1 3 6))</span><br /><span class="stt">(check-equal? (absolute </span><span class="stt">&rsquo;</span><span class="stt">(1 10 3 7)) </span><span class="stt">&rsquo;</span><span class="stt">(1 11 14 21))</span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._fig~3a3distance))"></a>Figure&nbsp;9: Absolute and relative distances (structurally)</span></p></blockquote><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered"><table cellspacing="0"><tr><td><p><span class="stt">#lang racket</span><br /><span class="stt"></span><br /><span class="stt">(require rackunit)</span><br /><span class="stt"></span><br /><span class="stt">;; [Tree Atom] is one of: </span><br /><span class="stt">;;  </span><span class="stt">&ndash;</span><span class="stt"> Atom</span><br /><span class="stt">;;  </span><span class="stt">&ndash;</span><span class="stt"> (list [Tree Atom] [Tree Atom])</span><br /><span class="stt"></span><br /><span class="stt">;; DEF: The distance of an atom to the root of the tree is </span><br /><span class="stt">;; the number of cons to be traversed to reach the atom. </span><br /><span class="stt"></span><br /><span class="stt">;; [Tree Symbol] -&gt; [Tree Number]</span><br /><span class="stt">;; replace each symbol by its distance to the root of the tree </span><br /><span class="stt"></span><br /><span class="stt">;; EXAMPLE: given (list </span><span class="stt">&rsquo;</span><span class="stt">a (list </span><span class="stt">&rsquo;</span><span class="stt">a </span><span class="stt">&rsquo;</span><span class="stt">b))</span><br /><span class="stt">;;          produce (list 1 (list 2 2))</span><br /><span class="stt">;; </span><br /><span class="stt">;; GRAPHICALLY:</span><br /><span class="stt">;;</span><br /><span class="stt">;;   *                  *</span><br /><span class="stt">;;  / \                / \</span><br /><span class="stt">;; a   *      ===&gt;    1   *</span><br /><span class="stt">;;    / \                /  \</span><br /><span class="stt">;;   a   b              2    2</span><br /><span class="stt"></span><br /><span class="stt">(define (replace-height t)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(symbol? t) 0]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else </span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(list</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(push1* (replace-height (first t)))</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(push1* (replace-height (second t))))]))</span><br /><span class="stt"></span><br /><span class="stt">;; [Tree Number] -&gt; [Tree Number]</span><br /><span class="stt">;; add 1 to all numbers in the tree</span><br /><span class="stt">(define (push1* t)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(number? t) (add1 t)]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else (list (push1* (first t)) (push1* (second t)))]))</span><br /><span class="stt"></span><br /><span class="stt">(check-equal? (replace-height (list </span><span class="stt">&rsquo;</span><span class="stt">a (list </span><span class="stt">&rsquo;</span><span class="stt">a </span><span class="stt">&rsquo;</span><span class="stt">b)))</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(list 1 (list 2 2)))</span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._fig~3a3tree))"></a>Figure&nbsp;10: Trees and their depth (structurally)</span></p></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._.Accumulators)"></a>Accumulators</h4><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered"><table cellspacing="0"><tr><td><p><span class="stt">#lang racket</span><br /><span class="stt"></span><br /><span class="stt">(require rackunit)</span><br /><span class="stt"></span><br /><span class="stt">;; [Listof Number] -&gt; [Listof Number]</span><br /><span class="stt">;; Given a list of relative distances (lord), </span><br /><span class="stt">;; produce a list of absolute distances</span><br /><span class="stt"></span><br /><span class="stt">;; EXAMPLE: given (1 10 3 7), produce (1 11 14 21)</span><br /><span class="stt"></span><br /><span class="stt">(define (absolute lord0)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; [Listof Number] Number -&gt; [Listof Number]</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; accumulator: so-far is the distance between lord0 and lord</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (absolute lord so-far)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(empty? lord) </span><span class="stt">&rsquo;</span><span class="stt">()]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else (let ([d (+ (first lord) so-far)])</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cons d (absolute (rest lord) d)))]))</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; </span><span class="stt">&ndash;</span><span class="stt"> IN </span><span class="stt">&ndash;</span><span class="stt"> </span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(absolute lord0 0))</span><br /><span class="stt"></span><br /><span class="stt">(check-equal? (absolute </span><span class="stt">&rsquo;</span><span class="stt">(1 2 3)) </span><span class="stt">&rsquo;</span><span class="stt">(1 3 6))</span><br /><span class="stt">(check-equal? (absolute </span><span class="stt">&rsquo;</span><span class="stt">(1 10 3 7)) </span><span class="stt">&rsquo;</span><span class="stt">(1 11 14 21))</span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._fig~3a3distance-accu))"></a>Figure&nbsp;11: Absolute and relative distances (accumulated)</span></p></blockquote><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered"><table cellspacing="0"><tr><td><p><span class="stt">#lang racket</span><br /><span class="stt"></span><br /><span class="stt">(require rackunit)</span><br /><span class="stt"></span><br /><span class="stt">;; [Tree Atom] is one of: </span><br /><span class="stt">;;  </span><span class="stt">&ndash;</span><span class="stt"> Atom</span><br /><span class="stt">;;  </span><span class="stt">&ndash;</span><span class="stt"> (list [Tree Atom] [Tree Atom])</span><br /><span class="stt"></span><br /><span class="stt">;; DEF: The distance of an atom to the root of the tree is </span><br /><span class="stt">;; the number of cons to be traversed to reach the atom. </span><br /><span class="stt"></span><br /><span class="stt">;; [Tree Symbol] -&gt; [Tree Number]</span><br /><span class="stt">;; replace each symbol by its distance to the root of the tree </span><br /><span class="stt"></span><br /><span class="stt">;; EXAMPLE: given (list </span><span class="stt">&rsquo;</span><span class="stt">a (list </span><span class="stt">&rsquo;</span><span class="stt">a </span><span class="stt">&rsquo;</span><span class="stt">b))</span><br /><span class="stt">;;          produce (list 1 (list 2 2))</span><br /><span class="stt">;; </span><br /><span class="stt">;; GRAPHICALLY:</span><br /><span class="stt">;;</span><br /><span class="stt">;;   *                  *</span><br /><span class="stt">;;  / \                / \</span><br /><span class="stt">;; a   *      ===&gt;    1   *</span><br /><span class="stt">;;    / \                /  \</span><br /><span class="stt">;;   a   b              2    2</span><br /><span class="stt"></span><br /><span class="stt">(define (replace-height t0)</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; [Tree Symbol] Number -&gt; [Tree Number]</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; accumulator: depth is distance of t to root of t0</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (replace-height t depth)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(symbol? t) depth]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else (list (replace-height (first t) (+ depth 1)) </span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(replace-height (second t) (+ depth 1)))]))</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; </span><span class="stt">&ndash;</span><span class="stt"> IN </span><span class="stt">&ndash;</span><span class="stt"> </span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(replace-height t0 0))</span><br /><span class="stt"></span><br /><span class="stt">(check-equal? (replace-height (list </span><span class="stt">&rsquo;</span><span class="stt">a (list </span><span class="stt">&rsquo;</span><span class="stt">a </span><span class="stt">&rsquo;</span><span class="stt">b)))</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(list 1 (list 2 2)))</span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._fig~3a3tree-accu))"></a>Figure&nbsp;12: Trees and their depth (accumulated)</span></p></blockquote><h4>3.3<tt>&nbsp;</tt><a name="(part._.One_.Function_per_.Task)"></a>One Function per Task</h4><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCentered"><table cellspacing="0"><tr><td><p><span class="stt">#lang racket</span><br /><span class="stt"></span><br /><span class="stt">(require rackunit)</span><br /><span class="stt"></span><br /><span class="stt">;; [Listof Symbol] -&gt; [Listof Number]</span><br /><span class="stt">;; replace the symbols in los0 with the frequency of occurrence </span><br /><span class="stt"></span><br /><span class="stt">;; EXAMPLE: given </span><span class="stt">&rsquo;</span><span class="stt">(a b c a a) produce </span><span class="stt">&rsquo;</span><span class="stt">(3 1 1 3 3)</span><br /><span class="stt"></span><br /><span class="stt">(define (frequency-transform los0)</span><br /><span class="stt"></span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; intermediate data structures use hash tables as an</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; intermediary data structure: FREQS = [Hash Symbol Number]</span><br /><span class="stt"></span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; [Listof Symbol] FREQS -&gt; FREQS</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; collect the frequencies at which symbols occur </span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; accumulator: h counts occurrences of symbols</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; between los and los0</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (freq los h)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(empty? los) h]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(freq (rest los) (hash-update h (first los) add1 0))]))</span><br /><span class="stt"></span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; [Listof Symbol] FREQS -&gt; [Listof Number]</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; replace symbols in l with their frequencies from h</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (replace l h)</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cond</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[(empty? l) </span><span class="stt">&rsquo;</span><span class="stt">()]</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">[else</span><br /><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cons (hash-ref h (first l)) (replace (rest l) h))]))</span><br /><span class="stt"></span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; </span><span class="stt">&ndash;</span><span class="stt"> IN </span><span class="stt">&ndash;</span><span class="stt"></span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define frequency-of-occurrence (histogram los0 #hash()))</span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; </span><span class="stt">&ndash;</span><span class="stt"> RETURN </span><span class="stt">&ndash;</span><span class="stt"> </span><br /><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(replace los0 frequency-of-occurrence))</span><br /><span class="stt"></span><br /><span class="stt">(check-equal? (frequency-transform </span><span class="stt">&rsquo;</span><span class="stt">(a b c a a)) </span><span class="stt">&rsquo;</span><span class="stt">(3 1 1 3 3))</span><br /><span class="stt"></span></p></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><a name="(counter._(figure._fig~3a3frequency))"></a>Figure&nbsp;13: Intermediate data and accumulators</span></p></blockquote><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="Some_More_Design__Some_More_Racket.html" title="backward to &quot;2 Some More Design, Some More Racket&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs (Crash Course)&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Some_Racket__First_Design.html" title="forward to &quot;1 Some Racket, First Design&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
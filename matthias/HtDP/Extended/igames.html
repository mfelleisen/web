<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from igames.tex by tex2page, v 20070609
(running on MzScheme 370.6, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
igames
</title>
<link rel="stylesheet" type="text/css" href="igames-Z-S.css" title=default>
<meta name=robots content="index,follow">
</head>
<body>
<div id=slidecontent>
<div align=right class=navigation></div>
<p></p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>





</p>
<p>
</p>
<p>
 </p>
<p>

</p>
<p>
</p>
<p>


</p>
<p>





</p>
<p>



</p>
<p>
</p>
<p>
 </p>
<p>














</p>
<p>



</p>
<p>
 
 
 </p>
<p>
 </p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>


</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>

</p>
<p>



</p>
<p>
  </p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>


</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
    </p>
<p>

</p>
<p>



</p>
<p>
  </p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>

</p>
<p>





</p>
<p>


</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>





</p>
<p>



</p>
<p>

</p>
<p>













</p>
<p>


</p>
<p>








</p>
<p>
</p>
<p>



</p>
<p>


  </p>
<p>
</p>
<p>
  </p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>







</p>
<p>
</p>
<p>
 </p>
<p>
</p>
<p>
</p>
<p>


</p>
<p>











</p>
<p>
</p>
<p>

 
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>



</p>
<p>
</p>
<p>


</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>




</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>





</p>
<p>





</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
 
 </p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
  </p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>







</p>
<p>
</p>
<p>
 </p>
<p>
</p>
<p>
</p>
<p>


</p>
<p>











</p>
<p>
</p>
<p>


</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<a name="node_sec_Temp_1"></a>
<h1 class=section>Extended Exercise: Interactive Games, v207</h1>
<p></p>
<a name="node_sec_Temp_2"></a>
<h2 class=section>A Supplement to
<a href="http://www.htdp.org"> &#8220;How to Design Programs&#8221;</a></h2>
<p>&copy;2004, 2003, 2002 Felleisen, Findler, Flatt, Krishnamurthi
 <br>
 <br>
 <br>
</p>
<p>
</p>
<a name="node_sec_1"></a>
<h1 class=section>1&nbsp;&nbsp;Events</h1>
<p>When something interesting happens, people say an event takes place. Programs
also notice events. When people press keys on a computer or when the clock
ticks, an event happens and programs react to it. We all know such programs. </p>
<p>
Text editing programs interpret every keystroke. Some indicate that the user is
typing plain text; others request that the editor changes fonts, transposes
words, and so on. Game programs also heavily use arrow keys; they allow players
to move objects, fire weapons, open locks, and so on. Games and animation
programs also react to the ticking of the clock. Every time it ticks, they must
redraw some canvas.</p>
<p>
</p>
<a name="node_sec_1.1"></a>
<h2 class=section>1.1&nbsp;&nbsp;Interaction via Keystrokes</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/curriculum-Z-H-5.html">7. The Varieties of Data</a>
<br>

</p>

<p class=noindent>T<small>E</small><small>A</small><small>C</small><small>H</small><small>P</small><small>A</small><small>C</small><small>K</small>: <a href="draw.ss">draw.ss</a><br>
</p>
<p>
</p>

<p class=noindent>The <tt><strong>draw.ss</strong></tt> teachpack supports programs that react to events on
a keyboard.  Every keystroke is an event. DrScheme observes these events and
provides a function that delivers the keystrokes, if the user has touched the
keyboard. Clearly, the first thing we need then is a data definition that
describes this class of events:<a name="node_call_footnote_Temp_3"></a><sup><small><a href="#node_footnote_Temp_3">1</a></small></sup>
</p>
<div align=left><pre class=scheme><span class=comment>;; A <span style="font-style: oblique"> KeyEvent</span> is one of: </span>
<span class=comment>;; --- a <code class=scheme><span class=variable>Character</span></code>, e.g., <code class=scheme><span class=selfeval>#\a</span></code>, <code class=scheme><span class=selfeval>#\space</span></code>, </span>
<span class=comment>;; --- a <code class=scheme><span class=variable>Symbol</span></code>, e.g., <code class=scheme><span class=keyword>'</span><span class=variable>up</span></code>, <code class=scheme><span class=keyword>'</span><span class=variable>left</span></code>, </span>
</pre></div><p>
A character represents the event when the user presses an alphanumeric key; a
symbols represents special keys and keyboard events. </p>
<p>
</p>

<p class=noindent>The data definition puts together an interesting mix of distinct
classes of data into one class. Naturally, a function that consumes and
processes a <code class=scheme><span class=variable>KeyEvent</span></code> must distinguish all those cases. </p>
<p>
Now consider the following problem: 
</p>
<blockquote>
Develop a program that draws the movements of a ball on a straight line left or
right. The user controls the movement of the ball by pressing the left arrow
(&larr;) key or the right arrow (&rarr;) key on the keyboard.
</blockquote>
Clearly, one of the ingredients that this program needs is a function that
consumes the current <code class=scheme><span class=variable>x</span></code> coordinate of the ball and a key event and that
produces the new <code class=scheme><span class=variable>x</span></code> coordinate: 
<div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>ball-move</span> <span class=selfeval>:</span> <span class=variable>KeyEvent</span> <span class=variable>Number</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Number</span></code></span>
<span class=comment>;; to interpret a <code class=scheme><span class=keyword>'</span><span class=variable>left</span></code> or <code class=scheme><span class=keyword>'</span><span class=variable>right</span></code> keystroke as a move</span>
<span class=comment>;; into the appropriate direction by 10 pixels</span>
</pre></div><p>
Since keyevents are ordinary pieces of data, we can also make up some example: 
</p>
<div align=left><pre class=scheme>(<span class=variable>ball-move</span> <span class=selfeval>#\a</span> <span class=selfeval>0</span>) <span class=selfeval>&quot;should be&quot;</span> <span class=selfeval>0</span>
(<span class=variable>ball-move</span> <span class=selfeval>#\z</span> <span class=selfeval>20</span>) <span class=selfeval>&quot;should be&quot;</span> <span class=selfeval>20</span>
(<span class=variable>ball-move</span> <span class=keyword>'</span><span class=variable>left</span> <span class=selfeval>0</span>) <span class=selfeval>&quot;should be&quot;</span> <span class=selfeval>-10</span>
(<span class=variable>ball-move</span> <span class=keyword>'</span><span class=variable>right</span> <span class=selfeval>20</span>) <span class=selfeval>&quot;should be&quot;</span> <span class=selfeval>30</span>
(<span class=variable>ball-move</span> <span class=keyword>'</span><span class=variable>up</span> <span class=selfeval>0</span>) <span class=selfeval>&quot;should be&quot;</span> <span class=selfeval>0</span>
</pre></div><p>
The examples illustrate that the function must distinguish character key events
from symbolic ones and that it must distinguish <code class=scheme><span class=keyword>'</span><span class=variable>left</span></code> and
<code class=scheme><span class=keyword>'</span><span class=variable>right</span></code> from other symbolic events. </p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_4"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme><span class=variable>Ball</span></code></span>
<span class=comment>;; <code class=scheme><span class=variable>Ball</span></code> = <code class=scheme><span class=variable>Number</span></code></span>

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; erase the existing ball, move it, and draw it again </span>
(<span class=keyword>define</span> (<span class=variable>erase-and-draw</span> <span class=variable>ke</span> <span class=variable>x-ball</span>)
  (<span class=keyword>draw</span> (<span class=variable>ball-erase</span> <span class=variable>x-ball</span>)
        (<span class=variable>ball-paint</span> (<span class=variable>ball-move</span> <span class=variable>ke</span> <span class=variable>x-ball</span>))
        <span class=keyword>produce</span> 
        (<span class=variable>ball-move</span> <span class=variable>ke</span> <span class=variable>x-ball</span>)))

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Ball</span></code></span>
<span class=comment>;; move the ball according to <code class=scheme><span class=variable>ke</span></code></span>
(<span class=keyword>define</span> (<span class=variable>ball-move</span> <span class=variable>ke</span> <span class=variable>x-ball</span>)
  (<span class=keyword>cond</span>
    [(<span class=builtin>char?</span> <span class=variable>ke</span>) <span class=variable>x-ball</span>]
    <span class=comment>;; we now know that <code class=scheme>(<span class=builtin>symbol?</span> <span class=variable>ke</span>)</code> is true</span>
    [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>left</span> <span class=variable>ke</span>) (<span class=builtin>-</span> <span class=variable>x-ball</span> <span class=selfeval>10</span>)]
    [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>right</span> <span class=variable>ke</span>) (<span class=builtin>+</span> <span class=variable>x-ball</span> <span class=selfeval>10</span>)]
    [<span class=keyword>else</span> <span class=variable>x-ball</span>]))

<span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; paint the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-paint</span> <span class=variable>x-ball</span>) (<span class=variable>draw-solid-disk</span> (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))

<span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; earse the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-erase</span> <span class=variable>x-ball</span>) (<span class=variable>clear-solid-disk</span> (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))

<span class=comment>;; run program run </span>
(<span class=keyword>define</span> <span class=variable>ball0</span> <span class=selfeval>150</span>)

(<span class=variable>start</span> <span class=selfeval>300</span> <span class=selfeval>100</span>) <span class=comment>;; create the canvas </span>
(<span class=variable>big-bang</span> <span class=selfeval>1</span> <span class=variable>ball0</span>) <span class=comment>;; specify what the initial world is</span>
(<span class=variable>ball-paint</span> <span class=variable>ball0</span>) <span class=comment>;; paint the initial world on the canvas </span>
(<span class=variable>on-key-event</span> <span class=variable>erase-and-draw</span>) <span class=comment>;; specify how to deal with key events</span>
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 1:</b>&nbsp;&nbsp;Moving a ball</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
Producing a template from the data definition and a full function from the
template and the examples is now straightforward: 
</p>
<div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>ball-move</span> <span class=selfeval>:</span> <span class=variable>KeyEvent</span> <span class=variable>Number</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Number</span></code></span>
<span class=comment>;; to interpret a <code class=scheme><span class=keyword>'</span><span class=variable>left</span></code> or <code class=scheme><span class=keyword>'</span><span class=variable>right</span></code> keystroke as a move</span>
<span class=comment>;; into the appropriate direction by 10 pixels</span>
(<span class=keyword>define</span> (<span class=variable>ball-move</span> <span class=variable>ke</span> <span class=variable>x-ball</span>)
  (<span class=keyword>cond</span>
    [(<span class=builtin>char?</span> <span class=variable>ke</span>) <span class=variable>x-ball</span>]
    [<span class=keyword>else</span> <span class=comment>; we now know that <code class=scheme>(<span class=builtin>symbol?</span> <span class=variable>ke</span>)</code> is true</span>
      (<span class=keyword>cond</span>
        [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>left</span> <span class=variable>ke</span>) (<span class=builtin>-</span> <span class=variable>x-ball</span> <span class=selfeval>10</span>)]
        [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>right</span> <span class=variable>ke</span>) (<span class=builtin>+</span> <span class=variable>x-ball</span> <span class=selfeval>10</span>)]
        [<span class=keyword>else</span> <span class=variable>x-ball</span>])]))
</pre></div><p>
The <code class=scheme><span class=keyword>cond</span></code> expression distinguishes the two subclasses of data in the
data definition; the nested <code class=scheme><span class=keyword>cond</span></code> recognizes the kind of key that the
user pressed. Of course, we can also write this more concisely with a single
<strong>cond</strong>-expression as the definition in figure&nbsp;<a href="#node_fig_Temp_4">1</a>
shows.  The comment line reminds us that we first distinguish two major
subclasses and then cases within this subclass. </p>
<p>
</p>
<p>
Of course, <code class=scheme><span class=variable>ball-move</span></code> doesn&#8217;t really move any ball on any canvas. It
only computes where the ball should appear next on the horizontal line, given
the user&#8217;s keystroke and the ball&#8217;s current position. To accomplish this, we
need a function that uses <code class=scheme><span class=variable>ball-move</span></code>, paints, and erases the ball from
the canvas at the proper time. The function <code class=scheme><span class=variable>erase-and-draw</span></code> in
figure&nbsp;<a href="#node_fig_Temp_4">1</a> accomplishes just that. Like <code class=scheme><span class=variable>ball-move</span></code>,
the function consumes a key event and a ball. It then erases the existing ball
from the canvas, computes where the ball is supposed to be next, paints it
there, and returns this new ball representation.</p>
<p>
To understand how these functions produce the desired effects, we need to study
three more pieces of the <tt>draw.ss</tt> teachpack: 
</p>
<ol>
<li><p><code class=scheme><span class=variable>big-bang</span></code> is a function that consumes a number <code class=scheme><span class=variable>t</span></code> and
a <code class=scheme><span class=variable>World</span></code>. It starts the clock, make it tick every <code class=scheme><span class=variable>t</span></code>
seconds, and sets the world to be <code class=scheme><span class=variable>w</span></code>. A <code class=scheme><span class=variable>World</span></code> is just a
piece of data.</p>
<p>
In our example, the <code class=scheme><span class=variable>World</span></code> is just the <code class=scheme><span class=variable>x</span></code> coordinate of the
ball. After all, from that we know where the ball is, because it moves only on
a vertical line. The bottom of figure&nbsp;<a href="#node_fig_Temp_4">1</a> therefore means that
we first create the canvas and the world and then draw the world. </p>
<p>
</p>
<li><p><code class=scheme>(<span class=keyword>draw</span> <span class=variable>draw-command</span> ... <span class=keyword>produce</span> <span class=variable>e</span>)</code> executes a series of drawing
command and then returns the value of the expression <code class=scheme><span class=variable>e</span></code>. Putting the
previous point and this one together explains why <code class=scheme><span class=variable>erase-and-draw</span></code>
erases the current &#8220;world&#8221; from the canvas and then draw the new one. </p>
<p>
</p>
<li><p><code class=scheme><span class=variable>on-key-event</span></code> consumes a function like <code class=scheme><span class=variable>erase-and-draw</span></code> and
attaches it to the keyboard. We call such functions <small>K</small><small>E</small><small>Y</small> <small>E</small><small>V</small><small>E</small><small>N</small><small>T</small>
<small>H</small><small>A</small><small>N</small><small>D</small><small>L</small><small>E</small><small>R</small>. </p>
<p>
When the player touches a key, DrScheme applies <code class=scheme><span class=variable>erase-and-draw</span></code> to an
appropriate character or symbol and the current world. In turn, the world that
<code class=scheme><span class=variable>erase-and-draw</span></code> produces becomes the current world and thus the
argument for the next application of the function.
</p>
</ol><p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_1.1.1"></a>
<b>Exercise 1.1.1.</b>&nbsp;&nbsp; 
Copy and paste the program from figure&nbsp;<a href="#node_fig_Temp_4">1</a> into DrScheme. Use
it to move the ball around.&nbsp;<a href="../Solutions/key1.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_1.1.2"></a>
<b>Exercise 1.1.2.</b>&nbsp;&nbsp; 
Design the function <code class=scheme><span class=variable>up-or-down</span></code>, which consumes a
<code class=scheme><span class=variable>KeyEvent</span></code> and produces <code class=scheme><span class=builtin>true</span></code> when the input is
<code class=scheme><span class=keyword>'</span><span class=variable>up</span></code>, <code class=scheme><span class=keyword>'</span><span class=variable>down</span></code>, <code class=scheme><span class=selfeval>#\u</span></code>, or <code class=scheme><span class=selfeval>#\d</span></code>.&nbsp;<a href="../Solutions/key2.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_1.1.3"></a>
<b>Exercise 1.1.3.</b>&nbsp;&nbsp; 
Design <code class=scheme><span class=variable>move-4-directions</span></code>.  The function consumes a
<code class=scheme><span class=variable>KeyEvent</span></code> and produces a <code class=scheme><span class=variable>Posn</span></code>. The latter represents how
far the ball on the canvas has to move in one of the four directions
(<code class=scheme><span class=keyword>'</span><span class=variable>left</span></code>, <code class=scheme><span class=keyword>'</span><span class=variable>right</span></code>, <code class=scheme><span class=keyword>'</span><span class=variable>up</span></code>,
<code class=scheme><span class=keyword>'</span><span class=variable>down</span></code>).&nbsp;<a href="../Solutions/key0.html">Solution</a></p>
<p> </p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_1.2"></a>
<h2 class=section>1.2&nbsp;&nbsp;Time</h2>
<p>The <tt><strong>draw.ss</strong></tt> teachpack also supports programs that must react to the
ticking of the clock.  For example, if a program is supposed to move a ball
continuously across the screen, it really means that for each tick of the clock
the program erases the ball from its current position and draws it at the new
position.</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_5"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme><span class=variable>Ball</span></code></span>
<span class=comment>;; <code class=scheme><span class=variable>Ball</span></code> = <code class=scheme><span class=variable>Number</span></code></span>

<span class=comment>;; <code class=scheme><span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; erase the existing ball, move it and draw it again </span>
(<span class=keyword>define</span> (<span class=variable>erase-and-draw</span> <span class=variable>x-ball</span>)
  (<span class=keyword>draw</span> (<span class=variable>ball-erase</span> <span class=variable>x-ball</span>)
        (<span class=variable>ball-paint</span> (<span class=variable>ball-move</span> <span class=variable>x-ball</span>))
        <span class=keyword>produce</span> 
        (<span class=variable>ball-move</span> <span class=variable>x-ball</span>)))

<span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Ball</span></code></span>
<span class=comment>;; move the ball right by 1 pixel </span>
(<span class=keyword>define</span> (<span class=variable>ball-move</span> <span class=variable>x-ball</span>) (<span class=builtin>+</span> <span class=variable>x-ball</span> <span class=selfeval>1</span>))

<span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; paint the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-paint</span> <span class=variable>x-ball</span>) (<span class=variable>draw-solid-disk</span> (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))

<span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; earse the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-erase</span> <span class=variable>x-ball</span>) (<span class=variable>clear-solid-disk</span> (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))

<span class=comment>;; run program run </span>
(<span class=keyword>define</span> <span class=variable>ball0</span> <span class=selfeval>150</span>)

(<span class=variable>start</span> <span class=selfeval>300</span> <span class=selfeval>100</span>)
(<span class=variable>big-bang</span> <span class=selfeval>.1</span> <span class=variable>ball0</span>)
(<span class=variable>ball-paint</span> <span class=variable>ball0</span>)
(<span class=variable>on-tick-event</span> <span class=variable>erase-and-draw</span>)
</pre></div><p> 
</p>
</td></tr>
<tr><td align=center><b>Figure 2:</b>&nbsp;&nbsp;A simple animation</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
Let us see how to solve this programming problem: 
</p>
<blockquote>
Develop a program that draws the movements of a ball as it moves from left to
right across a canvas in a straight line. The clock controls the movement of
the ball, i.e., the ball should move every 1/10 of a second. 
</blockquote>
The problem basically says that the program should apply some function like
<code class=scheme><span class=variable>erase-and-draw</span></code> from figure&nbsp;<a href="#node_fig_Temp_4">1</a> every 1/10 of a
second. Put differently, we need a function that deals with time events but is
otherwise just like a function that deals with keyboard events. <p>
For just such problems, the <tt>draw.ss</tt> teachpack provides two more functions: 
</p>
<ol>
<li><p><b>4.</b>&nbsp;&nbsp; <code class=scheme><span class=variable>on-tick-event</span></code>, which consumes a function that is applied
every tick of the clock. The function is a <small>T</small><small>I</small><small>M</small><small>E</small> <small>E</small><small>V</small><small>E</small><small>N</small><small>T</small>
<small>H</small><small>A</small><small>N</small><small>D</small><small>L</small><small>E</small><small>R</small>. In contrast to a key event handler, it consumes only a
representation of the world not other value; its result is also a
<code class=scheme><span class=variable>World</span></code>.</p>
<p>
</p>
<li><p><b>5.</b>&nbsp;&nbsp; <code class=scheme><span class=variable>end-of-time</span></code>, which stops the time and produces the last
<code class=scheme><span class=variable>World</span></code>. 
</p>
</ol><p>
Hence, just as in the section on key events, we must first agree on what
represents the world and then we can design event handlers that deal with this
<code class=scheme><span class=variable>World</span></code>.</p>
<p>
Figure&nbsp;<a href="#node_fig_Temp_5">2</a> displays the code for the specified animation.  As
before, our world consists of just one ball and, to be more precise, of its
<code class=scheme><span class=variable>x</span></code> coordinate, which is a number. Everything else remains as the ball
moves across the canvas. Computing the new coordinate of the ball becomes much
simpler. Since it doesn&#8217;t depend on a keystroke anymore, our new
<code class=scheme><span class=variable>ball-move</span></code> function just adds <code class=scheme><span class=selfeval>1</span></code> to the current value of the
<code class=scheme><span class=variable>x</span></code> coordinate. This represents a move to the right. The other functions
are the same as before.</p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_1.2.1"></a>
<b>Exercise 1.2.1.</b>&nbsp;&nbsp; 
Copy and paste the program from figure&nbsp;<a href="#node_fig_Temp_5">2</a> into DrScheme. Watch
the ball move by itself.&nbsp;<a href="../Solutions/time1.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_1.2.2"></a>
<b>Exercise 1.2.2.</b>&nbsp;&nbsp; 
Develop a program that simulates the drop of a ball from the top of the canvas
to the bottom of the canvas. Represent the world as a structure: 
</p>
<div align=left><pre class=scheme>(<span class=keyword>define-struct</span> <span class=variable>world</span> (<span class=variable>t</span> <span class=variable>y</span>))
<span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme>(<span class=builtin>make-world</span> <span class=variable>Number</span> <span class=variable>Number</span>)</code></span>
</pre></div><p> 
The first number in the structure represents the number of times that the
handler has been invoked since <code class=scheme><span class=variable>big-bang</span></code>, and the second one
represents the current <code class=scheme><span class=variable>y</span></code> coordinate of the ball. The ball&#8217;s
position is determined by the formula:
</p>
<div class=mathdisplay align=center><table><tr><td> <em>y</em>  =  (1/2)  &middot;  5  &middot;  <em>t</em><sup>2</sup> </td></tr></table></div>
<p class=noindent>
where <code class=scheme><span class=variable>t</span></code> is the current time. Hint: Try <code class=scheme>(<span class=builtin>make-world</span> <span class=selfeval>0</span> <span class=selfeval>0</span>)</code>
as the initial world. What does it represent? What should the next world
look like?&nbsp;<a href="../Solutions/time2.html">Solution</a></p>
<p></p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_6"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">


<img src=Images/shots.jpg alt="[Stopping a UFO]">
</p>
</td></tr>
<tr><td align=center><b>Figure 3:</b>&nbsp;&nbsp;Stopping a UFO</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
</p>

<p class=noindent><strong>Teaching Note</strong>: The goal is to keep the functional portion
separated from the drawing and event-based portion of the program. To this end,
we use a program design discipline that separates the computations from the
visible actions. The discipline is often referred to as model-view
separation. Indeed, the idea of programming in DrScheme is based on this idea,
too. DrScheme provides rudimentary views and students can focus on writing the
functions proper.&nbsp;</p>
<p>
</p>
<a name="node_sec_2"></a>
<h1 class=section>2&nbsp;&nbsp;Stopping a UFO</h1>
<p>The goal of this extended exercise is to develop a simple interactive
game. Imagine the approach of a UFO, falling out of the blue sky. You&#8217;re
riding a modern AUP (anti-UFO platform), and your task is to stop the UFO
from crossing the line, i.e., the bottom of the canvas. Your powerful AUP
can move left or right, and it can shoot at the UFO in straight lines. The
means of last resort is to make sure the UFO crashes into your AUP. If the
UFO makes it across the line, you lost; otherwise you win.</p>
<p>
Figure&nbsp;<a href="#node_fig_Temp_6">3</a> contains a screen shot of the game. The (green) saucer on
the canvas is the UFO; the line at the bottom is your AUP. The straight lines
going up and through the UFO are the shots that the AUP fired.</p>
<p>
The section consists of three subsections. Each corresponds to a stage in
the design process. The subsections illustrate what we call the iterative
refinement process (see section&nbsp;16). The goal of iterative refinement is
to implement the core functionality of a product and to add pieces of the
functionality step by step. Here we present the method via an example;
take a look at the sections on iterative refinement in <i>How to Design
Programs</i> for a thorough description of the idea. </p>
<p>
</p>
<a name="node_sec_2.1"></a>
<h2 class=section>2.1&nbsp;&nbsp;UFOs</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">6.1 Structures</a>
<br>

</p>

<p class=noindent>T<small>E</small><small>A</small><small>C</small><small>H</small><small>P</small><small>A</small><small>C</small><small>K</small>: <a href="draw.ss">draw.ss</a><br>
</p>
<p>
</p>

<p class=noindent>The first goal is to create a UFO that drops from the top of a
canvas to the bottom. The function that does the repetitive work and the
fragment that starts the game are defined in figure&nbsp;<a href="#node_fig_Temp_7">4</a>.  The
following exercises show how to fill in the dots.</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_7"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme><span class=variable>UFO</span></code></span>

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Boolean</span></code></span>
<span class=comment>;; fly UFO until it lands on bottom </span>
(<span class=keyword>define</span> (<span class=variable>fly-until-down</span> <span class=variable>ufo</span>)
  (<span class=keyword>and</span> (<span class=variable>start</span> <span class=variable>WIDTH</span> <span class=variable>HEIGHT</span>)
       (<span class=variable>big-bang</span> <span class=selfeval>.1</span> <span class=variable>ufo</span>)
       (<span class=variable>ufo-draw</span> <span class=variable>ufo</span>)
       (<span class=variable>on-tick-event</span> <span class=variable>new-scene</span>)))

<span class=comment>;; <code class=scheme><span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; erase old scene, create new one, draw it and produce it. </span>
(<span class=keyword>define</span> (<span class=variable>new-scene</span> <span class=variable>w</span>) 
  (<span class=variable>ufo-erase-and-draw</span> <span class=variable>w</span> (<span class=variable>ufo-move</span> <span class=variable>w</span>)))

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>UFO</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>UFO</span></code></span>
<span class=comment>;; erase old ufo and draw new one, unless it&#8217;s at the bottom </span>
(<span class=keyword>define</span> (<span class=variable>ufo-erase-and-draw</span> <span class=variable>old-ufo</span> <span class=variable>new-ufo</span>)  
  (<span class=keyword>cond</span>
    [(<span class=variable>ufo-at-bottom?</span> <span class=variable>new-ufo</span>) (<span class=variable>end-of-time</span>)]
    [<span class=keyword>else</span> (<span class=keyword>draw</span> (<span class=variable>ufo-clear</span> <span class=variable>old-ufo</span>)
                (<span class=variable>ufo-draw</span> <span class=variable>new-ufo</span>)
                <span class=keyword>produce</span>
                <span class=variable>new-ufo</span>)]))
...
<span class=comment>;; Constants </span>
(<span class=keyword>define</span> <span class=variable>WIDTH</span> <span class=selfeval>200</span>)
(<span class=keyword>define</span> <span class=variable>HEIGHT</span> <span class=selfeval>500</span>)

<span class=comment>;; run program, run</span>
(<span class=variable>fly-until-down</span> (<span class=variable>ufo-create</span> (<span class=builtin>random</span> <span class=variable>WIDTH</span>)))
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 4:</b>&nbsp;&nbsp;Flying a UFO</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
We adopt the usual conventions from physics and think of the UFO as just a
position on the canvas:
</p>
<div align=left><pre class=scheme><span class=comment>;; A <code class=scheme><span class=variable>UFO</span></code> is a <code class=scheme><span class=variable>Posn</span></code>: <code class=scheme><span class=variable>UFO</span></code> = <code class=scheme><span class=variable>Posn</span></code></span>
</pre></div><p>
When we draw the UFO we think of it as a green disk whose center
is the <code class=scheme><span class=variable>Posn</span></code> with which we represent it. Or, we think of it as
something more elaborate, but for now this doesn&#8217;t matter. We can always
change our understanding; we just need to keep in mind what the
<code class=scheme><span class=variable>Posn</span></code> represents. To remind ourselves of this relationship
(between data and information), we call the <code class=scheme><span class=variable>Posn</span></code> that represents
a UFO an <em>anchor point</em>.</p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.1.1"></a>
<b>Exercise 2.1.1.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>ufo-create</span></code>, which consumes a number
<code class=scheme><span class=variable>n</span></code> and produces a UFO whose anchor point is at the top of the
canvas <code class=scheme><span class=variable>n</span></code> pixels to the right of the canvas
origin.&nbsp;<a href="../Solutions/ufo-create.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.1.2"></a>
<b>Exercise 2.1.2.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>ufo-move</span></code>, which consumes a <code class=scheme><span class=variable>UFO</span></code>
(representation) and produces one whose anchor point is <code class=scheme><span class=selfeval>3</span></code> pixels
below the given one. </p>
<p>
Modify <code class=scheme><span class=variable>ufo-move</span></code> so that it produces a <code class=scheme><span class=variable>UFO</span></code> that has
dropped <code class=scheme><span class=selfeval>3</span></code> pixels and has moved randomly to the left or right by
up to <code class=scheme><span class=selfeval>4</span></code> pixels.
Hint: Use the function <code class=scheme><span class=builtin>random</span></code>, which consumes a positive number
<code class=scheme><span class=variable>n</span></code> and produces a number between <code class=scheme><span class=selfeval>0</span></code> (inclusive) and
<code class=scheme><span class=variable>n</span></code> (exclusive). Two consecutive calls may or may not produce the
same number. Design the function <code class=scheme><span class=variable>random-range</span></code>, which consumes
<code class=scheme><span class=variable>n</span></code> and produces a number between  <tt>-</tt> <em>n</em> and  + <em>n</em>. </p>
<p>
Challenge: Revise <code class=scheme><span class=variable>ufo-move-ran</span></code> so that a <code class=scheme><span class=variable>UFO</span></code> that has
disappeared on the left or right of the canvas reappears on the other side for
the next time slice. Modify the program in figure&nbsp;<a href="#node_fig_Temp_7">4</a> so that it uses
<code class=scheme><span class=variable>ufo-move-ran</span></code>.&nbsp;<a href="../Solutions/ufo-move.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.1.3"></a>
<b>Exercise 2.1.3.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>ufo-at-bottom?</span></code>, which consumes a <code class=scheme><span class=variable>UFO</span></code>
(representation) and determines whether its anchor point is level with, or
below, the bottom of the canvas.&nbsp;<a href="../Solutions/ufo-bottom.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.1.4"></a>
<b>Exercise 2.1.4.</b>&nbsp;&nbsp; 
Design the function <code class=scheme><span class=variable>ufo-draw</span></code>, which consumes the representation of
a ufo and draws it on the canvas.</p>
<p>
Also design <code class=scheme><span class=variable>ufo-clear</span></code>, which consumes the representation of a ufo and
clears it from the canvas.</p>
<p>
Draw the UFO as a green disk of radius <code class=scheme><span class=selfeval>3</span></code> around the anchor point.
For the ambitious, draw the UFO as a green line of length <code class=scheme><span class=selfeval>20</span></code> with
a disk of radius <code class=scheme><span class=selfeval>3</span></code> in the center.&nbsp;<a href="../Solutions/draw-clear.html">Solution</a></p>
<p></p>
<p>
Now watch the UFO fly down from top to bottom (in a random walk). </p>
<p>
</p>
<a name="node_sec_2.2"></a>
<h2 class=section>2.2&nbsp;&nbsp;AUPs</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">7.1 Varieties of Data</a></p>
<p>
</p>

<p class=noindent>Now it&#8217;s time to develop our defenses. An AUP defends the bottom
of the canvas where it can move left or right.</p>
<p>
</p>
<p><a name="node_thm_2.2.1"></a>
<b>Exercise 2.2.1.</b>&nbsp;&nbsp;  
Develop a data definition for AUPs. Keep in mind that an AUP is always at the
bottom of the canvas, and that it always has the same
shape.&nbsp;<a href="../Solutions/aup-defdd.html">Solution</a></p>
<p></p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_8"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme><span class=variable>AUP</span></code></span>

<span class=comment>;; <code class=scheme><span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>Boolean</span></code></span>
<span class=comment>;; create a world with an AUP and install an event handler for it</span>
(<span class=keyword>define</span> (<span class=variable>controller</span> <span class=variable>aup</span>)
  (<span class=keyword>and</span> (<span class=variable>start</span> <span class=variable>WIDTH</span> <span class=variable>HEIGHT</span>)
       (<span class=variable>big-bang</span> <span class=selfeval>1</span> <span class=variable>aup</span>)
       (<span class=variable>aup-draw</span> <span class=variable>aup</span>)
       (<span class=variable>on-key-event</span> <span class=variable>new-aup-scene</span>)))

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; erase old scene, create new one, draw it and produce it. </span>
(<span class=keyword>define</span> (<span class=variable>new-aup-scene</span> <span class=variable>ke</span> <span class=variable>w</span>)
  (<span class=variable>aup-erase-and-draw</span> <span class=variable>w</span> (<span class=variable>aup-move</span> <span class=variable>ke</span> <span class=variable>w</span>)))

<span class=comment>;; <code class=scheme><span class=variable>AUP</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>AUP</span></code></span>
(<span class=keyword>define</span> (<span class=variable>aup-erase-and-draw</span> <span class=variable>old-aup</span> <span class=variable>new-aup</span>)  
  (<span class=keyword>draw</span> (<span class=variable>aup-clear</span> <span class=variable>old-aup</span>)
        (<span class=variable>aup-draw</span> <span class=variable>new-aup</span>)
        <span class=keyword>produce</span>
        <span class=variable>new-aup</span>))

...

<span class=comment>;; Constants </span>
(<span class=keyword>define</span> <span class=variable>WIDTH</span> <span class=selfeval>200</span>)
(<span class=keyword>define</span> <span class=variable>HEIGHT</span> <span class=selfeval>500</span>)

<span class=comment>;; run program, run</span>
(<span class=variable>controller</span> (<span class=variable>create-aup</span> <span class=selfeval>0</span>))
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 5:</b>&nbsp;&nbsp;Controlling an AUP</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
</p>
<p><a name="node_thm_2.2.2"></a>
<b>Exercise 2.2.2.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>aup-create</span></code>, which consumes a number
<code class=scheme><span class=variable>n</span></code> and produces an <code class=scheme><span class=variable>AUP</span></code> that is <code class=scheme><span class=variable>n</span></code> pixels to the
right of the canvas&#8217;s left margin.&nbsp;<a href="../Solutions/aup-create.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.2.3"></a>
<b>Exercise 2.2.3.</b>&nbsp;&nbsp;  
Design <code class=scheme><span class=variable>aup-move</span></code>. The function consumes an <code class=scheme><span class=variable>AUP</span></code>
(representation) and a <code class=scheme><span class=variable>KeyEvent</span></code>. It produces an <code class=scheme><span class=variable>AUP</span></code> that
has moved to the left or right by one (<code class=scheme><span class=selfeval>1</span></code>) pixel, if the player
has pressed the left or right arrow key; otherwise, it just returns the
given <code class=scheme><span class=variable>AUP</span></code>.&nbsp;<a href="../Solutions/aup-move.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.2.4"></a>
<b>Exercise 2.2.4.</b>&nbsp;&nbsp; 
Design the function <code class=scheme><span class=variable>aup-draw</span></code>, which consumes a <code class=scheme><span class=variable>AUP</span></code> and
draws it on the  canvas.</p>
<p>
Also design <code class=scheme><span class=variable>aup-clear</span></code>, which consumes a <code class=scheme><span class=variable>AUP</span></code> and clears it from
the canvas.</p>
<p>
Think of the AUP as a blue line of width
<code class=scheme><span class=selfeval>10</span></code>.&nbsp;<a href="../Solutions/aup-draw-clear.html">Solution</a></p>
<p></p>
<hr>
<p></p>
<p></p>
<p></p>
<p>
The program fragment in figure&nbsp;<a href="#node_fig_Temp_8">5</a> allows players to control an
<code class=scheme><span class=variable>AUP</span></code> via the arrow keys on the keyboard. It requires well-developed
solutions for all the exercises in this subsection. Don&#8217;t rush. Follow the
design recipe.</p>
<p>
</p>
<a name="node_sec_2.3"></a>
<h2 class=section>2.3&nbsp;&nbsp;Putting it all together</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">7.1 Varieties of Data</a></p>
<p>
</p>

<p class=noindent>With UFOs and AUPs in place we can create our first interactive game.
First, we need to merge the code from figures&nbsp;<a href="#node_fig_Temp_7">4</a>
and&nbsp;<a href="#node_fig_Temp_8">5</a>. That gives us a world in which a UFO descends from the top
and the AUP is movable via the arrow keys. </p>
<p>
Figure&nbsp;<a href="#node_fig_Temp_9">6</a> contains the result of the merger. The world is now a
structure with two fields: one for the UFO and one for the AUP. The
<code class=scheme><span class=variable>game</span></code> function sets up two handlers: one for the keyboard events and
one for the time events. The remaining functions are from the previous
programs, except that all those whose contract contains <code class=scheme><span class=variable>World</span></code> need
some adjustments.</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_9"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme>(<span class=keyword>define-struct</span> <span class=variable>world</span> (<span class=variable>ufo</span> <span class=variable>aup</span>))
<span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme>(<span class=builtin>make-world</span> <span class=variable>UFO</span> <span class=variable>AUP</span>)</code></span>

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; set up world with UFO and AUP and add event handlers </span>
(<span class=keyword>define</span> (<span class=variable>game</span> <span class=variable>ufo</span> <span class=variable>aup</span>)
  (<span class=keyword>and</span> (<span class=variable>start</span> <span class=variable>WIDTH</span> <span class=variable>HEIGHT</span>)
       (<span class=variable>big-bang</span> <span class=selfeval>.1</span> (<span class=builtin>make-world</span> <span class=variable>ufo</span> <span class=variable>aup</span>))
       (<span class=variable>ufo-draw</span> <span class=variable>ufo</span>)
       (<span class=variable>aup-draw</span> <span class=variable>aup</span>)
       (<span class=variable>on-key-event</span> <span class=variable>new-aup-scene</span>)
       (<span class=variable>on-tick-event</span> <span class=variable>new-scene</span>)))

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
(<span class=keyword>define</span> (<span class=variable>new-aup-scene</span> <span class=variable>ke</span> <span class=variable>w</span>)
  (<span class=builtin>make-world</span>
    (<span class=builtin>world-ufo</span> <span class=variable>w</span>)
    (<span class=variable>aup-erase-and-draw</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>) (<span class=variable>aup-move</span> <span class=variable>ke</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>)))))

<span class=comment>;; <code class=scheme><span class=variable>AUP</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>AUP</span></code></span>
(<span class=keyword>define</span> (<span class=variable>aup-erase-and-draw</span> <span class=variable>old-aup</span> <span class=variable>new-aup</span>)  
  (<span class=keyword>draw</span> (<span class=variable>aup-clear</span> <span class=variable>old-aup</span>)
        (<span class=variable>aup-draw</span> <span class=variable>new-aup</span>)
        <span class=keyword>produce</span>
        <span class=variable>new-aup</span>))

<span class=comment>;; <code class=scheme><span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
(<span class=keyword>define</span> (<span class=variable>new-scene</span> <span class=variable>w</span>)
  (<span class=builtin>make-world</span>
    (<span class=variable>ufo-erase-and-draw</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>) (<span class=variable>ufo-move</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)))
    (<span class=builtin>world-aup</span> <span class=variable>w</span>)))

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>UFO</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>UFO</span></code></span>
(<span class=keyword>define</span> (<span class=variable>ufo-erase-and-draw</span> <span class=variable>old-ufo</span> <span class=variable>new-ufo</span>)  
  (<span class=keyword>cond</span>
    [(<span class=variable>ufo-at-bottom?</span> <span class=variable>new-ufo</span>) (<span class=variable><u><code class=scheme><span class=variable>announcement</span></code></u></span> <span class=variable>old-ufo</span> (<span class=variable>end-of-time</span>))]
    [<span class=keyword>else</span> (<span class=keyword>draw</span> (<span class=variable>ufo-clear</span> <span class=variable>old-ufo</span>)
                (<span class=variable>ufo-draw</span> <span class=variable>new-ufo</span>)
                <span class=keyword>produce</span>
                <span class=variable>new-ufo</span>)]))
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 6:</b>&nbsp;&nbsp;Crashing a UFO</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
The other major addition in figure&nbsp;<a href="#node_fig_Temp_9">6</a> concerns the end of the
game. In the original code for flying a UFO, the animation just stopped when
the UFO reached the ground. Now we should announce the result of the
game. After all, the player can win or lose. To this end we apply the new
<code class=scheme><span class=variable>announcement</span></code> function to the current world. If the UFO crashes on the
AUP, the player wins; otherwise, it&#8217;s a loss. </p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.3.1"></a>
<b>Exercise 2.3.1.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>landed-on-aup?</span></code>. It determines whether some
given <code class=scheme><span class=variable>UFO</span></code> has landed on a given <code class=scheme><span class=variable>AUP</span></code>.</p>
<p>
Hint: Recall the geometric interpretation that goes with each data
representation. Then draw pictures and determine what it means for the UFO
shape to overlap with the AUP shape. If you can&#8217;t get it completely right,
approximate what it means for the two shapes to overlap as best as you can. Of
course, you must then expect to see these simplifications as you play the
game.&nbsp;<a href="../Solutions/all1-landed-on.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.3.2"></a>
<b>Exercise 2.3.2.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>announcement</span></code>. It consumes a <code class=scheme><span class=variable>World</span></code> and
produces <code class=scheme><span class=builtin>true</span></code>. If the UFO in the <code class=scheme><span class=variable>World</span></code> landed on the AUP in
the <code class=scheme><span class=variable>World</span></code>, it draws the string <code class=scheme><span class=selfeval>&quot;you win&quot;</span></code> on the canvas;
otherwise, it writes <code class=scheme><span class=selfeval>&quot;you lose&quot;</span></code>.</p>
<p>
Hint: Which function in the game code applies <code class=scheme><span class=variable>announcement</span></code> to the
<code class=scheme><span class=variable>World</span></code> and which world is it? Simulate such worlds for the
tests.&nbsp;<a href="../Solutions/all1-announcement.html">Solution</a></p>
<p></p>
<p>
</p>
<a name="node_sec_2.4"></a>
<h2 class=section>2.4&nbsp;&nbsp;One shot at the UFO</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">7.1 Varieties of Data</a></p>
<p>
</p>

<p class=noindent>The chief engineer has figured out how to let AUP&#8217;s fire a gun&#8212;once.
This means that an AUP now has two chances to stop the UFO. Either the AUP
shoots and that one shot hits the UFO or it manages to stop the UFO via a
crash. We already have a program that does the latter; let&#8217;s develop a
program that simulates the new ability to shoot. </p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.1"></a>
<b>Exercise 2.4.1.</b>&nbsp;&nbsp;  
Develop a data definition for representing a shot.  Make up examples
and show what each example means in
figure&nbsp;<a href="#node_fig_Temp_6">3</a>.&nbsp;<a href="../Solutions/shot-defdd.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.2"></a>
<b>Exercise 2.4.2.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>shot-create</span></code>, which consumes an <code class=scheme><span class=variable>AUP</span></code> and
produces (the representation of) a shot that has just left the AUP. Assume the
shot leaves from the middle of the AUP.&nbsp;<a href="../Solutions/shot-create.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.3"></a>
<b>Exercise 2.4.3.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>shot-move</span></code>, which consumes a <code class=scheme><span class=variable>Shot</span></code>
(representation) and produces one that has risen <code class=scheme><span class=selfeval>5</span></code>
pixels.&nbsp;<a href="../Solutions/shot-move.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.4"></a>
<b>Exercise 2.4.4.</b>&nbsp;&nbsp; 
Design the function <code class=scheme><span class=variable>shot-draw</span></code>, which consumes the representation of a
shot and draws it on the canvas.</p>
<p>
Also design <code class=scheme><span class=variable>shot-clear</span></code>, which consumes the representation of a
shot and clears it from the canvas.</p>
<p>
Think of a shot as a vertical red line of length
<code class=scheme><span class=selfeval>5</span></code>.&nbsp;<a href="../Solutions/draw-shot-clear.html">Solution</a></p>
<p></p>
<hr>
<p></p>
<p></p>
<p></p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_10"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; set up world with UFO and AUP and add event handlers </span>
(<span class=keyword>define</span> (<span class=variable>game</span> <span class=variable>ufo</span> <span class=variable>aup</span>) ...)

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
(<span class=keyword>define</span> (<span class=variable>new-aup-scene</span> <span class=variable>ke</span> <span class=variable>w</span>)
  (<span class=keyword>cond</span>
    [(<span class=builtin>char?</span> <span class=variable>ke</span>) <span class=variable>w</span>]
    [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>up</span> <span class=variable>ke</span>)
     (<span class=keyword>cond</span>
       [(<span class=builtin>boolean?</span> (<span class=variable>shot-world</span> <span class=variable>w</span>)) 
	(<span class=builtin>make-world</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>) (<span class=builtin>world-aup</span> <span class=variable>w</span>) (<span class=variable>shot-create</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>)))]
       [<span class=keyword>else</span> <span class=variable>w</span>])]
    [<span class=keyword>else</span> (<span class=builtin>make-world</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)
	    (<span class=variable>aup-erase-and-draw</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>) (<span class=variable>aup-move</span> <span class=variable>ke</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>)))
	    (<span class=builtin>world-shot</span> <span class=variable>w</span>))]))

<span class=comment>;; <code class=scheme><span class=variable>AUP</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>AUP</span></code></span>
<span class=comment>;; erase old AUP, draw new one, and produce it</span>
(<span class=keyword>define</span> (<span class=variable>erase-and-draw</span> <span class=variable>aup-old</span> <span class=variable>aup-new</span>) ...)

<span class=comment>;; <code class=scheme><span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
(<span class=keyword>define</span> (<span class=variable>new-scene</span> <span class=variable>w</span>)
  (<span class=keyword>cond</span>
    [(<span class=builtin>boolean?</span> (<span class=builtin>world-shot</span> <span class=variable>w</span>)) 
     (<span class=builtin>make-world</span>
       (<span class=variable>ufo-erase-and-draw</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>) (<span class=variable>ufo-move</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)))
       (<span class=builtin>world-aup</span> <span class=variable>w</span>)
       <span class=builtin>false</span>)]
    [(<span class=variable><u><code class=scheme><span class=variable>hit-shot?</span></code></u></span> (<span class=builtin>world-shot</span> <span class=variable>w</span>) (<span class=builtin>world-ufo</span> <span class=variable>w</span>)) (<span class=variable><u><code class=scheme><span class=variable>announcement</span></code></u></span> (<span class=variable>end-of-time</span>))]
    [<span class=keyword>else</span> (<span class=builtin>make-world</span>
	    (<span class=variable>ufo-erase-and-draw</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>) (<span class=variable>ufo-move</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)))
	    (<span class=builtin>world-aup</span> <span class=variable>w</span>)
	    (<span class=variable><u><code class=scheme><span class=variable>shot-erase-and-draw</span></code></u></span> (<span class=builtin>world-shot</span> <span class=variable>w</span>) (<span class=variable>shot-move</span> (<span class=builtin>world-shot</span> <span class=variable>w</span>))))]))

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>UFO</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>UFO</span></code></span>
<span class=comment>;; erase old ufo and draw new one, unless it&#8217;s at the bottom </span>
(<span class=keyword>define</span> (<span class=variable>ufo-erase-and-draw</span> <span class=variable>old-ufo</span> <span class=variable>new-ufo</span>) ...)
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 7:</b>&nbsp;&nbsp;Crashing or shooting down a UFO</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
Now that we have functions for creating, drawing, erasing, and moving shots, we
can turn our attention to the code that drives the animation. Let&#8217;s inspect
each element of figure&nbsp;<a href="#node_fig_Temp_9">6</a> and see how we need to adapt it: 
</p>
<ol>
<li><p>The first element defines the <code class=scheme><span class=variable>World</span></code> as a structure of two
components: a UFO and an AUP. Naturally, we need to add a field in order to
keep track of the shot that the AUP can fire:
</p>
<div align=left><pre class=scheme>(<span class=keyword>define-struct</span> <span class=variable>world</span> (<span class=variable>ufo</span> <span class=variable>aup</span> <span class=variable>shot</span>))
</pre></div><p>
Although it is tempting to say that <code class=scheme>(<span class=builtin>make-world</span> <span class=variable>UFO</span> <span class=variable>AUP</span> <span class=variable>Shot</span>)</code>
constructs a world, it is also clearly incorrect. Initially no shot has been
fired, and we need to leave the timing of the shot to the player. Hence, we
define the class of <code class=scheme><span class=variable>World</span></code>s as follows: 
</p>
<div align=left><pre class=scheme>(<span class=keyword>define-struct</span> <span class=variable>world</span> (<span class=variable>ufo</span> <span class=variable>aup</span> <span class=variable>shot</span>))
<span class=comment>;; <code class=scheme><span class=variable>World</span></code> = <code class=scheme>(<span class=builtin>make-world</span> <span class=variable>UFO</span> <span class=variable>AUP</span> <span class=variable>Shot/f</span>)</code></span>

<span class=comment>;; A Shot/f is one of the following: </span>
<span class=comment>;; --- a shot ; (see exercise&nbsp;<a href="#node_thm_2.4.1">2.4.1</a>)</span>
<span class=comment>;; --- false</span>
</pre></div><p>
In other words, as long as no shot has been fired, the <code class=scheme><span class=variable>shot</span></code> field
is <code class=scheme><span class=builtin>false</span></code>; afterwards, it contains the shot. </p>
<p>
</p>
<li><p>The second element in figure&nbsp;<a href="#node_fig_Temp_9">6</a> is an event handler for time
events. It consumes a world, erases it, computes new values for those pieces
that move with each tick event, and draws those. Its result is the new world. 
Since the definition of what a world is has changed, we must also modify this
event handler. </p>
<p>
</p>
<li><p>The third and last critical element in figure&nbsp;<a href="#node_fig_Temp_9">6</a> is the key
event handler. Like the time event handler, it consumes a world and produces
one. The modified handler must not only check for left and right arrow keys,
but also for up (&uarr;), which we take as a signal to fire the single shot
in the AUP.
</p>
</ol><p>
Turning these thoughts into code yields the definitions in
figure&nbsp;<a href="#node_fig_Temp_10">7</a>. The following exercises specify the purpose of the
underlined functions. The others remain the same. </p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.5"></a>
<b>Exercise 2.4.5.</b>&nbsp;&nbsp; 
Formulate purpose statements for the functions <code class=scheme><span class=variable>new-scene</span></code> and
<code class=scheme><span class=variable>new-aup-scene</span></code> compute. Then explain <em>how</em> they compute their
results.&nbsp;<a href="../Solutions/explain2.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.6"></a>
<b>Exercise 2.4.6.</b>&nbsp;&nbsp; 
Design the function <code class=scheme><span class=variable>hit-shot?</span></code>, which determines whether a shot has
hit a UFO. The function consumes an <code class=scheme><span class=variable>Shot</span></code> and a <code class=scheme><span class=variable>UFO</span></code>. It
produces <code class=scheme><span class=builtin>true</span></code> if there is any overlap between the <code class=scheme><span class=variable>UFO</span></code>
and <code class=scheme><span class=variable>Shot</span></code>.  Hint: Recall the geometric interpretation that goes
with each data representation. Then draw pictures and determine what it
means to figure out whether the two geometric shapes overlap.  Approximate
&#8220;hit by a shot&#8221; as best as you can; expect to see these simplifications
as you play the game.&nbsp;<a href="../Solutions/hit-shot.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.7"></a>
<b>Exercise 2.4.7.</b>&nbsp;&nbsp; 
Modify <code class=scheme><span class=variable>announcement</span></code> so that it writes <code class=scheme><span class=selfeval>&quot;you win&quot;</span></code> on the canvas
when the UFO is hit by a shot or when it crashes into the
AUP.&nbsp;<a href="../Solutions/announcement2.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.4.8"></a>
<b>Exercise 2.4.8.</b>&nbsp;&nbsp; 
Design <code class=scheme><span class=variable>shot-erase-and-draw</span></code>. The function consumes the old shot and the
new shot. It erases the old one, draws the new one, and produces it as a
result.&nbsp;<a href="../Solutions/shot-erase-and-draw.html">Solution</a></p>
<p></p>
<p>
</p>
<a name="node_sec_2.5"></a>
<h2 class=section>2.5&nbsp;&nbsp;Many Shots</h2>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">10.2 Lists that Contain Structures</a></p>
<p>
</p>

<p class=noindent>The true goal is to simulate an AUP-UFO fight like the one in
figure&nbsp;<a href="#node_fig_Temp_6">3</a>. The AUP in the figure can obviously fire many shots,
not just one. Since &#8220;many&#8221; clearly means &#8220;arbitrary&#8221; and &#8220;unknown&#8221;, we
need a list of shots. Put differently, we need to revise our structure
definition and our data definition for <code class=scheme><span class=variable>World</span></code>:
</p>
<div align=left><pre class=scheme>(<span class=keyword>define-struct</span> <span class=variable>world</span> (<span class=variable>ufo</span> <span class=variable>aup</span> <span class=variable>shots</span>))
<span class=comment>;; World = <code class=scheme>(<span class=builtin>make-world</span> <span class=variable>UFO</span> <span class=variable>AUP</span> <span class=variable>LoShots</span>)</code></span>
</pre></div><p>
and we must revise all the functions that deal with <code class=scheme><span class=variable>World</span></code>s. </p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.1"></a>
<b>Exercise 2.5.1.</b>&nbsp;&nbsp;  
Develop a data definition for representing a list of
shots.&nbsp;<a href="../Solutions/lshots-defdd.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.2"></a>
<b>Exercise 2.5.2.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>all-shots-move</span></code>, which consumes a list of
shots and produces one where each shot has been moved with
<code class=scheme><span class=variable>shot-move</span></code>.&nbsp;<a href="../Solutions/map-move.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.3"></a>
<b>Exercise 2.5.3.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>all-shots-draw</span></code>, which consumes a list of
shots, draws all of them, and produces <code class=scheme><span class=builtin>true</span></code> if all drawing
actions succeed.</p>
<p>
Design the function <code class=scheme><span class=variable>all-shots-clear</span></code>, which consumes a list of
shots, clears all of them, and produces <code class=scheme><span class=builtin>true</span></code> if all drawing
actions succeed.&nbsp;<a href="../Solutions/map-draw.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.4"></a>
<b>Exercise 2.5.4.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>hit-by-any-shot?</span></code>. It consumes a list of
<code class=scheme><span class=variable>Shot</span></code>s and a <code class=scheme><span class=variable>UFO</span></code>. It produces <code class=scheme><span class=builtin>true</span></code> if one of the
<code class=scheme><span class=variable>Shot</span></code>s has hit the <code class=scheme><span class=variable>UFO</span></code>; it produces <code class=scheme><span class=builtin>false</span></code> if
none of the <code class=scheme><span class=variable>Shot</span></code>s has hit the
<code class=scheme><span class=variable>UFO</span></code>.&nbsp;<a href="../Solutions/map-hit.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.5"></a>
<b>Exercise 2.5.5.</b>&nbsp;&nbsp;  
Design the function <code class=scheme><span class=variable>shots-erase-and-clear</span></code>. It consumes two lists of
shots. The first one is the list of shots that needs to be erased, the second
one is the list of shots that need to be drawn. The function produces the second
list of shots. See&nbsp;<a href="#node_fig_Temp_11">8</a>.&nbsp;<a href="../Solutions/shots-erase-and-clear.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.5.6"></a>
<b>Exercise 2.5.6.</b>&nbsp;&nbsp; 
Revise <code class=scheme><span class=variable>announcement</span></code> exercise&nbsp;<a href="#node_thm_2.4.7">2.4.7</a>. Instead of a
<code class=scheme><span class=variable>Shot/f</span></code>, the function now consumes a list of
<code class=scheme><span class=variable>Shot</span></code>s.&nbsp;<a href="../Solutions/draw-scene-v2.html">Solution</a></p>
<p></p>
<hr>
<p></p>
<p></p>
<p></p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_11"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; set up world with UFO and AUP and add event handlers </span>
(<span class=keyword>define</span> (<span class=variable>game</span> <span class=variable>ufo</span> <span class=variable>aup</span>) ...)

<span class=comment>;; <code class=scheme><span class=variable>KeyEvent</span> <span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; create world with moved AUP</span>
(<span class=keyword>define</span> (<span class=variable>new-aup-scene</span> <span class=variable>ke</span> <span class=variable>w</span>)
  (<span class=keyword>cond</span>
    [(<span class=builtin>char?</span> <span class=variable>ke</span>) <span class=variable>w</span>]
    [(<span class=builtin>symbol=?</span> <span class=keyword>'</span><span class=variable>up</span> <span class=variable>ke</span>)
     (<span class=builtin>make-world</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)
                 (<span class=builtin>world-aup</span> <span class=variable>w</span>)
                 (<span class=builtin>cons</span> (<span class=variable>shot-create</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>)) (<span class=builtin>world-shots</span> <span class=variable>w</span>)))]
    [<span class=keyword>else</span> 
     (<span class=builtin>make-world</span>
       (<span class=builtin>world-ufo</span> <span class=variable>w</span>)
       (<span class=variable>erase-and-draw</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>) (<span class=variable>aup-move</span> <span class=variable>ke</span> (<span class=builtin>world-aup</span> <span class=variable>w</span>)))
       (<span class=builtin>world-shots</span> <span class=variable>w</span>))]))

<span class=comment>;; <code class=scheme><span class=variable>AUP</span> <span class=variable>AUP</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>AUP</span></code></span>
<span class=comment>;; erase old AUP, draw new one, and produce it</span>
(<span class=keyword>define</span> (<span class=variable>erase-and-draw</span> <span class=variable>aup-old</span> <span class=variable>aup-new</span>) ...)

<span class=comment>;; <code class=scheme><span class=variable>World</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>World</span></code></span>
<span class=comment>;; move ufo and create world with it </span>
(<span class=keyword>define</span> (<span class=variable>new-scene</span> <span class=variable>w</span>)
  (<span class=keyword>cond</span>
    [(<span class=variable>hit-by-any-shot?</span> (<span class=builtin>world-shots</span> <span class=variable>w</span>) (<span class=builtin>world-ufo</span> <span class=variable>w</span>))
     (<span class=variable>announcement</span> (<span class=variable>end-of-time</span>))]
    [<span class=keyword>else</span> 
     (<span class=builtin>make-world</span> 
       (<span class=variable>ufo-erase-and-draw</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>) (<span class=variable>ufo-move</span> (<span class=builtin>world-ufo</span> <span class=variable>w</span>)))
       (<span class=builtin>world-aup</span> <span class=variable>w</span>)
       (<span class=variable><u><code class=scheme><span class=variable>shots-erase-and-draw</span></code></u></span>
         (<span class=builtin>world-shots</span> <span class=variable>w</span>) (<span class=variable>all-shots-move</span> (<span class=builtin>world-shots</span> <span class=variable>w</span>))))]))

<span class=comment>;; <code class=scheme><span class=variable>UFO</span> <span class=variable>UFO</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=variable>UFO</span></code></span>
<span class=comment>;; erase old ufo and draw new one, unless it&#8217;s at the bottom </span>
(<span class=keyword>define</span> (<span class=variable>ufo-erase-and-draw</span> <span class=variable>old-ufo</span> <span class=variable>new-ufo</span>) ...)
</pre></div><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 8:</b>&nbsp;&nbsp;Crashing or shooting down a UFO with many shots</td></tr>
<tr><td> <p>
</p>
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
It&#8217;s time to play. And you&#8217;re ready to play. The program fragment in
figure&nbsp;<a href="#node_fig_Temp_11">8</a> contains those pieces of code from
figure&nbsp;<a href="#node_fig_Temp_10">7</a> that require changes due to our revised definition of
<code class=scheme><span class=variable>World</span></code>. When combined with previous code and the solutions to the
exercises in this section, the program allows AUPs to fire many shots at the
UFO. After you have played enough, try to understand and write down how the
program evolved and how we planned out this series of exercises. Then think of
a game that you want to implement and develop a plan for your game. </p>
<p>
</p>
<a name="node_sec_2.6"></a>
<h2 class=section>2.6&nbsp;&nbsp;Eliminating Similarities</h2>
<p></p>
<a name="node_sec_2.6.1"></a>
<h3 class=section>2.6.1&nbsp;&nbsp;Abstracting Similar Functions</h3>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">19 Similarities in Definitions</a></p>
<p>
</p>

<p class=noindent>Take a second look at figure&nbsp;<a href="#node_fig_Temp_4">1</a>. The program
contains two almost identical auxiliary functions: <code class=scheme><span class=variable>ball-paint</span></code> and
<code class=scheme><span class=variable>ball-erase</span></code>:
</p>
<div align=center><table><tr><td>

</td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; paint the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-paint</span> <span class=variable>x-ball</span>)
  (<span class=variable>draw-solid-disk</span>
    (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))
</pre></div></td><td></td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Ball</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
<span class=comment>;; earse the ball from the canvas </span>
(<span class=keyword>define</span> (<span class=variable>ball-erase</span> <span class=variable>x-ball</span>)
  (<span class=variable>clear-solid-disk</span>
    (<span class=builtin>make-posn</span> <span class=variable>x-ball</span> <span class=selfeval>50</span>) <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>))
</pre></div></td><td>
</td></tr></table></div>

Now suppose we want the same program to move a stick figure, not a plain
ball. In that case, the program would have to draw and clear the disk and a
thin rectangle below the disk. That is, we would need to write these two
functions: 
<div align=center><table><tr><td>

</td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Posn</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
(<span class=keyword>define</span> (<span class=variable>shape-paint</span> <span class=variable>a-posn</span>)
  (<span class=keyword>and</span>
    (<span class=variable>draw-solid-rect</span> <span class=variable>a-posn</span> <span class=selfeval>1</span> <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>)
    (<span class=variable>draw-solid-disk</span> <span class=variable>a-posn</span> <span class=selfeval>3</span> <span class=keyword>'</span><span class=variable>red</span>)))
</pre></div></td><td></td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Posn</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
(<span class=keyword>define</span> (<span class=variable>shape-erase</span> <span class=variable>a-posn</span>)
  (<span class=keyword>and</span>
    (<span class=variable>clear-solid-rect</span> <span class=variable>a-posn</span> <span class=selfeval>1</span> <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>)
    (<span class=variable>clear-solid-disk</span> <span class=variable>a-posn</span> <span class=selfeval>3</span> <span class=keyword>'</span><span class=variable>red</span>)))
</pre></div></td><td>
</td></tr></table></div>
<p>
Clearly, the two pairs of functions are prime examples of functions with
similar definitions. We can easily abstract over both pairs.  For the
second pair, we get this general function: 
</p>
<div align=left><pre class=scheme><span class=comment>;; <code class=scheme>(<span class=variable>Posn</span> <span class=variable>Number</span> <span class=variable>Number</span> <span class=variable>Symbol</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span>)</code></span>
<span class=comment>;; &nbsp;&nbsp;&nbsp;&nbsp; <code class=scheme>(<span class=variable>Posn</span> <span class=variable>Number</span> <span class=variable>Symbol</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span>) <span class=variable>Posn</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
(<span class=keyword>define</span> (<span class=variable>graphics-shape</span> <span class=variable>solid-rect</span> <span class=variable>solid-disk</span> <span class=variable>a-posn</span>)
  (<span class=keyword>and</span> (<span class=variable>solid-rect</span> <span class=variable>a-posn</span> <span class=selfeval>1</span> <span class=selfeval>10</span> <span class=keyword>'</span><span class=variable>red</span>)
       (<span class=variable>solid-disk</span> <span class=variable>a-posn</span> <span class=selfeval>3</span> <span class=keyword>'</span><span class=variable>red</span>)))
</pre></div><p>
To get back the two functions, we just pass in the appropriate primitives: 
</p>
<div align=center><table><tr><td>

</td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Posn</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
(<span class=keyword>define</span> (<span class=variable>shape-paint</span> <span class=variable>p</span>) 
  (<span class=variable>graphics-shape</span>
    <span class=variable>draw-solid-rect</span> <span class=variable>draw-solid-disk</span> <span class=variable>p</span>))
</pre></div></td><td></td><td><div align=left><pre class=scheme><span class=comment>;; <code class=scheme><span class=variable>Posn</span> &nbsp;<tt>-&gt;</tt>&nbsp; <span class=builtin>true</span></code></span>
(<span class=keyword>define</span> (<span class=variable>shape-erase</span> <span class=variable>p</span>)
  (<span class=variable>graphics-shape</span>
    <span class=variable>clear-solid-rect</span> <span class=variable>clear-solid-disk</span> <span class=variable>p</span>))
</pre></div></td><td>
</td></tr></table></div>

The advantage is that, in many cases, we can now change just a single
function to get an entirely new shape to move across a canvas. <p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.1"></a>
<b>Exercise 2.6.1.</b>&nbsp;&nbsp;  
Replace the functions <code class=scheme><span class=variable>ball-paint</span></code> and <code class=scheme><span class=variable>ball-erase</span></code> in
figure&nbsp;<a href="#node_fig_Temp_4">1</a> with <code class=scheme><span class=variable>shape-paint</span></code> and
<code class=scheme><span class=variable>shape-erase</span></code>. Don&#8217;t forget to add <code class=scheme><span class=variable>graphics-shape</span></code> so that the
functions actually work. Then modify <code class=scheme><span class=variable>graphics-shape</span></code> so that the
program moves
</p>
<ol>
<li><p>a square of size&nbsp;<code class=scheme><span class=selfeval>3</span></code>;</p>
<p>
</p>
<li><p>a cross-hair that intersect at the given <code class=scheme><span class=variable>Posn</span></code>;</p>
<p>
</p>
<li><p>a pair of intersecting disks (each of size&nbsp;<code class=scheme><span class=selfeval>5</span></code>) that contain the
given <code class=scheme><span class=variable>Posn</span></code> in their intersection.&nbsp;<a href="../Solutions/abs0.html">Solution</a></p>
</ol><p>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.2"></a>
<b>Exercise 2.6.2.</b>&nbsp;&nbsp;  
Develop an abstract function for <code class=scheme><span class=variable>ufo-draw</span></code> and <code class=scheme><span class=variable>ufo-clear</span></code>
from exercise&nbsp;<a href="#node_thm_2.1.4">2.1.4</a>.&nbsp;<a href="../Solutions/abs-draw-clear.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.3"></a>
<b>Exercise 2.6.3.</b>&nbsp;&nbsp;  
Develop an abstract function for <code class=scheme><span class=variable>aup-draw</span></code> and <code class=scheme><span class=variable>aup-clear</span></code> from
exercise&nbsp;<a href="#node_thm_2.2.4">2.2.4</a>.&nbsp;<a href="../Solutions/abs-draw-clear-aup.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.4"></a>
<b>Exercise 2.6.4.</b>&nbsp;&nbsp;  
Develop an abstraction for <code class=scheme><span class=variable>shot-draw</span></code> and <code class=scheme><span class=variable>shot-clear</span></code>
from exercise&nbsp;<a href="#node_thm_2.4.4">2.4.4</a>.&nbsp;<a href="../Solutions/abs-shot.html">Solution</a></p>
<p></p>
<hr>
<p></p>
<p></p>
<p></p>
<p>
</p>
<a name="node_sec_2.6.2"></a>
<h3 class=section>2.6.2&nbsp;&nbsp;Using Loops</h3>
<p></p>

<p class=noindent>P<small>R</small><small>E</small><small>R</small><small>E</small><small>Q</small><small>U</small><small>I</small><small>S</small><small>I</small><small>T</small><small>E</small>: 
<a href="http://www.htdp.org/2002-09-22/Book/">21.2 Finger Exercises with Abstract List Functions</a></p>
<p>
</p>

<p class=noindent>In addition to abstracting over similar functions, it is also good
practice to define functions with applications of existing
abstractions. Scheme provides a number of &#8220;loops&#8221;, i.e., functions that
traverse a piece of data and apply some give function to each &#8220;stop&#8221;
during the traversal. For example, 
</p>
<div align=left><pre class=scheme>(<span class=builtin>map</span> <span class=variable>shot-move</span> 
     (<span class=builtin>list</span> (<span class=builtin>make-posn</span> <span class=selfeval>100</span> <span class=selfeval>500</span>)
           (<span class=builtin>make-posn</span> <span class=selfeval>100</span> <span class=selfeval>460</span>)
           (<span class=builtin>make-posn</span> <span class=selfeval>120</span> <span class=selfeval>420</span>)))
</pre></div><p>
applies the function <code class=scheme><span class=variable>shot-move</span></code> to each <code class=scheme><span class=variable>Shot</span></code> (i.e.,
<code class=scheme><span class=variable>Posn</span></code>) on the given list. The result is the list
</p>
<div align=left><pre class=scheme>(<span class=builtin>list</span> (<span class=builtin>make-posn</span> <span class=selfeval>100</span> <span class=selfeval>492</span>) (<span class=builtin>make-posn</span> <span class=selfeval>100</span> <span class=selfeval>452</span>) (<span class=builtin>make-posn</span> <span class=selfeval>120</span> <span class=selfeval>412</span>))
</pre></div><p>
In short, the expression moves an entire list of shots. </p>
<p>
</p>
<p></p>
<hr>
<p></p>
<p><strong>Exercises</strong>
</p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.5"></a>
<b>Exercise 2.6.5.</b>&nbsp;&nbsp; 
Use <code class=scheme><span class=builtin>map</span></code> to define <code class=scheme><span class=variable>all-shots-move</span></code> from
exercise&nbsp;<a href="#node_thm_2.5.2">2.5.2</a>.&nbsp;<a href="../Solutions/abs-map-move.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.6"></a>
<b>Exercise 2.6.6.</b>&nbsp;&nbsp; 
Use <code class=scheme><span class=builtin>andmap</span></code> to define <code class=scheme><span class=variable>all-shots-draw</span></code> and
<code class=scheme><span class=variable>all-shots-clear</span></code> from
exercise&nbsp;<a href="#node_thm_2.5.3">2.5.3</a>.&nbsp;<a href="../Solutions/abs-andmap-draw.html">Solution</a></p>
<p></p>
<p>
</p>
<p><a name="node_thm_2.6.7"></a>
<b>Exercise 2.6.7.</b>&nbsp;&nbsp;  
Use <code class=scheme><span class=builtin>ormap</span></code> to define <code class=scheme><span class=variable>hit-by-any-shot?</span></code> from
exercise&nbsp;<a href="#node_thm_2.5.4">2.5.4</a>.&nbsp;<a href="../Solutions/abs-hit-shot.html">Solution</a></p>
<p></p>
<hr>
<p></p>
<p></p>
<p></p>
<p>
Now that play some more, but use this second draft of the program. </p>
<p>
</p>
<a name="node_sec_3"></a>
<h1 class=section>3&nbsp;&nbsp;Suggestions</h1>
<p></p>
<a name="node_sec_3.1"></a>
<h2 class=section>3.1&nbsp;&nbsp;Worm</h2>
<p>The Worm game is one the oldest computer games around. The world of Worm
consists of a square landscape with a worm and a piece of food. From the
beginning, the worm travels across the landscape in some direction. The
player can change the worm&#8217;s direction via keystrokes using the four arrow
keys. The worm continues to travel in the direction of the last command.
When the worm gets close enough to the food, it eats the food and grows by
one segment. Once the food is eaten, new food shows up somewhere else on
the screen. </p>
<p>
</p>
<p>

</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_12"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">


<center>
<img src=Images/worms1.jpg alt="[WORM 1]">
<img src=Images/worms2.jpg alt="[WORM 1]">
</center>
</p>
</td></tr>
<tr><td align=center><b>Figure 9:</b>&nbsp;&nbsp;The Worm Game</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
The goal of the game is to grow the worm as large as possible. Two
obstacles prevent the worm from growing forever. First, if the worm runs
into itself, it is said to eat itself, which kills it and the game is
over. Second, the worm&#8217;s head can run into one of the four surrounding
walls, which has the same consequence. In other words, the goal of the
game is to grow the worm as large as possible before it runs into the wall
or eats itself.</p>
<p>
</p>
<a name="node_sec_3.2"></a>
<h2 class=section>3.2&nbsp;&nbsp;BlockScape</h2>
<p>BlockScape is a variation on the Tetris theme, which is also a computer
game from the early ages of personal computers. The BlockScape world
contains on flying block (a rectangle of a certain size) and a list of
blocks that have accumulated on the ground. Every time a block lands on
the floor or on one of the blocks lying there, a new block appears at the
top of the picture. The player can navigate the flying block with the left
and right arrow key, to which the block responds with appropriate
movements. </p>
<p>
</p>
<p>

</p>
<p>

<blockquote><table bgcolor="beige"><tr><td>

</p>
<a name="node_fig_Temp_13"></a>
<div class=figure align=center><table width=100%><tr><td align=center><div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">


<center>
<img src=Images/blocks1.jpg alt="[BLOCK 1]">
<img src=Images/blocks2.jpg alt="[BLOCK 1]">
</center>
</p>
</td></tr>
<tr><td align=center><b>Figure 10:</b>&nbsp;&nbsp;The Blocks Game</td></tr>
<tr><td> 
</td></tr></table></div><p>

</td></tr></table></blockquote>
</p>
<p>
The goal of the game is to land as many blocks as possible before the
tallest accumulation of blocks reaches the black line (see
figure&nbsp;<a href="#node_fig_Temp_13">10</a>). Although this appears trivial at first, the
trick is that this game is played a very high speed so that the blocks
descend very quickly. On a reasonably modern computer the clock (see
<code class=scheme><span class=variable>big-bang</span></code>) should tick every <code class=scheme><span class=selfeval>.01</span></code> seconds. </p>
<p>
Note: Navigating the blocks requires tests that determine whether a block
that moves left or right would run into (or through) a block that is
already on the ground or whether it would leave the entire picture, which
it can&#8217;t. Landing the block requires a similar test. Specifically, the
program must know whether one block is on top of each other. </p>
<p>
At first glance, these tests mean that blocks should only move in certain
discrete steps, that the picture frame has a certain size, and so
on. Instead of relying on the nature of exact rational numbers in Scheme,
we recommend that you instead use approximate test. For example, for the
&#8220;on top of one another&#8221; test, you may wish to ask whether the <code class=scheme><span class=variable>x</span></code>
coordinates of the two blocks are approximately the same and whether the
lower-left corner of the top block is approximately near the upper-right
of the bottom block. </p>
<p>
</p>

<div class=footnoterule><hr></div><p></p>
<div class=footnote><p><a name="node_footnote_Temp_3"></a><sup><small><a href="#node_call_footnote_Temp_3">1</a></small></sup> Recall that <code class=scheme><span class=builtin>char?</span></code> is the
predicate that recognizes characters and that <code class=scheme><span class=builtin>char=?</span></code>  is a predicate
for comparing characters.</p>
</div>
<div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">
<div align=right class=navigation></div>
</p>
<p></p>
<div align=right class=colophon>Last modified: Thursday, July 22nd, 2004 9:41:37am<br><div align=right class=advertisement>HTML conversion by <a href="http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html">TeX2page 20070609</a></div></div>
</div>
</body>
</html>

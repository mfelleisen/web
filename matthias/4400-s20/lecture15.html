<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>15 --- JULIA Types &amp; Dispatch</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Principles of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="communication.html" class="tocviewlink" data-pltdoc="x">Email, Office Hours, Etc.</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">In-<wbr></wbr>Class Reviews</a></td></tr><tr><td align="right"></td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right"></td><td><a href="assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x">1 &#8212;<wbr></wbr> Programming Languages:<span class="mywbr"> &nbsp;</span> Research and Teaching</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x">2 &#8212;<wbr></wbr> Parsing</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x">3 &#8212;<wbr></wbr> Scope, Compilation</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x">4 &#8212;<wbr></wbr> Compilers; Fun</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x">5 &#8212;<wbr></wbr> Help!</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x">6 &#8212;<wbr></wbr> Recursive Functions</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x">7 &#8212;<wbr></wbr> Errors and Ordering</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x">8 &#8212;<wbr></wbr> Assignments</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x">9 &#8212;<wbr></wbr> Store Passing</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x">10 &#8212;<wbr></wbr> <span class="emph">What</span> and <span class="emph">When</span></a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x">13 &#8212;<wbr></wbr> Poly Types</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">15 &#8212;<wbr></wbr> JULIA Types &amp; Dispatch</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x">16 &#8212;<wbr></wbr> Gradual Types</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">15 &#8212;<wbr></wbr> JULIA Types &amp; Dispatch</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.6.0.14</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture14.html" title="backward to &quot;14 --- More Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture16.html" title="forward to &quot;16 --- Gradual Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._lecture15)"></a>15 &#8212;<wbr></wbr> JULIA Types &amp; Dispatch</h4><a name="(part._chap~3alecture15)"></a><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Julia Belyakova</p></span></div><p><span style="font-weight: bold">Tuesday, 25 February 2020</span>
<span style="font-weight: bold">Julia Belyakova</span></p><p><div class="SIntrapara"></div><div class="SIntrapara"><span style="font-weight: bold">Presenters</span> (1) Chase Boni, Koissi Adjorlolo</div></p><p>This time, we will talk about:</p><ul><li><p>multiple dispatch and why it is cool;
<span class="refelem"><span class="refcolumn"><span class="refcontent">Things we learned about nominal and structural subtyping
in <a href="lecture14.html" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a> will come in handy.</span></span></span></p></li><li><p>how it is supported in the <a href="https://julialang.org/">Julia</a> language;</p></li><li><p>how types interact with the dispatch mechanism.</p></li></ul><h4><a name="(part._.The_.Extensibility__aka_.Expression__.Problem)"></a>The Extensibility (aka Expression) Problem</h4><p>Consider the <span style="font-weight: bold">following task</span>.</p><blockquote><p>Write an interpreter for this simple language of arithmetic:</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Expr ::= int | - Expr | Expr + Expr</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table><p>Any expression in this language evaluates to an integer.</p></blockquote><p>Take a moment to think about the task.
How would you solve it in your favorite language?
What data types and functions/methods would you define?</p><p>Now, consider <span style="font-weight: bold">another task</span>.</p><blockquote><p>Extend the language of arithmetic expressions
to support integer equality check and conditional:</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Expr ::= ... | Expr == Expr | if Expr Expr Expr</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table><p>In the extended language, an expression evaluates to
either an integer or a boolean.
The equality check is defined only for integers,
and the if-expression takes a boolean condition.</p><p>Write a type checker and an interpreter for this language.</p></blockquote><p>If you were allowed to reuse/extend code written for the first task,
what would be your solution to the new task?
What data types would you have to add and/or modify?
What functions/methods would you have to add and/or modify?</p><p>Most likely, your solution falls into one of the two categories:</p><ul><li><p><div class="SIntrapara"><span style="font-weight: bold">Functional style</span>
</div><div class="SIntrapara"><ol><li><p>Original language</p><p><div class="SIntrapara">Datatype for expressions with three variants, e.g.
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data Expr = EInt(Int) | ENeg(Expr) | EAdd(Expr, Expr)</span></p></td></tr></table></div></p><p>+</p><p>Datatype for integer value</p><p>+</p><p><div class="SIntrapara">Function for interpreter, e.g.
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interpreter :: Expr -&gt; Value</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interpreter(expr) =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case expr of</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">EInt(v) -&gt; ...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></div></p></li><li><p>Extended language</p><p><div class="SIntrapara"><span class="emph">Modified</span> datatype for expressions, e.g.
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">data Expr = ... | EEq(Expr, Expr) | EIf(Expr, Expr, Expr)</span></p></td></tr></table></div></p><p>+</p><p><span class="emph">Modified</span> datatype for values</p><p>+</p><p>Datatype for types</p><p>+</p><p>Function for type checker</p><p>+</p><p><span class="emph">Modified</span> function for interpreter, e.g.</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interpreter :: Expr -&gt; Value</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interpreter(expr) =</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case expr of</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">EEq(eleft, eright) -&gt; ...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">EIf(econd, ethen, eelse) -&gt; ...</span></p></td></tr></table></li></ol></div></p></li><li><p><div class="SIntrapara"><span style="font-weight: bold">Object-oriented style</span>
</div><div class="SIntrapara"><ol><li><p>Original language</p><p>Class hierarchy for values</p><p>+</p><p>Class hierarchy for expressions
with a method for interpreter in each class, e.g.</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">abstract class Expr {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">abstract Value interpret();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class EInt extends Expr {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Int val;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Value interpret() { ... }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class ENeg extends Expr {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr left;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr right;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Value interpret() { ... }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class EAdd extends Expr { ... }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></li><li><p>Extended language</p><p>Class hierarchy for types</p><p>+</p><p><span class="emph">Modified</span> classes with a new method for type checker</p><p>+</p><p>Concrete classes for new expressions
with methods for type checker and interpreter, e.g.</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class EEq extends Expr {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr left;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr right;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Type check() { ... }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Value interpret() { ... }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class EIf extends Expr { ... }</span></p></td></tr></table></li></ol></div></p></li></ul><p>Look through the both bullet points above and notice
which parts of the code have to be <span class="emph">modified</span>.</p><p><div class="SIntrapara">Note that the task of extending the language has two components:
</div><div class="SIntrapara"><ul><li><p>extending data;</p></li><li><p>adding functionality.</p></li></ul></div></p><p>Which of the approaches above (functional or object-oriented)
works better for extending data?
And which one is better for adding functionality?</p><p>The intuition "works better" can be expressed as
"does not require <span class="emph">modifying</span> existing code".</p><ul><li><p>With the functional approach, we don&rsquo;t need
to modify any code to add a type checker,
so it works better for adding functionality.</p></li><li><p>With the object-oriented approach, we don&rsquo;t need
to modify any code to add new expressions,
so it works better for extending data.</p></li></ul><p>This challenge of extending data and adding functions over the data
<span class="emph">without modifying existing code</span>
is known as the <span style="font-weight: bold">extensibility problem</span> (aka <span style="font-weight: bold">expression problem</span>).</p><p>Visually, it is usually represented with a diagram,
where "Good" means "easy to extend without modifying existing code". See
<a href="#%28counter._%28figure._fig~3aext-plain%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">67</span></a> for the basic diagram.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_20.png" alt="image" width="425.3" height="425.3"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aext-plain))" x-target-lift="Figure"></a>Figure&nbsp;67: </span>The Basic Extensibility Problem</span></p></blockquote><p>In most languages, without planning for extensibility from the start,
one would not be able to get both these dimensions
(as you have just experienced yourself).
There are workarounds and design patterns,
e.g. extensible visitors, tagless final, object algebras,
but they would normally be injected after revising the code,
once the need for extensions has become clear.
(Note that a good old visitor pattern
simply reverses the problem for an object-oriented language.)</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_21.png" alt="image" width="425.3" height="425.3"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aext-pattern))" x-target-lift="Figure"></a>Figure&nbsp;68: </span>The Extensibility Problem, Solved With Patterns</span></p></blockquote><p>In a language with <span style="font-weight: bold">multiple dispatch</span>, however,
the extensibility problem is solved <span style="font-weight: bold">trivially</span>! <span class="refelem"><span class="refcolumn"><span class="refcontent">The
word &ldquo;trivial&rdquo; refers to just one dimension, the &ldquo;control&rdquo; aspect of
the problem. The other dimension concerns static typing, which we do not
address here.</span></span></span>
Without planning and thinking ahead, one is able
to both extend data and add functionality without touching any existing code.
Thus, if we limit the diagram only to pure language mechanisms,
multiple dispatch takes the sweet spot; see <a href="#%28counter._%28figure._fig~3aext-multiple%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">69</span></a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_22.png" alt="image" width="425.3" height="425.3"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aext-multiple))" x-target-lift="Figure"></a>Figure&nbsp;69: </span>The Extensibility Problem, Solved Linguistically</span></p></blockquote><h4><a name="(part._.Logical_vs_.Physical_.Types__again_)"></a>Logical vs Physical Types (again)</h4><p><span style="font-weight: bold">Question.</span> What is the fundamental difference between
an abstract class/interface and a "normal" class?</p><p>Normal classes give rise to objects, whereas abstract ones don&rsquo;t.</p><p>Remember we talked about logical and physical types in <a href="lecture11.html" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a>?</p><ul><li><p><span class="emph">Logical</span> types are used by the type checker;
they enable reasoning about programs without running the programs.</p></li><li><p><span class="emph">Physical</span> types are used by the interpreter/compiler;
they are needed for running the programs.</p></li></ul><p>Let&rsquo;s look at Java from this logical/physical types prospective.
Are non-abstract classes logical or physical? Why?
What about abstract classes and interfaces?</p><ul><li><p>All classes and interfaces induce logical types that can be used
by the type checker.</p></li><li><p>In addition, non-abstract classes (but not interfaces) give rise
to run-time objects, so they also act as physical types.</p></li></ul><p>We can summarize this reasoning in a diagram
(from now on, "interface" stands for both interfaces and abstract classes,
and "class" stands for non-abstract classes):</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">logical</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interface ----------&#9655;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">type</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-----------&#9655; type checker</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9651;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(for "instanceof" and dispatch)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">-----------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9661;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class ------------&#9655; physical ----------&#9655; interpreter</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">object</span></p></td></tr></table></p><p>A type checker does not care about the physical side of classes.
An interpreter does not care about the logical side of classes,
but it needs to know something about interfaces for dynamic dispatch.</p><p>Note that in our toy language with structural types
(from lectures and home assignments),
logical types were completely decoupled from run-time values.
In the presence of classes, however, this is not the case any more.
<span class="emph">Every class</span> serves as both logical and physical type
because it gives rise to two things:</p><ul><li><p><span style="font-weight: bold">type annotation</span> used by the type checker statically;</p></li><li><p><span style="font-weight: bold">type tag</span> used by the interpreter at run-time
(every object is "tagged" with the class name it has been created with).</p></li></ul><p>Loosely speaking, the <span class="stt">instanceof</span> operation checks whether
a type tag adheres to a type annotation.</p><p>Ignoring the implementation details of dynamic dispatch,
let us revise the diagram:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">type</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">interface ----------&#9655; annotation ----------&#9655; type checker</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9651;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">(for "instanceof" and dispatch)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">--------------&#9655; interpreter</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class ------------&#9655; type --------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">tag</span></p></td></tr></table></p><h4><a name="(part._.Simple_.Interpreter_in_.J.U.L.I.A)"></a>Simple Interpreter in JULIA</h4><p>Let&rsquo;s get back to the very first task and write an interpreter
for the simple language of arithmetic:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr ::= int | - Expr | Expr + Expr</span></p></td></tr></table></p><p>This time, we will write it in <a href="https://julialang.org/">Julia</a>,
a language with multiple dispatch.
Note that Julia is not statically typed.</p><p>As usual, we start with a data representation for expressions.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._abstract%29%29" class="RktStxLink" data-pltdoc="x">abstract</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">type</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EInt</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">val</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ENeg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EAdd</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">left</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">right</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">These data type definitions remind of classes in object-oriented languages. The
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">EInt</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">notation introduces <span class="emph">subtyping</span> between the types,
similar to
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">EInt extends ExprAST</span></p></td></tr></table></div><div class="SIntrapara">in Java.</div></p><p>What do you think is the difference between an <span class="stt">abstract type</span> and a <span class="stt">struct</span>?
Just like interfaces, <span style="font-weight: bold">abstract types</span> such as <span class="stt">ExprAST</span> do not
give rise to data but make up nominal hierarchies.
Structs such as <span class="stt">EInt</span> (called <span style="font-weight: bold">concrete types</span> in Julia),
on the other hand, are data constructors that produce values "tagged" with
the struct name, just like non-abstract classes produce objects.</p><p>Note that <span class="stt">&lt;:</span> in Julia is really nothing but subtyping.
Neither abstract types nor structs can have methods inside;
abstract types are just names, and concrete types cannot be further subtyped,
so there is nothing to inherit/extend.
Despite its name, <span class="stt">struct</span> is a nominal type.
(If you are wondering why concrete types cannot be subtyped,
the answer is &#8212; for the sake of performance.)</p><p>Ok, we have the data definition. Let&rsquo;s write an interpreter!
What should it return?
In our simple language, the result of evaluating an expression is an integer:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">IValue</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Can the interpreter ever error? Why? Let&rsquo;s write some examples/unit tests:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">iBig</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4543534543</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">eInt1</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">eIntBig</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktSym">iBig</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">eNegIntBig</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ENeg</span><span class="RktPn">(</span><span class="RktSym">eIntBig</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">eAddN3Neg5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EAdd</span><span class="RktPn">(</span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktVal">-3</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ENeg</span><span class="RktPn">(</span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">-3</span><span class="hspace">&nbsp;</span><span class="RktCmt">+</span><span class="hspace">&nbsp;</span><span class="RktCmt">(-(5))</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">@test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">eInt1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">@test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">eIntBig</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">iBig</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">@test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">eNegIntBig</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="nobreak">-i</span>Big</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">@test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">eAddN3Neg5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-8</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Since no run-time errors are possible, the interpreter implementation is trivial:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprAST</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">IValue</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.val</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.expr</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EAdd</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.left</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.right</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Note that the three lines of the implementation are separate
(function) definitions, which are called <span style="font-weight: bold">methods</span> in Julia.
These definitions might look like pattern-patching on
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ExprAST = EInt|ENeg|EAdd</span></p></td></tr></table></div><div class="SIntrapara">but the domain of <span class="stt">interpret</span> is not limited to the <span class="stt">ExprAST</span> type.
Thus, for example, nothing prevents us from defining
an <span class="stt">interpret</span> method for strings:</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">s::String</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The set of all methods with the same name is called a generic function
(not to confuse with generics and polymorphic functions).
At run-time, every function call such as <span class="stt">interpret(ENeg(EInt(4)))</span>
is <span style="font-weight: bold">dispatched</span> to the best method available (we&rsquo;ll talk about this
mechanism soon).</p><p>Ok, our interpreter seems to work.
But what if we forgot to define a method for <span class="stt">ENeg</span>?
In the <span class="stt">interpret(ENeg(EInt(4)))</span> case, we would get a <span class="emph">run-time error</span>, of course!</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MethodError: no method matching interpret(::ENeg)</span></p></td></tr></table></p><p><span style="font-weight: bold">The role of type annotations</span></p><p>Let&rsquo;s forget about the interpreter for a second.
Consider the following program (pseudo code):</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">let dec = fun* (x:int) (x - 1) in</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dec("hell")</span></p></td></tr></table></p><p>Can you translate it to Java and Julia?
What happens when we run the programs in each case?</p><p><div class="SIntrapara"><span class="emph">Java:</span>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int dec(int x) { return x - 1; }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dec("hell") // type error</span></p></td></tr></table></div></p><p>Thanks to the type checker, the <span class="stt">dec("hell")</span> call will never be evaluated.</p><p>Whenever a call to <span class="stt">dec</span> is being evaluated,
we can be certain that inside <span class="stt">dec</span>,
variable <span class="stt">x</span> contains an integer value.</p><p><div class="SIntrapara"><span class="emph">Julia:</span>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dec(x::Int) = x-1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dec("hell") # dynamic MethodError: no method matching dec(::String)</span></p></td></tr></table></div></p><p>Because Julia is not statically typed, no static type error is reported
for <span class="stt">dec("hell")</span>, so the call will be evaluated.
Then, because all function calls are handled by dispatch
and there is no <span class="stt">dec</span> method for a <span class="stt">String</span> argument,
this call will fail at run-time.
Note that we will <span class="emph">not evaluate the body</span> of <span class="stt">dec(::Int)</span>!</p><p>Whenever a call is being dispatched to the <span class="stt">dec(::Int)</span> method,
we can be certain that inside <span class="stt">dec(::Int)</span>,
variable <span class="stt">x</span> contains an integer value.</p><p>Thus, Julia does not use type annotation as logical types for type checking,
but the interpreter does rely on them at run-time.</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">abstract -----------&#9655; type annotation ------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">type</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9651;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9661;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">interpreter</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9651;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9478;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">struct ---------------&#9655; type tag ----------------</span></p></td></tr></table></p><p><span class="emph">Note.</span> Type annotations are not required in Julia.
We can write methods such as</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">f</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr></table></blockquote><p>and then inside <span class="stt">f</span>, variable <span class="stt">x</span> can contain any value.
A method without type annotations is equivalent to a method for <span class="stt">::Any</span>,
where <span class="stt">Any</span> is a supertype of all types (often referred to as "top").</p><h4><a name="(part._.Subtyping_.Dispatch)"></a>Subtyping Dispatch</h4><p>How does the run-time system know which method to dispatch to?
Clearly, in the current interpreter example,
there is just one method that can handle <span class="stt">ENeg</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprAST</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">IValue</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.val</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.expr</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EAdd</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.left</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.right</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">ENeg</span><span class="RktPn">(</span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">-4</span><span class="RktMeta"></span></td></tr></table></blockquote><p>How about the following definitions?</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprAST</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">String</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">expr::ExprAST</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"ExprAST"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">expr::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"$(expr.val)"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">expr::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"-($(toString(expr.expr)))"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">ENeg</span><span class="RktPn">(</span><span class="RktSym">EInt</span><span class="RktPn">(</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">"-(4)"</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Intuitively, there are two methods <span class="emph">applicable</span> to an <span class="stt">ENeg</span> value,
<span class="stt">toString(::ExprAST)</span> and <span class="stt">toString(::ENeg)</span>.
And we would like the dispatch mechanism to pick the latter one,
because it is <span class="emph">more specific</span>.
But what does it mean to be applicable and more specific?</p><p>Formally, the intuition translates to the use of subtyping.
Dynamic dispatch of <span class="stt">toString(ENeg(...))</span> is resolved in two steps:</p><ol><li><p>Find all <span class="stt">toString</span> methods applicable to <span class="stt">ENeg</span> tag.
For this, check subtyping between the type tag and
type annotation of every <span class="stt">toString</span> method:</p><ul><li><p><span class="RktSym">ENeg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span> ? Yes, <span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">::ExprAST</span><span class="RktPn">)</span><span class="RktMeta"></span> is applicable.</p></li><li><p><span class="RktSym">ENeg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EInt</span><span class="RktMeta"></span> ? No, <span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span> is not applicable.</p></li><li><p><span class="RktSym">ENeg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ENeg</span><span class="RktMeta"></span> ? Yes, <span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span> is applicable.</p></li></ul></li><li><p>Select the most specific method out of the applicable ones.
For this, check subtyping between type annotations of the methods.</p><ul><li><p><span class="RktSym">ENeg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span> ? Yes, <span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span>
    is more specific than <span class="RktSym">toString</span><span class="RktPn">(</span><span class="RktSym">::ExprAST</span><span class="RktPn">)</span><span class="RktMeta"></span>.</p></li></ul></li></ol><p>Thus, we have two applicable methods
and one of them is more specific than the other,
so the call is dispatched to the more specific one.</p><p>In the interpreter example, the set of applicable methods
is a singleton set, so there is no choice but to pick <span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span>.
If we remove this method, the set becomes empty and we get
the "no method" error.</p><p>Do you think other errors are possible? What about step 2?
Is it always possible to find the best method?</p><h4><a name="(part._.Multiple__.Symmetric__.Dispatch)"></a>Multiple (Symmetric) Dispatch</h4><p>Wait a minute! Didn&rsquo;t we promise to talk about multiple dispatch?
So far, all the methods accept one argument, and we can easily write similar
code in Java using classes and dynamic dispatch.</p><p>Very well, let&rsquo;s define equality for expressions in the <span class="stt">Expr</span> language.
How do we do this in Julia? Any guesses?
The solution should not be surprising
(the last method catches situations where the arguments have different tags,
in which case they are definitely not equal).</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktPn">(</span><span class="RktSym">e1::EInt</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e1.val</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2.val</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktPn">(</span><span class="RktSym">e1::ENeg</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e1.expr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2.expr</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktPn">(</span><span class="RktSym">e1::EAdd</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2::EAdd</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e1.left</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2.left</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&amp;&amp;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e1.right</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2.right</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktPn">(</span><span class="RktSym">e1::ExprAST</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e2::ExprAST</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/booleans.html#%28def._%28%28lib._racket%2Fbool..rkt%29._false%29%29" class="RktValLink" data-pltdoc="x">false</a></span><span class="RktMeta"></span></td></tr></table></blockquote><p>And what about Java? Because here, dynamic dispatch works only for one argument,
we have to inspect the tag of the second argument manually, for example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class EInt extends ExprAST {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int val;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">boolean equals(ExprAST e) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return (e instanceof EInt) ? this.val == ((EInt)e).val : false;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>In Julia, multiple dispatch does all the tag-inspection work for us.</p><p><span class="emph">Note.</span> Dispatch in Julia is called <span style="font-weight: bold">symmetric</span> because all the arguments
are treated as equally important. Can you think of a different approach?
It is called an <span class="emph">asymmetric</span> multiple dispatch.
In this case, we process arguments left to right,
and filter applicable methods based on the type of current argument.</p><p><span style="font-weight: bold">The truth about multiple dispatch</span></p><p>There is nothing special about multiple symmetric dispatch.
It is just a single dispatch on tuple types!</p><ul><li><p>Every method in Julia takes one argument, but the argument is a tuple.</p></li><li><p>A tuple is a generalization of a pair;
it represents one or more values bundled together, e.g. <span class="stt">("hey", true, 3)</span>.</p></li></ul><p>So, in addition to nominal types such as <span class="stt">ExprAST</span> and <span class="stt">EInt</span>,
Julia supports several <span class="emph">structural</span> types such as tuples.
Subtyping of tuple types is rather straightforward
(tuples are often denoted as <span class="stt">s &#215; t</span>):</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">s &lt;: s*</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">t &lt;: t*</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">(s, t) &lt;: (s*, t*)</span></p></td></tr></table></p><p><span style="font-weight: bold">What else can go wrong with dispatch</span></p><p>Consider the following methods, assuming that <span class="stt">Nat &lt;: Int</span> and
<span class="stt">Int(v)</span> converts a <span class="stt">Nat</span> to an <span class="stt">Int</span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">x::Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y::Nat</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">add_int</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">x::Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y::Int</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">add_int</span><span class="RktPn">(</span><span class="RktSym">Int</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Is there anything weird about these definitions?
What happens when we call <span class="stt">add</span> with two natural numbers?
Let&rsquo;s walk through the method resolution process:</p><ol><li><p>Find applicable methods.</p><ul><li><p><span class="RktPn">(</span><span class="RktSym">Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Nat</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Nat</span><span class="RktPn">)</span><span class="RktMeta"></span> ? Yes, <span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">::Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::Nat</span><span class="RktPn">)</span><span class="RktMeta"></span> is applicable.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Nat</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktPn">)</span><span class="RktMeta"></span> ? Yes, <span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">::Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::Int</span><span class="RktPn">)</span><span class="RktMeta"></span> is applicable.</p></li></ul></li><li><p>Find the best method.</p><ul><li><p><span class="RktPn">(</span><span class="RktSym">Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Nat</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktPn">)</span><span class="RktMeta"></span> ? No, <span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">::Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::Nat</span><span class="RktPn">)</span><span class="RktMeta"></span> is
no more specific than <span class="stt">add(::Nat, ::Int)</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Int</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Nat</span><span class="RktPn">)</span><span class="RktMeta"></span> ? No, <span class="RktSym">add</span><span class="RktPn">(</span><span class="RktSym">::Nat</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::Int</span><span class="RktPn">)</span><span class="RktMeta"></span> is
no more specific than <span class="stt">add(::Int, ::Nat)</span>.</p></li></ul></li></ol><p>Neither of the applicable methods is the most specific!
In this case, we get an "ambiguity" error:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MethodError: add(::Nat, ::Nat) is ambiguous</span></p></td></tr></table></p><p><span class="emph">Note.</span> With an asymmetric dispatch, the ambiguity error is impossible.
Why is that?</p><h4><a name="(part._.J.U.L.I.A_.Solution_to_.The_.Extensibility_.Problem)"></a>JULIA Solution to The Extensibility Problem</h4><p>Finally, we are ready to solve the extensibility problem!
Let&rsquo;s add the support for the extended language:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Expr ::= ... | Expr == Expr | if Expr Expr Expr</span></p></td></tr></table></p><p>First of all, we need to extend the data definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EEq</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">left</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">right</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">EIf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">econd</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ethen</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">eelse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprAST</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr></table></blockquote><p>In the extended language, the result of interpretation can be
either integer or boolean:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">IValue</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Union</span><span class="RktPn">{</span><span class="RktSym">Int</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Bool</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>To avoid interpreting bad expressions and producing run-time errors,
we need a type checker. Of course, we have to define types first:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._abstract%29%29" class="RktStxLink" data-pltdoc="x">abstract</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">type</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Ty</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">TInt</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Ty</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">TBool</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Ty</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">instances</span><span class="hspace">&nbsp;</span><span class="RktCmt">for</span><span class="hspace">&nbsp;</span><span class="RktCmt">convenience</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._const%29%29" class="RktValLink" data-pltdoc="x">const</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">TInt</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._const%29%29" class="RktValLink" data-pltdoc="x">const</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tBool</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">TBool</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>And type errors:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">Custom</span><span class="hspace">&nbsp;</span><span class="RktCmt">exception</span><span class="hspace">&nbsp;</span><span class="RktCmt">for</span><span class="hspace">&nbsp;</span><span class="RktCmt">type</span><span class="hspace">&nbsp;</span><span class="RktCmt">checker</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">TypecheckException</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Exception</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">msg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">String</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._const%29%29" class="RktValLink" data-pltdoc="x">const</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIntDomain</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"domain</span><span class="hspace">&nbsp;</span><span class="RktVal">error:</span><span class="hspace">&nbsp;</span><span class="RktVal">integer</span><span class="hspace">&nbsp;</span><span class="RktVal">expected"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._const%29%29" class="RktValLink" data-pltdoc="x">const</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIfCond</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"boolean</span><span class="hspace">&nbsp;</span><span class="RktVal">expected</span><span class="hspace">&nbsp;</span><span class="RktVal">for</span><span class="hspace">&nbsp;</span><span class="RktVal">if</span><span class="hspace">&nbsp;</span><span class="RktVal">condition"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._const%29%29" class="RktValLink" data-pltdoc="x">const</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIfBranches</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"same</span><span class="hspace">&nbsp;</span><span class="RktVal">type</span><span class="hspace">&nbsp;</span><span class="RktVal">expected</span><span class="hspace">&nbsp;</span><span class="RktVal">for</span><span class="hspace">&nbsp;</span><span class="RktVal">if</span><span class="hspace">&nbsp;</span><span class="RktVal">branches"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">errorType</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">throw</span><span class="RktPn">(</span><span class="RktSym">TypecheckException</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Finally, the type checker:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprAST</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ty|Error</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">Type</span><span class="hspace">&nbsp;</span><span class="RktCmt">checks</span><span class="hspace">&nbsp;</span><span class="RktCmt">[expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">either</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">its</span><span class="hspace">&nbsp;</span><span class="RktCmt">type</span><span class="hspace">&nbsp;</span><span class="RktCmt">or</span><span class="hspace">&nbsp;</span><span class="RktCmt">throws</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">type</span><span class="hspace">&nbsp;</span><span class="RktCmt">error</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr::EInt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr::ENeg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">expr.expr</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIntDomain</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr::EAdd</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">ExprAST</span><span class="RktPn">[</span><span class="RktSym">expr.left</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.right</span><span class="RktPn">]</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIntDomain</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr::EEq</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">ExprAST</span><span class="RktPn">[</span><span class="RktSym">expr.left</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.right</span><span class="RktPn">]</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tInt</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIntDomain</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tBool</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr::EIf</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" class="RktStxLink" data-pltdoc="x">let</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">expr.econd</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tBool</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ERRTyIfCond</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">tthen</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">telse</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr.ethen</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr.eelse</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tthen</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">telse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tthen</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">errorType</span><span class="RktPn">(</span><span class="RktSym">ERRTyIfBranches</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">end</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ExprAST,</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ty)</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ty|Error</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">Type</span><span class="hspace">&nbsp;</span><span class="RktCmt">checks</span><span class="hspace">&nbsp;</span><span class="RktCmt">[expr]</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">matches</span><span class="hspace">&nbsp;</span><span class="RktCmt">its</span><span class="hspace">&nbsp;</span><span class="RktCmt">type</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">[ty]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">expr::ExprAST</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ty::Ty</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">errMsg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheck</span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ty</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ty</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">errorType</span><span class="RktPn">(</span><span class="RktSym">errMsg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ExprASTList,</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ty)</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">TyList|Error</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;#</span><span class="hspace">&nbsp;</span><span class="RktCmt">Type</span><span class="hspace">&nbsp;</span><span class="RktCmt">checks</span><span class="hspace">&nbsp;</span><span class="RktCmt">expressions</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">[exprs]</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">matches</span><span class="hspace">&nbsp;</span><span class="RktCmt">their</span><span class="hspace">&nbsp;</span><span class="RktCmt">types</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">[ty]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">exprs::ExprASTList</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ty::Ty</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">errMsg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="RktValLink" data-pltdoc="x">map</a></span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">typecheckMatch</span><span class="RktPn">(</span><span class="RktSym">expr</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ty</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">errMsg</span><span class="RktPn">)</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote%29%29" class="RktStxLink" data-pltdoc="x">,</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">exprs</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Assuming we will run the interpreter on well-typed expressions,
the extension to the interpreter is rather modest:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EEq</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.left</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._~3d~3d%29%29" class="RktStxLink" data-pltdoc="x">==</a></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.right</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr::EIf</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._~3d%29%29" class="RktValLink" data-pltdoc="x">=</a></span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">interpret</span><span class="RktPn">(</span><span class="RktSym">expr.econd</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.ethen</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">expr.eelse</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Note that we did not have to touch any old code to extend the language!  We
simply defined new data and added new methods.  Recall
<a href="#%28counter._%28figure._fig~3aext-multiple%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">69</span></a>, the diagrammatic placement of multiple
dispatch with respect to the extensibility problem.  Of course, nothing
comes for free.  Because multiple dispatch is so flexible, someone or
something has to suffer.</p><ul><li><p>It can be hard for the user to predict which methods are called here and there.</p></li><li><p>Dispatch is not easy to implement efficiently.
<span class="refelem"><span class="refcolumn"><span class="refcontent">Julia is JIT-compiled and employs type inference
to "statically" resolve as many function calls as possible.</span></span></span></p></li><li><p>Fully-fledged multiple dispatch might be hard to type check,
depending on the the kind of logical types and guarantees
one wants to provide.</p></li></ul><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture14.html" title="backward to &quot;14 --- More Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture16.html" title="forward to &quot;16 --- Gradual Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
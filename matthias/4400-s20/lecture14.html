<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>14 --- More Types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Principles of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="communication.html" class="tocviewlink" data-pltdoc="x">Email, Office Hours, Etc.</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">In-<wbr></wbr>Class Reviews</a></td></tr><tr><td align="right"></td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right"></td><td><a href="assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x">1 &#8212;<wbr></wbr> Programming Languages:<span class="mywbr"> &nbsp;</span> Research and Teaching</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x">2 &#8212;<wbr></wbr> Parsing</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x">3 &#8212;<wbr></wbr> Scope, Compilation</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x">4 &#8212;<wbr></wbr> Compilers; Fun</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x">5 &#8212;<wbr></wbr> Help!</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x">6 &#8212;<wbr></wbr> Recursive Functions</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x">7 &#8212;<wbr></wbr> Errors and Ordering</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x">8 &#8212;<wbr></wbr> Assignments</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x">9 &#8212;<wbr></wbr> Store Passing</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x">10 &#8212;<wbr></wbr> <span class="emph">What</span> and <span class="emph">When</span></a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x">13 &#8212;<wbr></wbr> Poly Types</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.6.0.9</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture13.html" title="backward to &quot;13 --- Poly Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="readings.html" title="forward to &quot;Readings&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._lecture14)"></a>14 &#8212;<wbr></wbr> More Types</h4><a name="(part._chap~3alecture14)"></a><p><span style="font-weight: bold">Friday, 21 February 2020</span></p><p><span style="font-weight: bold">Presenters</span> (1) William Victoria &amp; Lenny Xie (2) Vadym Matviichuk,
Oleksandr Litus</p><p>The topic of types is so large that some people spend the entire principles of
programming languages course on types. Some people go even as far as saying that
a programming language must be understood as the &ldquo;sum of its types,&rdquo; that is,
the entire topic must be organized around the study of types and the linguistic
constructs that introduce and eliminate certain forms of types.</p><p>While this idea has an elegant appeal and is worth studying somewhat, it would
be wrong to view the entire area through this angle, as if programming languages
weren&rsquo;t organically grown artifacts.</p><p>In the spirit of looking at ideas that you are likely to encounter, here are two
more from the world of structural typing that has so dominated research in this
area.</p><h4><a name="(part._.Structural_vs_.Nominal_.Subtyping)"></a>Structural vs Nominal Subtyping</h4><p><span style="font-weight: bold">Typing and Subtyping &#224; la Java</span></p><p>Take a look at <a href="#%28counter._%28figure._fig~3anominal%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">64</span></a>, which shows two &ldquo;parallel&rdquo; class
hierarchies. The <span class="stt">extends</span> is just to indicate the classes sit inside of
an fixed class hierarchy.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Aplus extends Object {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int m(int x) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return 42; }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Aprime extends Object {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int m(int x) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return 42; }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3anominal))" x-target-lift="Figure"></a>Figure&nbsp;64: </span>Nomimnal Typing for Classes</span></p></blockquote><p><div class="SIntrapara"><span style="font-weight: bold">Question</span> Are instances of <span class="stt">Aplus</span> and <span class="stt">Aprime</span> compatible with
each other? Would the following work?
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class ConsumeA {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int k(Aprime a) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return a.m(1); }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">... new ConsumeA().k(new Aplus()) ...</span></p></td></tr></table></div><div class="SIntrapara">No! Because <span class="stt">Aplus</span> is not a subtype of <span class="stt">Aprime</span>, and a method of
input type <span class="stt">Aprime</span> can accept only objects of this type or subtypes.</div></p><p>What is the impact of this strictly name-based subtyping on software
development? When programmers create their own separate hierarchy of
classes, like the one for <span class="stt">Aplus</span>, they cannot simultaneously inject
this class into the class hierarchy of <span class="stt">Aprime</span> and will then be forced
to copy code, write adapters (and lose some benefits from type checking),
or resort to other tricks.</p><p><span style="font-weight: bold">Typing and Subtyping &#224; la Typed Racket</span></p><p>At first glance, <a href="#%28counter._%28figure._fig~3astructural%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">65</span></a> presents code that is
identical to <a href="#%28counter._%28figure._fig~3anominal%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">64</span></a> but written in Typed Racket.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed%2Fracket%2Fbase..rkt%29._define-type%29%29" class="RktStxLink" data-pltdoc="x">define-type</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Class</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed%2Fracket%2Fbase..rkt%29._define-type%29%29" class="RktStxLink" data-pltdoc="x">define-type</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Class</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3astructural))" x-target-lift="Figure"></a>Figure&nbsp;65: </span>Structural Typing for Classes</span></p></blockquote><p><div class="SIntrapara">Now we can ask the same question again. Will the following run properly?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeA</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeA</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">This time the answer is &ldquo;yes!&rdquo; because Typed Racket uses
<span class="emph">structural</span> typing for classes.</div></p><p>In a structural type system a method may accept any object that has the
methods (and fields), properly typed, as specified in the parameter&rsquo;s
type. The type checker accepts such calls, and all method invocations will
work out&#8212;<wbr></wbr>in the sense of types.</p><p><div class="SIntrapara">On the output side, a method is also allowed to return any object that has
the specified methods (and fields) of the proper type&#8212;<wbr></wbr>even if it is not
in the type hierarchy:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeAgain</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fprivate%29%29" class="RktStxLink" data-pltdoc="x">define/private</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeAgain</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>In short, structural typing makes a software developer&rsquo;s life easier,
because it enables more code reuse than nominal subtyping. But, as always,
it imposes a burden on the implementor of the type checker (and
implementation).</p><p><span style="font-weight: bold">Some Basic Rules</span></p><p><div class="SIntrapara">Let&rsquo;s introduce a second <span style="font-style: italic">base type</span>, called <span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">nat</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">It &ldquo;predicts&rdquo; the collection of all non-negative integers.</div></p><p><div class="SIntrapara">We need a new relationship for types: <span class="stt">&lt;:</span>. Here is the way researchers
specify this relationship:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt"></span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">t* &lt;: t,</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">s &lt;:s*</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t*</span><span class="stt"> </span><span class="RktSym">s*</span><span class="RktPn">)</span></p></td></tr></table></div></p><p><div class="SIntrapara">Now we can add some new typing rules:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">n &gt;= 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">TEnv |- n : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- l : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt">,</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">TEnv |- r : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- [tnode o l r] : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- f : </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- a : </span><span class="RktSym">t*</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">t* &lt; t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- [tcall f a] : s</span></p></td></tr></table></div></p><p>Take a look at the example in <a href="#%28counter._%28figure._fig~3asub%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">66</span></a>.</p><p>Yes, it really makes sense to permit a natural number to play the role of an
integer during computation. And that&rsquo;s what such rules are:
predictors. This one feels okay.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 1: 0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 2: apply the application rule to the open claim</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- 4 : ______</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: __________________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 3: apply the rule for literal numeric constants to the second open</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">claim above the line</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: _____________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 4: apply the fun and variable rules to the first open claim</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">claim above the line</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 5: fill in the function type</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 6: recognize that while the domain and argument types differ,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="emph">they are compatible</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">&lt;:</span></span><span class="highlighted"><span class="stt"> </span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">nat</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="stt"> </span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">int</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 7: hence, we have established the claim that the program itself</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is of type </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asub))" x-target-lift="Figure"></a>Figure&nbsp;66: </span>Nomimnal Typing for Classes</span></p></blockquote><p><div class="SIntrapara">An alternative is this rule:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- e : t</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">s &lt;: t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- e : s</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></div><div class="SIntrapara">But if we introduce this rule, generating the &ldquo;tree&rdquo; of rule instances
that confirm the consistency of type specifications with code becomes much
harder. We say that the rule system is no longer algorithmic.</div></p><h4><a name="(part._.Type_.Inference)"></a>Type Inference</h4><p>Throughout the history of programming languages people have expressed the idea
that writing down types is painful and useless. They are correct with respect to
pain. As language designers add power to the type system, types become complex
pieces of code development in their own right, and it is easy to make
mistakes. The problem becomes particularly acute with the addition of
polymorphic types. In response to this idea, programming language people have
invested a lot of energy into <span style="font-style: italic">type inference</span>.</p><p>As for the second part of the claim&#8212;<wbr></wbr>uselessness&#8212;<wbr></wbr>these people are plain
wrong.  But to understand why an idea could be wrong you first need to
understand the idea so you can grasp the reason(s) why it might be the wrong
idea.</p><p><span style="font-weight: bold">Module-Level Inference</span></p><p><div class="SIntrapara">In most general terms, type inference is stated as the following problem:
</div><div class="SIntrapara"><blockquote><p> Take fully typed programs in a typed language. Erase
some of the type specifications for variables (parameters, declarations). Find
an algorithm that can restore the type variables in all cases.</p></blockquote></div></p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Curry and Feys worked out the very basics first.
Hindley expanded their work to a full typed lambda calculus at
Swansea. Milner (who was in the same academic department at Swansea)
re-invented the algorithm ten years later and made it famous as ML&rsquo;s
inference algorithm. It is known as Hindley-Milner inference now.</span></span></span></p><p>The solution to the most well-known instance of this general problem is known as
<span style="font-style: italic">Hindley-Milner type inference</span>. Two well-known languages rely on HM
type inference: ML and Haskell. HM inference roughly applies to languages such
as those used in this course, extended with type products, sums, and records,
plus explicitly declared recursive datatypes (lists, trees).  The algorithm also
accommodates reference cells like those used in <a href="5.html" data-pltdoc="x">5 &#8212;<wbr></wbr> Simple Mutable Objects</a>. People have found a
few other extensions for which an adaptation of the algorithm works, especially
the group supporting the OCaml language, but it is not worth your time studying
these until you must understand them.</p><p>Let&rsquo;s assume for the rest of this section that <span class="RktSym">tdecl</span> does not introduce
recursion.</p><p><div class="SIntrapara"><span style="font-weight: bold">Variables and Equations</span> The goal of this section is to introduce the idea
of HM type inference via examples. So say we take the program on the left and
erase its types to get the program on the right:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVar">______________</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVar">____</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td></tr></table></div><div class="SIntrapara">The holes (represented with underlines) express the idea that the type
specifications for these variables are <span class="emph">unknown</span>.</div></p><p><div class="SIntrapara">1. In mathematics an unknown quantity is called a variable. So we introduce
the concept of a <span style="font-style: italic">type variable</span> and fill these holes with capital
letters corresponding to the lowercase program variable names:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">F</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td></tr></table></div><div class="SIntrapara">In K-12 mathematics, variables range over numbers. Here they range over
the types <span class="emph">Ty</span> of our language.</div></p><p><div class="SIntrapara">We can go even further and annotate each sub-expression with a type
variable, just like we annotated all sub-expressions with types in
<a href="6.html" data-pltdoc="x">6 &#8212;<wbr></wbr> Type Checking</a>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">F</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="RktRdr">,</span><span class="RktSym">X</span><span class="RktPn">}</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktVal">1</span><span class="RktRdr">,</span><span class="RktSym">O</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">FB</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">R</span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">(We skip the sub-expressions in the body of <span class="RktSym">tdecl</span>.)</div></p><p><table cellspacing="0" cellpadding="0"><tr><td valign="top"><p>F = R</p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tdecl</span> demands the declared type is equal to the computed type of the right-hand side</p></td></tr><tr><td valign="top"><p>R = <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">X</span><span class="stt"> </span><span class="RktSym">FB</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tfun*</span> demands a function has an <span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span>
type, whose domain is the specified type (X) and whose result is the
computed type of the body</p></td></tr><tr><td valign="top"><p>X = <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tnode</span> demands +&rsquo;s arguments are of type <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr><tr><td valign="top"><p>O = <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tnode</span> demands +&rsquo;s arguments are of type <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr></table></p><p>3. We can solve equations to find out which values of variables solve
them. Recall that solving means you can plug the values in for the
variables and you get equations whose left-hand side is the same as the
right-hand side.</p><p><div class="SIntrapara">Let&rsquo;s solve the above equations. We proceed as always by replacing all
variables for which we know the value (type) in all other equations with
their values:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = R</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">X</span><span class="stt"> </span><span class="RktSym">FB</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">FB = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></div></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = R</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">FB = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">FB = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></p><p>Now we have the values of the variables we originally put into the program
for the specified type, and they are the same as before.</p><p><span style="font-weight: bold">Note</span> What&rsquo;s the difference between this and linear algebra?  The
constructor symbols have no (inverse) laws on them.  We say they are
uninterpreted.</p><p>Let&rsquo;s play this game for an example.</p><p><span style="font-weight: bold">Copying Code</span></p><p>Here is an alternative one:</p><p><div class="SIntrapara">Here is how get polymorphism, ineffectively:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">TEnv |- bdy[x &lt;- rhs] : s</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">TEnv |- [TLET* x ty rhs bdy] : s</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv + (x,TYPE) |- </span><span class="RktSym">f</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: (All (x) t),</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">t : Type</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">TEnv |- </span><span class="RktPn">(</span><span class="RktSym">CALL</span><span class="stt"> </span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">t</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: (All (x) s)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></div></p><p><span style="font-weight: bold">Why Type Inference is Wrong</span></p><p>1:</p><p>Stated in this form, the type inference problem is <span class="emph">undecidable</span> for almost
all typed languages and ways of erasing types.</p><p>2: error messages for HM type inference with <span style="font-weight: bold">let</span>-polymorphosm</p><p>3: specification vs implementation</p><p><span style="font-weight: bold">Local Type Inference</span></p><h4><a name="(part._.Other_.Types)"></a>Other Types</h4><p>Haskell&rsquo;s separatist ways: type classes</p><p>ML&rsquo;s separatist ways: module types (a restricted form of dependent type; see below)</p><p>What you might see in the future:</p><p><div class="SIntrapara">- substructural types
</div><div class="SIntrapara"><ul><li><p>refinment types (Typed Racket; numeric constraints: array access)</p></li><li><p>affine (Rust; object ownership)</p></li></ul></div></p><p>- dependent types (Coq, Agda)</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture13.html" title="backward to &quot;13 --- Poly Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="readings.html" title="forward to &quot;Readings&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
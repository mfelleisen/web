<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>14 --- More Types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Principles of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="communication.html" class="tocviewlink" data-pltdoc="x">Email, Office Hours, Etc.</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">In-<wbr></wbr>Class Reviews</a></td></tr><tr><td align="right"></td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right"></td><td><a href="assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x">1 &#8212;<wbr></wbr> Programming Languages:<span class="mywbr"> &nbsp;</span> Research and Teaching</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x">2 &#8212;<wbr></wbr> Parsing</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x">3 &#8212;<wbr></wbr> Scope, Compilation</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x">4 &#8212;<wbr></wbr> Compilers; Fun</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x">5 &#8212;<wbr></wbr> Help!</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x">6 &#8212;<wbr></wbr> Recursive Functions</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x">7 &#8212;<wbr></wbr> Errors and Ordering</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x">8 &#8212;<wbr></wbr> Assignments</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x">9 &#8212;<wbr></wbr> Store Passing</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x">10 &#8212;<wbr></wbr> <span class="emph">What</span> and <span class="emph">When</span></a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x">13 &#8212;<wbr></wbr> Poly Types</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x">15 &#8212;<wbr></wbr> JULIA Types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x">16 &#8212;<wbr></wbr> Gradual Types</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x">17 &#8212;<wbr></wbr> CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x">18 &#8212;<wbr></wbr> ONLINE</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x">19 &#8212;<wbr></wbr> CANCELLED</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x">20 &#8212;<wbr></wbr> Control from CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x">21 &#8212;<wbr></wbr> State Machines</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x">22 &#8212;<wbr></wbr> C, CC, CK</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x">23 &#8212;<wbr></wbr> CEK, CESK</a></td></tr><tr><td align="right"></td><td><a href="lecture24.html" class="tocviewlink" data-pltdoc="x">24 &#8212;<wbr></wbr> Memory, Safety</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x">25 &#8212;<wbr></wbr> Space</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x">26 &#8212;<wbr></wbr> Expressiveness</a></td></tr><tr><td align="right"></td><td><a href="lecture27.html" class="tocviewlink" data-pltdoc="x">27 &#8212;<wbr></wbr> The Ideas</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x">28 &#8212;<wbr></wbr> Monads</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x">29 &#8212;<wbr></wbr> Grab Programming</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.6.0.19</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture13.html" title="backward to &quot;13 --- Poly Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture15.html" title="forward to &quot;15 --- JULIA Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._lecture14)"></a>14 &#8212;<wbr></wbr> More Types</h4><a name="(part._chap~3alecture14)"></a><p><span style="font-weight: bold">Friday, 21 February 2020</span></p><p><span style="font-weight: bold">Presenters</span> (1) William Victoria &amp; Lenny Xie (2) Vadym Matviichuk,
Oleksandr Litus</p><p>The topic of types is so large that some people spend the entire principles of
programming languages course on types. Some people go even as far as saying that
a programming language must be understood as the &ldquo;sum of its types,&rdquo; that is,
the entire topic must be organized around the study of types and the linguistic
constructs that introduce and eliminate certain forms of types.</p><p>While this idea has an elegant appeal and is worth studying somewhat, it would
be wrong to view the entire area through this angle, as if programming languages
weren&rsquo;t organically grown artifacts.</p><p>In the spirit of looking at ideas that you are likely to encounter, here are two
more from the world of structural typing that has so dominated research in this
area.</p><h4><a name="(part._.Structural_vs_.Nominal_.Subtyping)"></a>Structural vs Nominal Subtyping</h4><p><span style="font-weight: bold">Typing and Subtyping &#224; la Java</span></p><p>Take a look at <a href="#%28counter._%28figure._fig~3anominal%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">64</span></a>, which shows two &ldquo;parallel&rdquo; class
hierarchies. The <span class="stt">extends</span> is just to indicate the classes sit inside of
an fixed class hierarchy.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Aplus extends Object {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int m(int x) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return 42; }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class Aprime extends Object {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int m(int x) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return 42; }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3anominal))" x-target-lift="Figure"></a>Figure&nbsp;64: </span>Nomimnal Typing for Classes</span></p></blockquote><p><div class="SIntrapara"><span style="font-weight: bold">Question</span> Are instances of <span class="stt">Aplus</span> and <span class="stt">Aprime</span> compatible with
each other? Would the following work?
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">class ConsumeA {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">public int k(Aprime a) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">return a.m(1); }</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">... new ConsumeA().k(new Aplus()) ...</span></p></td></tr></table></div><div class="SIntrapara">No! Because <span class="stt">Aplus</span> is not a subtype of <span class="stt">Aprime</span>, and a method of
input type <span class="stt">Aprime</span> can accept only objects of this type or subtypes.</div></p><p>What is the impact of this strictly name-based subtyping on software
development? When programmers create their own separate hierarchy of
classes, like the one for <span class="stt">Aplus</span>, they cannot simultaneously inject
this class into the class hierarchy of <span class="stt">Aprime</span> and will then be forced
to copy code, write adapters (and lose some benefits from type checking),
or resort to other tricks.</p><p><span style="font-weight: bold">Typing and Subtyping &#224; la Typed Racket</span></p><p>At first glance, <a href="#%28counter._%28figure._fig~3astructural%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">65</span></a> presents code that is
identical to <a href="#%28counter._%28figure._fig~3anominal%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">64</span></a> but written in Typed Racket.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed%2Fracket%2Fbase..rkt%29._define-type%29%29" class="RktStxLink" data-pltdoc="x">define-type</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Class</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed%2Fracket%2Fbase..rkt%29._define-type%29%29" class="RktStxLink" data-pltdoc="x">define-type</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Class</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="hspace">&nbsp;</span><span class="RktSym">Integer</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">42</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3astructural))" x-target-lift="Figure"></a>Figure&nbsp;65: </span>Structural Typing for Classes</span></p></blockquote><p><div class="SIntrapara">Now we can ask the same question again. Will the following run properly?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeA</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeA</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">This time the answer is &ldquo;yes!&rdquo; because Typed Racket uses
<span class="emph">structural</span> typing for classes.</div></p><p>In a structural type system a method may accept any object that has the
methods (and fields), properly typed, as specified in the parameter&rsquo;s
type. The type checker accepts such calls, and all method invocations will
work out&#8212;<wbr></wbr>in the sense of types.</p><p><div class="SIntrapara">On the output side, a method is also allowed to return any object that has
the specified methods (and fields) of the proper type&#8212;<wbr></wbr>even if it is not
in the type hierarchy:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeAgain</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29" class="RktStxLink" data-pltdoc="x">class</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._object~25%29%29" class="RktValLink" data-pltdoc="x">object%</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super-new%29%29" class="RktStxLink" data-pltdoc="x">super-new</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fpublic%29%29" class="RktStxLink" data-pltdoc="x">define/public</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._define%2Fprivate%29%29" class="RktStxLink" data-pltdoc="x">define/private</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Instance</span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aplus%</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._send%29%29" class="RktStxLink" data-pltdoc="x">send</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ConsumeAgain</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/objcreation.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._new%29%29" class="RktStxLink" data-pltdoc="x">new</a></span><span class="hspace">&nbsp;</span><span class="RktSym">Aprime%</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>In short, structural typing makes a software developer&rsquo;s life easier,
because it enables more code reuse than nominal subtyping. But, as always,
it imposes a burden on the implementor of the type checker (and
implementation).</p><p><span style="font-weight: bold">Some Basic Rules</span></p><p><div class="SIntrapara">Let&rsquo;s introduce a second <span style="font-style: italic">base type</span>, called <span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">nat</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">It &ldquo;predicts&rdquo; the collection of all non-negative integers.</div></p><p><div class="SIntrapara">We need a new relationship for types: <span class="stt">&lt;:</span>. Here is the way researchers
specify this relationship:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt"></span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">t* &lt;: t,</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">s &lt;:s*</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t*</span><span class="stt"> </span><span class="RktSym">s*</span><span class="RktPn">)</span></p></td></tr></table></div></p><p><div class="SIntrapara">Now we can add some new typing rules:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">n &gt;= 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">TEnv |- n : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- l : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt">,</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">TEnv |- r : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- [tnode o l r] : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- f : </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- a : </span><span class="RktSym">t*</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">t* &lt; t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- [tcall f a] : s</span></p></td></tr></table></div></p><p>Take a look at the example in <a href="#%28counter._%28figure._fig~3asub%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">66</span></a>.</p><p>Yes, it really makes sense to permit a natural number to play the role of an
integer during computation. And that&rsquo;s what such rules are:
predictors. This one feels okay.</p><blockquote class="Figure"><blockquote class="Leftfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 1: 0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 2: apply the application rule to the open claim</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- 4 : ______</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: __________________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 3: apply the rule for literal numeric constants to the second open</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">claim above the line</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: _____________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 4: apply the fun and variable rules to the first open claim</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">claim above the line</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktVar">____</span><span class="stt"> </span><span class="RktVar">____</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 5: fill in the function type</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 6: recognize that while the domain and argument types differ,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="emph">they are compatible</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">x is in the one-element TENV</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(x: </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt">) |- x : </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">4 &gt;= 0 check</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------------</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">---------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">0 |- 4 : (nat)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">&lt;:</span></span><span class="highlighted"><span class="stt"> </span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">nat</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="stt"> </span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">int</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0 |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: ______________</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">STEP 7: hence, we have established the claim that the program itself</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is of type </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asub))" x-target-lift="Figure"></a>Figure&nbsp;66: </span>Nomimnal Typing for Classes</span></p></blockquote><p><div class="SIntrapara">An alternative is this rule:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- e : t</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">s :&gt; t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">----------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- e : s</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></table></div><div class="SIntrapara">But if we introduce this rule, generating the &ldquo;tree&rdquo; of rule instances
that confirm the consistency of type specifications with code becomes much
harder. We say that the rule system is no longer algorithmic.</div></p><h4><a name="(part._.Type_.Inference_and_let_.Polymorphism)"></a>Type Inference and <span style="font-weight: bold">let</span> Polymorphism</h4><p>Throughout the history of programming languages people have expressed the idea
that writing down types is painful and useless. They are correct with respect to
pain. As language designers add power to the type system, types become complex
pieces of code development in their own right, and it is easy to make
mistakes. The problem becomes particularly acute with the addition of
polymorphic types. In response to this idea, programming language people have
invested a lot of energy into <span style="font-style: italic">type inference</span>.</p><p>As for the second part of the claim&#8212;<wbr></wbr>uselessness&#8212;<wbr></wbr>these people are plain
wrong.  But to understand why an idea could be wrong you first need to
understand the idea so you can grasp the reason(s) why it might be the wrong
idea.</p><p><span style="font-weight: bold">Module-Level Inference</span></p><p><div class="SIntrapara">In most general terms, type inference is stated as the following problem:
</div><div class="SIntrapara"><blockquote><p> Take fully typed programs in a typed language. Erase
some of the type specifications for variables (parameters, declarations). Find
an algorithm that can restore the type variables in all cases.</p></blockquote></div></p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Curry and Feys worked out the very basics first.  Hindley
expanded their work to a full typed lambda calculus at Swansea. Milner (who
was in the same academic department at Swansea) re-invented the algorithm
ten years later and made it famous as ML&rsquo;s inference algorithm for let
polymorphism. It is known as Hindley-Milner inference now.</span></span></span></p><p>The solution to the most well-known instance of this general problem is known as
<span style="font-style: italic">Hindley-Milner type inference</span>. Two well-known languages rely on HM
type inference: ML and Haskell. HM inference roughly applies to languages such
as those used in this course, extended with type products, sums, and records,
plus explicitly declared recursive datatypes (lists, trees).  The algorithm also
accommodates reference cells like those used in <a href="5.html" data-pltdoc="x">5 &#8212;<wbr></wbr> Simple Mutable Objects</a>. People have found a
few other extensions for which an adaptation of the algorithm works, especially
the group supporting the OCaml language, but it is not worth your time studying
these until you must understand them.</p><p>Let&rsquo;s assume for the rest of this section that <span class="RktSym">tdecl</span> does not introduce
recursion.</p><p><div class="SIntrapara"><span style="font-weight: bold">Variables and Equations</span> The goal of this section is to introduce the idea
of HM type inference via examples. So say we take the program on the left and
erase its types to get the program on the right:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVar">______________</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVar">____</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td></tr></table></div><div class="SIntrapara">The holes (represented with underlines) express the idea that the type
specifications for these variables are <span class="emph">unknown</span>.</div></p><p><div class="SIntrapara">1. In mathematics an unknown quantity is called a variable. So we introduce
the concept of a <span style="font-style: italic">type variable</span> and fill these holes with capital
letters corresponding to the lowercase program variable names:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">F</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></td></tr></table></div><div class="SIntrapara">In K-12 mathematics, variables range over numbers. Here they range over
the types <span class="emph">Ty</span> of our language.</div></p><p><div class="SIntrapara">We can go even further and annotate each sub-expression with a type
variable, just like we annotated all sub-expressions with types in
<a href="6.html" data-pltdoc="x">6 &#8212;<wbr></wbr> Type Checking</a>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">F</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tfun</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktSym">x</span><span class="RktRdr">,</span><span class="RktSym">X</span><span class="RktPn">}</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktVal">1</span><span class="RktRdr">,</span><span class="RktSym">O</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">FB</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">R</span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">42</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">(We skip the sub-expressions in the body of <span class="RktSym">tdecl</span>.)</div></p><p>2. In mathematics we learn to set up equations that govern and constrain
variables. In the context of type checking, we can use the type-checking
rules to find equations.</p><p><div class="SIntrapara">The rules from <a href="lecture11.html" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a> hide equality constraints with clever
notation. Consider the type checking rule for function application (on the
left):
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- f : </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">t</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- a : </span><span class="RktSym">t</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: s</span></p></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- f : </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">u</span><span class="stt"> </span><span class="RktSym">s</span><span class="RktPn">)</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- a : </span><span class="RktSym">t</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">u == t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-----------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- </span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="stt"> </span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: w</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">and</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">w = s</span></p></td></tr></table></td></tr></table></div></p><p>This simple looking rule imposes the constraint that the domain part of the
function type is equal to the type of the argument expression. When we
expressed this as code, we actually had to make this test explicit. The
rule on the right side shows how we can express this idea as an equational
constraint.</p><p><div class="SIntrapara">For some of the rules, we have to look a bit harder to see the equations:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- l : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- r : </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">---------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- </span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="stt"> </span><span class="RktSym">o</span><span class="stt"> </span><span class="RktSym">l</span><span class="stt"> </span><span class="RktSym">r</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span></p></td></tr></table></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- l : tl</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tl == </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- r : tr</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tr == </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">--------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">TEnv |- </span><span class="RktPn">[</span><span class="RktSym">tnode</span><span class="stt"> </span><span class="RktSym">o</span><span class="stt"> </span><span class="RktSym">l</span><span class="stt"> </span><span class="RktSym">r</span><span class="RktPn">]</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">: u</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">and</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">u = </span><span class="RktPn">(</span><span class="RktSym">nat</span><span class="RktPn">)</span></p></td></tr></table></td></tr></table></div></p><p>Once the rules are written this way, it becomes straightforward to derive
equations that govern the type variables we have attached to terms. Here is
a table of equations with their justification:</p><p><table cellspacing="0" cellpadding="0"><tr><td valign="top"><p>F = R</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tdecl</span> demands the declared type is equal</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>  to the computed type of the right-hand side</p></td></tr><tr><td valign="top"><p>R = <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">X</span><span class="stt"> </span><span class="RktSym">B</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tfun*</span> demands a function has an <span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span> type,</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>whose domain is the specified type (X) and</p></td></tr><tr><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>whose result is the computed type of the body</p></td></tr><tr><td valign="top"><p>X = <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tnode</span> demands +&rsquo;s arguments are of type <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr><tr><td valign="top"><p>O = <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktSym">tnode</span> demands +&rsquo;s arguments are of type <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span></p></td></tr></table></p><p>3. We can solve equations to find out which values of variables solve
them. Recall that solving means you can plug the values in for the
variables and you get equations whose left-hand side is the same as the
right-hand side.</p><p><div class="SIntrapara">Let&rsquo;s solve the above equations. We proceed as always by replacing all
variables for which we know the value (type) in all other equations with
their values:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = R</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktSym">X</span><span class="stt"> </span><span class="RktSym">B</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></td><td><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = R</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></td><td><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">F = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">R = </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">O = (int)</span></p></td></tr></table></td></tr></table></div></p><p>The process yields one solution per type variable that we put into the
program, and the values are the same that we erased.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>In calculation-oriented math courses, as they are now common,
all you see is matrix manipulations. But these manipulations are really
just efficient representations of equality-preserving operations on
equations.</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">Note</span> What&rsquo;s the difference between this and linear algebra?  The
constructor symbols have no (inverse) laws on them.  We say they are
<span style="font-style: italic">uninterpreted</span>. The process of solving relies on matching the
parts of the type constructors (here <span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span>), which really just
generalizes the Gaussian elimination process for solving linear equations
over numbers.</p><p><div class="SIntrapara"><span style="font-weight: bold">LET Polymorphism</span> Once we understand type inference in terms of
equations, we can analyze it in standard mathematical terms. A system of
equations may have
</div><div class="SIntrapara"><ul><li><p><span class="emph">a single solution</span></p><p>In middle school a single solution is the most desirable. When it comes to
type inference, it means type checking succeeded in an ordinary manner.</p></li><li><p><span class="emph">no solution</span></p><p>Type checking would fail. There are no types that get this expression thru
the type checker. None. Don&rsquo;t even look.</p></li><li><p><span class="emph">an infinite number of solutions</span></p><p>When you solve a system of three equations in three variables and two are
dependent,  you get an equation that describes a two-dimensional
plain. In the context of type inference, you get a function whose type is
compatible with several, seemingly distinct uses.</p><p>Milner called this idea <span style="font-style: italic">let polymorphism</span>, and it was&#8212;<wbr></wbr>and by
some OCaml and Haskell programmers still is&#8212;<wbr></wbr>considered a practical and
lightweight form of useful polymorphism. </p></li></ul></div></p><p><div class="SIntrapara">Here is a sketch of how and why it works. Consider this expression:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">g</span><span class="hspace">&nbsp;</span><span class="RktVar">___</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Notice how <span class="RktSym">f</span>, the identity function, is used in two different
ways: a function on <span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span> and another one on <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="RktPn">)</span>. From the interpreter&rsquo;s perspective this ambiguity poses no
problem, but our simple type system does not bless this program.</div></p><p><div class="SIntrapara">Let-polymorphism&#8212;<wbr></wbr>so called because Milner used &ldquo;let&rdquo; instead of
&ldquo;decl&rdquo;&#8212;<wbr></wbr>accommodates this kind of program. The easiest way to understand
the idea is to ignore recursive declaration for a moment and to use a
completely different rule for checking <span class="RktSym">tdecl</span>:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">TEnv |- bdy[x &lt;- rhs] : s</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">TEnv |- rhs : t</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">------------------------------------------------</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">TEnv |- [tdecl x _ rhs bdy] : s</span></p></td></tr></table></div><div class="SIntrapara">This alternative rule has two rather different premises:
<span class="refelem"><span class="refcolumn"><span class="refcontent">Copying code is a <span class="emph">bad</span> way of generating the equations
for the type variables. It is inefficient and getting recursion right is
hard. But it is a good way to understand the mechanism and the problems it
causes.</span></span></span>
</div><div class="SIntrapara"><ul><li><p>The one on the left represents the new idea. Instead of assigning
<span class="stt">x</span> a type in <span class="stt">TEnv</span>, it substitutes <span class="stt">rhs</span> for every occurrence of
<span class="stt">x</span> in <span class="stt">bdy</span>. Intuitively this copies the type variable for <span class="stt">x</span>
and thus permits different solutions for each copy of the type variable.</p></li><li><p>The one on the right merely confirms that <span class="stt">rhs</span> has a
type. Without this premise and without a reference to <span class="stt">x</span> in <span class="stt">bdy</span>, a
<span class="stt">tdecl</span> expression may type check even though <span class="stt">rhs</span> doesn&rsquo;t. Since
the interpreter must determine the value of <span class="stt">rhs</span>, this failure could
cause a lack of soundness.</p></li></ul></div></p><p><div class="SIntrapara">Let&rsquo;s annotate the above example with just the necessary type variables:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tdecl</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">B</span><span class="RktPn">}</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">g</span><span class="hspace">&nbsp;</span><span class="RktSym">G</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Here is how we copy the function expression:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">g</span><span class="hspace">&nbsp;</span><span class="RktSym">G</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X1</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">B1</span><span class="RktPn">}</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tcall</span><span class="hspace">&nbsp;</span><span class="RktPn">{</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">X2</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktRdr">,</span><span class="RktSym">B2</span><span class="RktPn">}</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tfun*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">int</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">]</span></td></tr></table></blockquote></div><div class="SIntrapara">Note how <span class="stt">X</span> and <span class="stt">B</span> occur twice each and come with an index so we
can distinguish different uses. The relevant equations are these:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B1 = (-&gt; X1 X1)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X1 = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B2 = (-&gt; X2 X2)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X2 = (-&gt; (int) (int))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">G</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">= (-&gt; (int) (int))</span></p></td></tr></table></div><div class="SIntrapara">And it is indeed possible to solve them like this:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B1 = (-&gt; (int) (int))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X1 = (int)</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">B2 = (-&gt; (-&gt; (int) (int)) (-&gt; (int) (int)))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">X2 = (-&gt; (int) (int))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">G</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">= (-&gt; (int) (int))</span></p></td></tr></table></div><div class="SIntrapara">By solving them, we show that the &ldquo;expanded&rdquo; <span class="stt">tdecl</span> expression has a
value (according to our interpreter) because our type system is sound.</div></p><p>So type inference not only seems to make the use of types convenient, a
slight modification gives developers new powers. What&rsquo;s not to like?</p><p><span style="font-weight: bold">Why Type Inference is Wrong</span> Many things. Here are the two most
important ones:</p><ol><li><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Cardelli makes this point very forcefully in a DEC SRC
Technical Report titled <span class="emph">Typeful Programming</span>.</span></span></span> The second step of the
design recipe for functions demands the equivalent of a type
declaration. This signature is then used in subsequent steps to direct the
function design.</p><p>Programming people therefore dub a type signature a <span style="font-style: italic">specification</span>.
Think of a specification as a blue print, which shows the essential elements
of a building but not exactly what the finished product looks like.</p><p>The function definition itself is an <span style="font-style: italic">an implementation</span>. Roughly
speaking, the code is to the type what a building is to a blue print.</p><p>Type checking is making sure that the finished code adheres to the
specification.</p><p>Type inference thus fails us in two ways. First it removes an essential
element of systematic program design. Second it does not check the
compatibility of an independently created blue print with the finished
product. Besides unit tests, type checking is one of the simplest ways to
guarantee a few small things about our code before it runs.</p></li><li><p>Stated in its basic form, the type inference problem is
<span class="emph">undecidable</span> for almost all typed languages and ways of erasing types.</p><p>Technically, this means that there is no algorithm&#8212;<wbr></wbr>an always terminating
generative recursive function&#8212;<wbr></wbr>that can compute what the missing types
should be. The OCaml community has succeeded in extending it o an expressive
record and object system. The Haskell creators were able to deal with a rich
degree of overloading, called type classes.</p><p>From the perspective of language design, the consequence is much more
dramatic. It means that type inference is a brittle, unstable design
point. Every extension to a language must be carefully examined and is
subject to stringent algorithmic implementation constraints. But coupling
design with implementation constraints at an early stage is a bad idea.</p></li></ol><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Emeritus Professor Wand was one of the first to point out this
problem and to report some early results. He did so over three decades ago.</span></span></span></p><p>One secondary but substantial problem is the let-polymorphism that usually
comes with type inference. To this day, this form of inference does not
explain failures properly. In other words, when type inference fails because
the equation systems does not have a solution, the type inference algorithm
often (not always) reports an error in terms that is rarely actionable for
programmers.</p><p><span style="font-weight: bold">Local Type Inference</span> Because of the above, most type checkers employ
a form of type inference that is restricted to a single declaration,
definition, expression, or statement. This is particularly useful for the
application of polymorphic functions. When this form of inference fails, it
is easy to pinpoint a small region of code and help the developer.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture13.html" title="backward to &quot;13 --- Poly Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture15.html" title="forward to &quot;15 --- JULIA Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
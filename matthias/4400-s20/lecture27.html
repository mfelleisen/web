<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>27 --- Expressiveness</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Principles of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="communication.html" class="tocviewlink" data-pltdoc="x">Email, Office Hours, Etc.</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">In-<wbr></wbr>Class Reviews</a></td></tr><tr><td align="right"></td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right"></td><td><a href="assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x">1 &#8212;<wbr></wbr> Programming Languages:<span class="mywbr"> &nbsp;</span> Research and Teaching</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x">2 &#8212;<wbr></wbr> Parsing</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x">3 &#8212;<wbr></wbr> Scope, Compilation</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x">4 &#8212;<wbr></wbr> Compilers; Fun</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x">5 &#8212;<wbr></wbr> Help!</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x">6 &#8212;<wbr></wbr> Recursive Functions</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x">7 &#8212;<wbr></wbr> Errors and Ordering</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x">8 &#8212;<wbr></wbr> Assignments</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x">9 &#8212;<wbr></wbr> Store Passing</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x">10 &#8212;<wbr></wbr> <span class="emph">What</span> and <span class="emph">When</span></a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x">13 &#8212;<wbr></wbr> Poly Types</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x">15 &#8212;<wbr></wbr> JULIA Types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x">16 &#8212;<wbr></wbr> Gradual Types</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x">17 &#8212;<wbr></wbr> CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x">18 &#8212;<wbr></wbr> ONLINE</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x">19 &#8212;<wbr></wbr> CANCELLED</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x">20 &#8212;<wbr></wbr> Control from CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x">21 &#8212;<wbr></wbr> State Machines</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x">22 &#8212;<wbr></wbr> C, CC, CK</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x">23 &#8212;<wbr></wbr> CEK, CESK</a></td></tr><tr><td align="right"></td><td><a href="lecture24.html" class="tocviewlink" data-pltdoc="x">24 &#8212;<wbr></wbr> Memory, Safety</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x">25 &#8212;<wbr></wbr> Space</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x">26 &#8212;<wbr></wbr> Q &amp; A</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">27 &#8212;<wbr></wbr> Expressiveness</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x">28 &#8212;<wbr></wbr> Monads</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x">29 &#8212;<wbr></wbr> Grab Programming</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">27 &#8212;<wbr></wbr> Expressiveness</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.6.0.19</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture26.html" title="backward to &quot;26 --- Q &amp; A&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture28.html" title="forward to &quot;28 --- Monads&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._lecture27)"></a>27 &#8212;<wbr></wbr> Expressiveness</h4><a name="(part._chap~3alecture27)"></a><p><span style="font-weight: bold">Tuesday, 14 April 2020</span></p><h4><a name="(part._.Message_in_a_.Bottle)"></a>Message in a Bottle</h4><p>A software developer is like the guy who walks on the beach, finds a a
bottle, barely deciphers the messages inside, adds a few words, and throws
it back in the ocean.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="message-in-a-bottle.png" alt="" width="233" height="174"/></a></p></blockquote><h4><a name="(part._.The_.Web_.Developers_vs_.Church_and_.Turing)"></a>The Web Developers vs Church and Turing</h4><p>Every developer knows that different programming languages play different
roles. Java runs the back-end of the stack. JavaScript is for the
front-end. Python makes machine learning people happy. Data scientists vote
for R. Ruby (on Rails) had its day in the sun.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="web-stack.png" alt="" width="279" height="146"/></a></p></blockquote><p>When pressed though, ninety-nine percent of computer scientists and those
trained in computer science will tell you that all programming languages
are equal. All &ldquo;Turing complete&rdquo;<span class="refelem"><span class="refcolumn"><span class="refcontent">In principle, there is no
such thing as &ldquo;Turing complete&rdquo; though we have all used these term for a
long time. There is NP-complete, which is a well-defined term, and PL
borrowed this phrase.</span></span></span> programming languages have the same &ldquo;power,&rdquo;
meaning you can write only a certain class of programs in them.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="church-turing.png" alt="" width="202" height="202"/></a></p></blockquote><p>How can we reconcile these two takes on programming languages?</p><p>Let&rsquo;s start by stating the Church-Turing hypothesis.</p><h4><a name="(part._.The_.Church-.Turing_.Hypothesis_vs_the_.Web_.Stack)"></a>The Church-Turing Hypothesis vs the Web Stack</h4><p>Goedel visited Church in Princeton after publishing his famous theorem that
logic can&rsquo;t prove all truths about arithmetic and beyond, not even in the
small and seemingly simple area of formal statements.  For his proof,
Goedel had constructed what we would now call a programming language;
imagine BSL without structures. Goedel stayed on at the IAS.</p><p>Church responded with an investigation of the nature of pure functions and thus
invented the &#955; calculus&#8212;<wbr></wbr>a calculus of just functions. He and his students
then proceeded to see what you could compute with this calculus. They showed,
for example, that Curry&rsquo;s system of combinators (<span style="font-weight: bold">S</span> ad <span style="font-weight: bold">K</span>) was
equivalent to the &#955; calculus and could even prove the same equations (if we
added a set of axioms dubbed A axioms).</p><p>Turing obtained his PhD at Princeton under Church&rsquo;s direction in the mid
1930s and got to know Church&rsquo;s students and the &#955; calculus. He had come
there after having demonstrated the undecidability of the
<a href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entschedidungsproblem</a> but having been pre-empted by Church&rsquo;s
publication of the same result. Lobbying by his advisors allowed him to
publish this result eventually with an appendix that proved the equivalence
of his eponymous machines. And this gave rise to the famous hypothesis:
<span class="refelem"><span class="refcolumn"><span class="refcontent">These days Turing gets a lot more credit than Church or
Goedel because his life fits much better into the Hollywood scheme of
modern politics but all three people had to figure it out jointly&#8212;<wbr></wbr>and that
is common in science.</span></span></span></p><blockquote><p>A programming language can&#8212;<wbr></wbr>at most&#8212;<wbr></wbr>compute the
partial recursive functions on the natural numbers.</p></blockquote><p>If a programming languages <span class="emph">does</span> compute all partial recursive functions,
people nowadays speak of &ldquo;Turing complete&rdquo; programming languages, because
Turing&rsquo;s machines were most clearly distinct from an ordinary notion of
mathematical function and yet equivalent to this set of functions.</p><p>Ideas like these, and even the extended variant of the thesis, became the
central point of theory of computation. The field is still related to theory of
programming languages and complexity theory.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="thesis.png" alt="" width="265" height="153"/></a></p></blockquote><p>So there you have it, no matter how you design your programming language,
it cannot &ldquo;do more&rdquo; than the next guy&rsquo;s language in this absolute sense.
People tried for several decades to invalidate the hypothesis. Soon after
Turing&rsquo;s paper, Post developed a model of computation that worked with just
strings but had to admit that it was equivalent to the &#955; calculus and
Turing&rsquo;s machine. Even as late as the 1960&rsquo;s Smullyan (&ldquo;What&rsquo;s the Name of
this Book&rdquo;) tried to prove Church and Turing wrong. People now accept the
hypothesis for classical computation; quantum computation is a different
story.</p><p>At this point in the course, it is easy for you to understand the strategy
behind these equivalence proofs.  If you have a new computational model aka
programming language, you build a simulator for an existing one that is
equivalent to Turing machines, and then you pick a convenient second model in
which you build a simulator for your new language. If you have an algorithmic
inclination, you also show that these simulations have at most a polynomial
overhead.</p><p>Notice the words &ldquo;simulate&rdquo; and &ldquo;convenient&rdquo; in the preceding
paragraph. Even theoreticians acknowledge that something is going on that isn&rsquo;t
right for developers.</p><p>And really, how does this (hypo)thesis help the working software developer anyways?</p><h4><a name="(part._.This_is_.Useless)"></a>This is Useless</h4><p>Working developers&#8212;<wbr></wbr>including you in the not-too-distant-future&#8212;<wbr></wbr>recognize
that this idea is useless. And people even have a name for this insight: the
<span style="font-style: italic">Turing tar pit</span>.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="useless.png" alt="" width="270" height="151"/></a></p></blockquote><p><div class="SIntrapara">Here is why. On occasion:
</div><div class="SIntrapara"><ul><li><p>a programming language is the <span class="emph">first</span> on a platform and thus there&rsquo;s
no way to get around it. JavaScript is the example that you know. It became to
play this central role because even after a short few years of the web&rsquo;s
existence the developers of browsers had an equally powerful insight:
&ldquo;whatever you do, don&rsquo;t break the web.&rdquo; What this meant was that JavaScript&rsquo;s
role was cemented in history&#8212;<wbr></wbr>no matter its pluses and minuses. To the credit
of the JavaScript standardization body, the language has vastly improved over
the years since.</p></li><li><p>a programming language becomes <span class="emph">the only socially acceptable</span>
artifact to work with&#8212;<wbr></wbr>like social, cultural, and political ideas. It is
simply &ldquo;impolite&rdquo; to propose the use of Racket for a new project&#8212;<wbr></wbr>simply it
has too many parentheses.</p></li><li><p>a programming language has developed &ldquo;appeal&rdquo; due to surface attributes
or library developments that sway a large community that is the way to go&#8212;<wbr></wbr>no
matter the qualities of the actual language. R is one example, Python another.</p></li></ul></div><div class="SIntrapara">When pressed, however, no objector to the Church-Turing Hypothesis can provide
a technical argument. The platform argument is the closest they come. Even
worse, the attempts at technical arguments tend to deteriorate to variants of
the everything-is-a-Turing-machine proofs&#8212;<wbr></wbr>and thus end up in the Turin
tar pit.</div></p><p>Comparing programming languages at the technical level remains an incredibly
contentious idea. It remains subject to sociological, psychological, and
cultural factors to this day.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">If this relatinship to teaching is of interest to you, consider
looking at <a href="https://felleisen.org/matthias/OnHtDP/turing_is_useless.html">Turing is Useless</a>.</span></span></span></p><p><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Side Note</span>

Sadly this gap in our area affects computer science education at a deep
level. Most instructors of programming courses turn the Church-Turing
Hypothesis into the phrase &ldquo;the language doesn&rsquo;t matter&rdquo; with the hidden
goal of teaching their psychologically preferred candidate instead.</p></td><td><p> . </p></td></tr><tr><td><p><span class="stt"></span></p></td><td><p> . </p></td></tr><tr><td colspan="2"><p> Yours truly initially taught Racket (technically, its predecessor)
for this reason. I realized after only a couple of years in 1995 that Racket
was as bad as any other language for introducing students to programming. In
response my team and I developed the teaching languages, based on Racket but
substantially smaller syntactically and simpler semantically.</p></td></tr><tr><td><p><span class="stt"></span></p></td><td><p> . </p></td></tr><tr><td colspan="2"><p> The second effect is to argue that it suffices to teach the dominant
syntax and to have students learn by experimenting with variations on the
syntax theme.  After all, all languages have more or less the same kinds of
declarations, the same control constructs, similar kinds of functions or
methods, and so on. This syntactic view completely fails to understand that the
organization of the program itself is critical because after code has been
deployed, developers will have to read this code over and over and over
again. </p></td></tr><tr><td><p><span class="stt"></span></p></td><td><p> . </p></td></tr><tr><td colspan="2"><p> Fundamentals I therefore teaches about the design space and the process
of designing code systematically. Not applying this idea will be your loss and
the loss of your (future) colleagues.</p></td></tr></table></p><h4><a name="(part._.On_the_.Expressive_.Power_of_.Programming_.Languages)"></a>On the Expressive Power of Programming Languages</h4><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>I was inspired by Landin&rsquo;s informal writings about the
landscape of programming languages and his identification of syntactic
sugar. Sadly, a lot of people these days use the words &ldquo;syntactic
sugar&rdquo; and have no clue where they come from (Landin, the 1960s) and what they
mean. Buyer beware.</p></blockquote></blockquote></blockquote><p><div class="SIntrapara">Many years ago, <a href="https://www2.ccs.neu.edu/racket/pubs/#scp91-felleisen">I studied a simplification of this problem</a>:
</div><div class="SIntrapara"><blockquote><p>Suppose two languages differ only in one linguistic
construct. When do we say that this construct adds expressive power? Or is
just &ldquo;syntactic sugar&rdquo;?</p></blockquote></div><div class="SIntrapara">I have used the term linguistic construct throughout the semester. It really
just refers to a single concept: assignment statements for variables (<span class="stt">=</span>),
<span class="stt">grab</span> in <a href="9.html#%28tech._toy%29" class="techoutside" data-pltdoc="x"><span class="techinside">Toy</span></a> or generators &#225; la Python, call-by-value functions vs
call-by-name functions, and so on. It does <span class="emph">not</span> mean a cross-cutting
language attributes such as <span class="emph">lexical</span> scope or <span class="emph">memory-managed</span>
allocation.<span class="refelem"><span class="refcolumn"><span class="refcontent">As Strunk and White say, people should avoid the word
&ldquo;feature.&rdquo;</span></span></span></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_68.png" alt="image" width="578.0" height="446.00000000000006"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atranslations))" x-target-lift="Figure"></a>Figure&nbsp;105: </span>The Space of Mappings From One Language to Another</span></p></blockquote><p>Let&rsquo;s start by looking back at the Church-Turing thesis and its proof
strategies. The word &ldquo;simulate&rdquo; roughly means a mix of transpilation or
compilation from one language to another followed by an interpretation.
Think of a simulation as mathematical functions like the <span class="RktSym">cps</span>
translation of <a href="lecture17.html" data-pltdoc="x">17 &#8212;<wbr></wbr> CPS</a>.  As long as the translated program computes
the same results as the original one&#8212;<wbr></wbr>for all programs&#8212;<wbr></wbr>the translation can
be used for a proof. But not all translations are equal.</p><p><div class="SIntrapara"><a href="#%28counter._%28figure._fig~3atranslations%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">105</span></a> adjust this idea to a particular instance of the
narrow problem stated above:
</div><div class="SIntrapara"><ul><li><p>The <span style="color: navy">navy narrows</span> represents simulations that
can do anything to the given program. For example, it could encode the entire
program as a number and then use an interpreter to &ldquo;run&rdquo; this program.</p><p>A <span class="RktSym">cps</span> translation is such a simulation proper. It changes the
function-call protocol for every single function in the entire program.
As a result, it is even necessary to supply the rewritten program with a
continuation.</p></li><li><p>By contrast, the <span style="color: purple">purple narrows</span>
represents simulations that must translate all language constructs to the same
construct&#8212;<wbr></wbr>except for the one that we are trying to simulate.</p><p>In the example of <a href="#%28counter._%28figure._fig~3atranslations%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">105</span></a> <span class="stt">"grab"</span> would be the
construct that a translation can change in any way possible but only it. All
others must stay in place. Changing the function-call protocol is <span class="emph">not</span>
permitted under this rule.</p></li><li><p>And besides simulations proper and homomorphisms there are <span style="color: orange">orange translations</span> that might have interesting properties.</p></li></ul></div><div class="SIntrapara">In short, computational theoretician permit the use of any means to get the
desired proof. My proposal is to admit only <span style="color: purple">purple homomorphisms up to</span>.</div></p><p>Why?</p><p>Developers never have control of the entire program. They typically control a
module or two. But, if they really need <span class="RktSym">cps</span> to implement <span class="stt">"grab"</span>,
they must ask <span class="emph">all</span> their colleagues to change their functions and
function calls. I do not think we want to say that <a href="9.html#%28tech._toy%29" class="techoutside" data-pltdoc="x"><span class="techinside">Toy</span></a> is just as
&ldquo;convenient&rdquo; for control problems as <a href="9.html#%28tech._toy%29" class="techoutside" data-pltdoc="x"><span class="techinside">Toy</span></a> with <span class="stt">"grab"</span> just because
<span class="RktSym">cps</span> can eliminate <span class="stt">"grab"</span> with this whole-program transformation
recipe. And I do call this idea &ldquo;macro expressiveness&rdquo; because macros as
presented in <a href="lecture26.html" data-pltdoc="x">26 &#8212;<wbr></wbr> Q &amp; A</a> are roughly like homomorphisms-upto.</p><p>You might wonder how to prove that <span class="emph">no</span> homomorphism translation can
eliminate <span class="stt">"grab"</span>. Sadly the general technique I developed is beyond an
undergraduate course on programming languages. If you&rsquo;re interested, try to
study the paper and ask when you get stuck.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Haskell is a purely functional language;  JavaScript, OCaml, and
Racket are considered functional but not pure.</p></blockquote></blockquote></blockquote><p>So what kind of expressiveness results do we have so far? A purely functional
language can neither express assignment statements nor continuation grabbing.
A use of store-passing, continuation-passing etc makes these language
inherently imperative, just like all others&#8212;<wbr></wbr>even if they call them monads. A
proper call-by-value language cannot express call-by-name and vice
versa. <a href="11.html#%28tech._while%29" class="techoutside" data-pltdoc="x"><span class="techinside">While</span></a> and <a href="9.html#%28tech._toy%29" class="techoutside" data-pltdoc="x"><span class="techinside">Toy</span></a> cannot express type predicates such as
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/number-types.html#%28def._%28%28quote._~23~25kernel%29._number~3f%29%29" class="RktValLink" data-pltdoc="x">number?</a></span>, <span class="RktSym"><a href="http://docs.racket-lang.org/reference/objectutils.html#%28def._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._is-a~3f%29%29" class="RktValLink" data-pltdoc="x">is-a?</a></span>, or <span class="RktSym">instance-of?</span>. Although these
results are not surprising per se, the idea that we can state them rigorously
and in a way that makes sense to developers is meaningful.</p><p>The problem with my technique is that it is rather sensitive to the syntactic
nature of the construct we wish to consider. This criticism is fair, and people
run into time and again when they use my approach. In the meantime, we&rsquo;re still
waiting for an improvement on my idea or a generalization.</p><p><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Side Note</span>

Leivant has proposed an alternative way of classifying languages. He draws on
complexity theory starting with the observation that if a computation takes
hundreds of years we might as well consider it an infinite loop.  This idea can
then be used to classify different dialects of typed &#955; calculus to distinguish
their power. </p></td><td><p> . </p></td></tr><tr><td><p><span class="stt"></span></p></td><td><p> . </p></td></tr><tr><td><p>This comparison system can distinguish programming
languages in ways that macro expressibility cannot. But, it relies on rather
esoteric approaches to types and deep knowledge of complexity and recursion
theory. I conjecture that these classifications are probably not relevant for
working programmers.</p></td><td><p> . </p></td></tr></table></p><h4><a name="(part._.The_.End)"></a>The End</h4><p>Remember the guy at the beach? How can a rock-solid understanding of
programming languages help this guy?</p><p>To this day, working software developers will consider their programming
language and their preferred IDE primary tools of the trade. There are a
few others, mostly skills, and you must develop them during your time here
and even more so once you graduate.</p><p>Here are a number of things you might get out of this course. In the spirit
of &ldquo;programming is a people discipline,&rdquo; let&rsquo;s start with conversations
about programming languages and then move on to technical concepts.</p><p><span style="font-weight: bold">Conversations about programming languages</span> When you discuss
programming languages, their pluses and minuses, above all keep in mind
that not only technical but cultural, social, and psychological factors
deeply affect these discussions.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Kahneman&rsquo;s &ldquo;Thinking Fast and Slow&rdquo; explains this idea
really well.</span></span></span>
To address the <span class="emph">cultural</span>, <span class="emph">social</span>, and <span class="emph">psychological</span>,
you will have to develop, practice, and use personal communication
skills. And even then, it will always be difficult to overcome people&rsquo;s
prejudices.</p><p><div class="SIntrapara">To address <span class="emph">technical</span> points, you need to settle on a common language
to discuss ideas:
</div><div class="SIntrapara"><ul><li><p>Pay attention to <span class="emph">terminology</span>. To this day, confused ideas
dating back decades permeate the way people speak about language concepts.</p><p><span style="font-style: italic">Example</span> People insist on speaking of &ldquo;references&rdquo; and then of
&ldquo;by reference&rdquo; when they discuss mutable compound <span class="emph">values</span> such as
structs, dictionaries or arrays. They cannot separate implementation (a
reference to the heap) from the concept (value).</p></li><li><p>Find out whether your conversational partners know about <span class="emph">language
technology</span>.</p><p><span style="font-style: italic">Example</span> You are likely to have built an interpreter in
Fundamentals I or at least have attended a lecture on this topic.  Many CS
graduates never see an interpreter or compiler during their entire
education.</p></li><li><p>Stick to the same <span class="emph">conceptual level</span> and, when you must switch,
be explicit about it.</p><p><span class="emph">Example</span> While the word &ldquo;scope&rdquo; is a syntactic concept,
&ldquo;substitution&rdquo; (an operation on syntax) or &ldquo;environment&rdquo; explain it
operationally. Switching back and forth may lead to apples-to-orange
comparisons.</p></li></ul></div><div class="SIntrapara">When you have developed a common ontology, you can converse effectively.</div></p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="conversation.png" alt="" width="360" height="360"/></a></p></blockquote><p><span style="font-weight: bold">Concepts and their Meaning</span> This course covers the principles of
<span class="emph">sequential</span> programming languages and touches on some current
event-based concurrency.</p><p><div class="SIntrapara">Expressiveness theory suggests that we think of the dominant dimensions of
this design space as follows:
</div><div class="SIntrapara"><ul><li><p><span class="emph">basic algebra</span>, which includes all forms of local control
(if, basic loops)</p><p>Here <span class="emph">static scope</span> is the dominant idea, its denotation is the <span class="emph">environment</span>.</p></li><li><p>first-class and higher-order functions</p></li><li><p><span class="emph">state</span>, which includes variable assignments and mutable
objects, from the simplest one-slot object to gigabyte arrays</p><p>What we need to understand here is the <span class="emph">dynamic extent</span> of an effect,
and the <span class="emph">store</span> is its meaning.</p></li><li><p><span class="emph">control</span>, as in non-local control, which covers program exists,
loop and function exists (continue, return), exception handling,
generators, and far more general ideas.</p><p>At this point, we need to understand the notion of a <span class="emph">continuation</span> as
a separate idea that represents dynamic control flow.</p></li></ul></div><div class="SIntrapara">When you add parallelism to this mix, the last two aspects cause tremendous
complications and yet remain indispensable.</div></p><blockquote class="SCentered"><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_69.png" alt="image" width="456.0" height="366.0"/></p></blockquote><p><div class="SIntrapara">Orthogonal to these dimensions, we must think about programming languages
present themselves to developers in several layers:
</div><div class="SIntrapara"><ul><li><p><span class="emph">syntax</span>, which comprises the vocabulary of the language and its
context-free grammatical rules.</p><p>The notational aspects of syntax is a matter of personal taste, from the
particular use of certain tokens (<a href="https://en.wikipedia.org/wiki/Semicolon#Computing_usage">see separator vs terminator</a>).</p><p>The principles of syntax have not changed since the late 1960s, though, and
syntax is thus not a technical topic worthy of deep coverage.  It wouldn&rsquo;t
help the guy on the beach.</p></li><li><p><span class="emph">static properties</span>, that is, relationships among distinct
and physically disjoint pieces of syntax that can be validated
<span class="emph">without running the program</span> or <span class="emph">determining its complete
meaning</span>.</p><p>Static properties range from the very simple&#8212;<wbr></wbr>replacing a variable with a
static distance coordinate&#8212;<wbr></wbr>to the complex&#8212;<wbr></wbr>-checking the validity of
type declarations and implied claims about the program.</p><p>People occasionally use the phrase &ldquo;context-sensitive&rdquo; here.</p></li><li><p><span class="emph">semantics</span>, which refers to the actual meaning of grammatically
correct and possibly statically validated programs.</p><p>Meaning is what messages are to convey. It&rsquo;s the most central
idea. Many language researchers consider it a &ldquo;conquered problem,&rdquo;
except that every time we wish to apply it to a new application area,
we&rsquo;re stuck.</p></li><li><table cellspacing="0" cellpadding="0" class="boxed" style="display: inline-table; vertical-align: text-top; margin-top: 0;; border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>syntactic terms</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>static reasoning</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>semantic terms</p></td></tr><tr><td valign="bottom"><p>variable</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>static distance coordinate</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>environment</p></td></tr><tr><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>store, location</p></td></tr><tr><td valign="bottom"><p>expression</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>value</p></td></tr><tr><td valign="bottom"><p>statement</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>effect</p></td></tr><tr><td valign="bottom"><p>declaration</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>visible region</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>environment</p></td></tr><tr><td valign="bottom"><p>type</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>type checking</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>type (un)soundness</p></td></tr><tr><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p></p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p> . </p></td></tr><tr><td valign="bottom"><p>scope</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>visible region</p></td><td valign="bottom"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="bottom"><p>environment</p></td></tr></table></li><li></li><li><p><span class="emph">performance</span>, which tells us about the cost of individual
language constructs and some compositions.</p><p>A developer must understand the performance of a construct. Accessing
a field in a structure or a slot in an array takes constant time. A
loop or a function call should not consume space on the control stack.
In both cases, the CESK machines and the corresponding homework
assignments give some insight here. This aspect is, however, best left
to a course on compilers, because going beyond individual expressions
and statements is impossible without some knowledge of how efficient
implementations function.</p><p><span style="color: red">Warning</span> People often jump from knowledge about the performance
of some basic features to general conclusions about the performance of
the entire programming language. The area of performance measurement
is yet another niche discipline within programming languages, and too
few people know a lot.</p><p><span class="emph">Example</span> Some people say Python is a naive interpreter and
therefore slow. The first part of the statement is true, but the
second part does not follow at all. Many Python libraries aren&rsquo;t thin
veneers over C libraries, and compositions of such libraries run
extremely fast. Hence certain classes of Python programs are really
some of the best you can get.</p><p>Some people claim Python programs are always fast. Such people live in
a bubble, namely, a narrow slice of Python programs that are merely
compositions of C-veneer libraries.</p><p><span style="color: red">Advice</span> Complete systems and individual modules need systematic
performance evaluations. When you discover a performance problem, try
to use performance debuggers to spot a performance bottleneck. Beware!
Such bottlenecks may just be complex data representations and
algorithms and, without fundamental changes, you might not be able to
eliminate them.</p></li></ul></div></p><p><div class="SIntrapara">Two fundamental ideas relate the expressive power of the language to
semantics:
</div><div class="SIntrapara"><ul><li><p><span class="emph">type soundness</span> The sub-language of types enables
developers to make claims about relationships within the program. The
type checker makes sure these claims are consistent.</p><p>If a type checker discovers an inconsistency&#8212;<wbr></wbr>called a type
error&#8212;<wbr></wbr>the language implementation usually does not run the program.</p><p>The new development of gradual typing relaxes this idea a bit. Many of
you may encounter this new idea in TypeScript.</p><p>If the types are also perfect predictions of what happens at run time,
we speak of a sound type system.</p><p>Some typed languages are designed to satisfy this property, e.g., Java
or Haskell. Others aren&rsquo;t, say C.</p></li><li><p><span class="emph">memory soundness</span> Every single programming language
permits the dynamic allocation of storage space. Historically,
dynamically sized arrays were the first kind of such storage space;
structures and objects are much more common in modern languages.</p><p>Using such storage space properly means retrieving values and
modifying slots within bounds.</p><p>Some languages enforce this property. No program may access
non-existent parts of a dynamically allocated memory block.
These languages are memory safe (or sound).</p><p>Other languages leave it to programmers to keep track of the size of
arrays, the number of fields in a structure, etc. These languages fail
to be sound.</p><p>Additionally, some languages support the automatic management of
storage space. When the allocator detects that the required
dynamically-sized block does not fit into the available space, it
separates the useful storage locations from those the program no
longer needs and reuses this second kind. To this end the language
generates mutators that can point to a well-defined set of useful
starter locations.</p></li></ul></div></p><h4><a name="(part._.Back_to_the_.Guy_on_the_.Beach)"></a>Back to the Guy on the Beach</h4><p>When you walk on the beach of software development and find one of
those bottles, you are unlikely to know the syntax in which its
message is written. It was fashionable years and decades ago when some
old developer wrote it. You are unlikely to like the syntax. And you
shouldn&rsquo;t care.</p><p>You must strive to understand its meaning as completely as possible.
If you develop a firm grasp on the basic concepts of programming
languages and continue to train yourself, you will have a much better
chance to decipher the message. You will appreciate the subtle
differences, you will become aware of strange corner cases, and you
will thus avoid time-consuming traps.</p><p>If you find yourself in the rare position of choosing a language, the
image of sending a message to the future will help you too.  When
developers write code, lots of design insights are in their heads and
all of them matter. But some languages make it cumbersome to express
ideas, some make it even impossible. Some languages guarantee certain
relationships between syntax and run-time behavior for <span class="emph">all</span>
programs; others don&rsquo;t. As a result, developers don&rsquo;t write down some
of their design ideas or write them down as comments, which we know
will soon be out of date. And the future developer is then forced to
spend a lot of time reconstructing them. Again, developing an
appreciation of the programming language landscape will help a lot.</p><blockquote class="SCentered"><p><a href="https://youtu.be/MbXWrmQW-OE"><img src="throwing-the-message-back.png" alt="" width="270" height="270"/></a></p></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture26.html" title="backward to &quot;26 --- Q &amp; A&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture28.html" title="forward to &quot;28 --- Monads&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
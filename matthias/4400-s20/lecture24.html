<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>24 --- Memory, Safety</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Principles of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="communication.html" class="tocviewlink" data-pltdoc="x">Email, Office Hours, Etc.</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">In-<wbr></wbr>Class Reviews</a></td></tr><tr><td align="right"></td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right"></td><td><a href="assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x">1 &#8212;<wbr></wbr> Programming Languages:<span class="mywbr"> &nbsp;</span> Research and Teaching</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x">2 &#8212;<wbr></wbr> Parsing</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x">3 &#8212;<wbr></wbr> Scope, Compilation</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x">4 &#8212;<wbr></wbr> Compilers; Fun</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x">5 &#8212;<wbr></wbr> Help!</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x">6 &#8212;<wbr></wbr> Recursive Functions</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x">7 &#8212;<wbr></wbr> Errors and Ordering</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x">8 &#8212;<wbr></wbr> Assignments</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x">9 &#8212;<wbr></wbr> Store Passing</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x">10 &#8212;<wbr></wbr> <span class="emph">What</span> and <span class="emph">When</span></a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x">11 &#8212;<wbr></wbr> Types &amp; Proofs</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x">13 &#8212;<wbr></wbr> Poly Types</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x">14 &#8212;<wbr></wbr> More Types</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x">15 &#8212;<wbr></wbr> JULIA Types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x">16 &#8212;<wbr></wbr> Gradual Types</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x">17 &#8212;<wbr></wbr> CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x">18 &#8212;<wbr></wbr> ONLINE</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x">19 &#8212;<wbr></wbr> CANCELLED</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x">20 &#8212;<wbr></wbr> Control from CPS</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x">21 &#8212;<wbr></wbr> State Machines</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x">22 &#8212;<wbr></wbr> C, CC, CK</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x">23 &#8212;<wbr></wbr> CEK, CESK</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">24 &#8212;<wbr></wbr> Memory, Safety</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x">25 &#8212;<wbr></wbr> Space</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x">26 &#8212;<wbr></wbr> Expressiveness</a></td></tr><tr><td align="right"></td><td><a href="lecture27.html" class="tocviewlink" data-pltdoc="x">27 &#8212;<wbr></wbr> The Ideas</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x">28 &#8212;<wbr></wbr> Monads</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x">29 &#8212;<wbr></wbr> Grab Programming</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">24 &#8212;<wbr></wbr> Memory, Safety</a></td></tr></table></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.6.0.19</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture23.html" title="backward to &quot;23 --- CEK, CESK&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture25.html" title="forward to &quot;25 --- Space&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._lecture24)"></a>24 &#8212;<wbr></wbr> Memory, Safety</h4><a name="(part._chap~3alecture24)"></a><p><span style="font-weight: bold">Friday, 03 April 2020</span></p><p><span style="font-weight: bold">Presenters</span> (1) Alexander Takayama &amp; (2) Khalil Haji &amp; Griffin Rademacher</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="https://bluejeans.com/s/2OG@9/">BJ&rsquo;s recording</a></span></span></span></p><p>Stop! Is the CESK interpretation of <a href="lecture23.html#%28tech._expr%29" class="techoutside" data-pltdoc="x"><span class="techinside">Expr</span></a> sound? Can it produce
nonsensical results? Can it get stuck in a state that isn&rsquo;t final?</p><h4><a name="(part._.Soundness_aka__.Memory__.Safety)"></a>Soundness aka (Memory) Safety</h4><p>As spelled out, the mathematical model could be interpreted either way.
The transition table carefully spells out when a value is expected to be a plain
value, when a location, or when it doesn&rsquo;t matter.</p><p>If the set of <a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a>s is disjoint from the set of Numbers (no common
elements), then the machine gets stuck if locations are used as numbers or vice
versa.</p><p>If the set of <a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a>s is, say, the set of natural numbers, then the machine
may conflate locations and numbers when transitioning from one state to
another. The distinguishing new error state is one in which the machine attempts
to retrieve a value from a location that does not exist. Other error states
disappear, because multiplying locations, for example, is now perfectly
fine. The trade-off is a horrible one as those of you had the pleasure of
writing code in C. C++, or Objective C can witness.</p><p><div class="SIntrapara">Consider the evaluation of an expression that adds the result of an
allocation to <span class="RktVal">3</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">Or even worse, an expression that performs arithmetic on locations and then
retrieves the value in the resulting store location:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">dot</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">]</span></p></blockquote></div><div class="SIntrapara">This kind of calculation with locations may even make some sense when the
programming language spells out the layout of data structures in the
store&rsquo;s memory (say, the arrangement of array fields in sequential order
with no padding for the coefficient for an access polynomial).</div></p><p><div class="SIntrapara">And to drive home the potential problems, here is an expression that runs
just fine on our CESK machine, too:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">dot</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">It <span class="emph">multiplies</span> two locations&#8212;<wbr></wbr>hey! they might just be numbers&#8212;<wbr></wbr>and
then retrieves the value at the resulting number. Whether this number is a
valid location or not depends very much on many factors, including the
arithmetic of <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span> (small vs big nums), the size of the memory in the
store,  and so on.</div></p><p>So how does the machine behave on such expressions? Which behavior is
better?</p><p><span style="font-weight: bold">If locations are drawn from the set of numbers ...</span> In papers on
programming language research, you might see this idea expressed as follows:</p><blockquote class="SCentered"><p><a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a> &#8838; Number </p></blockquote><p><div class="SIntrapara">Let&rsquo;s see how the above expressions evaluate if <a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a> is just the set
of natural numbers. Here is the first one:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>*C</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*E</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*S</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*K</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td></tr><tr><td valign="top"><p><span class="RktVal">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span class="RktVal">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">0</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr><tr><td valign="top"><p><span class="RktVal">3</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span class="RktVal">3</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr></table></div><div class="SIntrapara">A call to <span class="RktSym">alloc</span> places the two given values into two neighboring
locations in the store&#8212;<wbr></wbr><span class="RktVal">0</span> and <span class="RktVal">1</span> because the store is
still empty&#8212;<wbr></wbr>and returns the first one. Since the CESK machine does not
distinguish locations from numbers, it adds this <span class="RktVal">0</span> to the
<span class="RktVal">3</span> and the final state represents the result <span class="RktVal">3</span>.</div></p><p>Is a location a result that a user expects?</p><p><div class="SIntrapara">The second expression exhibits the danger of seemingly legal calculations
with addresses:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>*C</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*E</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*S</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*K</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">dot</span><span class="stt"> </span><span class="RktSym">left</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>]</p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>], [<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p><span class="RktVal">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>], [<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">1</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span class="RktVal">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>], [<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">1</span>]</p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">0</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>]</p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span class="RktVal">1</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym">dot</span> <span class="RktSym">left</span>]</p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">dot</span><span class="stt"> </span><span class="RktSym">left</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr><tr><td valign="top"><p><span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr></table></div><div class="SIntrapara">The addition of <span class="RktVal">1</span> to the location happens to yield the location of
the second value places in the store, and the CESK machine retrieves the
<span class="RktVal">2</span> just fine.</div></p><p>What if we had added <span class="RktVal"><span class="nobreak">-1</span></span> to the result of <span class="RktSym">alloc</span>? What if
we had added <span class="RktVal">3</span>? Which value would we get?</p><p>The model presented here is precisely what languages such as C, C++, and
Objective C implement. Many Python libraries are actually just thin veneers
over such C code, which makes some of them blazingly fast&#8212;<wbr></wbr>but also makes
the language basically unsafe.</p><p>When locations are numbers, we speak of a language that lacks memory safety
because it can access any location, whether it is meaningful or not.</p><p>Stop! Run the location-multiplication expression on your CESK machine? What
does it yield?</p><p><span style="font-weight: bold">If locations are distinguishable from numbers ...</span> Now suppose
<a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a> and the set values do <span class="emph">not</span> overlap:</p><blockquote class="SCentered"><p><a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a> &#8745; Number = &#8709; </p></blockquote><p><div class="SIntrapara">Here we specifically imagine that <a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a> are bold-faced natural
numbers, which are not the same as pale-faced ones. In this case the CESK
machine can distinguish the two kind of values and, as specified, runs into
a stuck state:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>*C</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*E</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*S</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>*K</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td></tr><tr><td valign="top"><p><span style="font-weight: bold">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>pop</p></td></tr><tr><td valign="top"><p><span style="font-weight: bold">0</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p>[<span style="font-weight: bold">L</span> &#8709; <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> <span class="RktVal">3</span>]</p></td></tr><tr><td valign="top"><p><span class="RktPn">(</span><span style="font-weight: bold">0</span><span class="stt"> </span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p>&#8709;</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span class="RktVal">0</span> &#8614; <span class="RktVal">1</span>, <span class="RktVal">1</span> &#8614; <span class="RktVal">2</span></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top" colspan="3"><p></p></td></tr></table></div><div class="SIntrapara">The tabular specification implies the existence of a FAILED state, so the
machine transitions there and stops.</div></p><p>If a language handles <a href="lecture23.html#%28tech._loc%29" class="techoutside" data-pltdoc="x"><span class="techinside">Loc</span></a>s in this manner, it satisfies the property
known as memory safety.</p><p><span style="font-weight: bold">Tagged Integer</span> In the world of real stores and even abstract
machines, natural numbers do not come in bold face. In an implementation
we tag the integer. At the hardware level this corresponds to reserving a
bit (or more) per word whose setting tells the &ldquo;reader&rdquo; whether it is a
location&#8212;<wbr></wbr>called <span style="font-style: italic">pointer</span> at this level&#8212;<wbr></wbr>or a number. Many
implementations use several bits for tagging to distinguish several kinds
of values (array values, locations, etc). In a software implementation, we
may wrap natural numbers in structures, e.g., <span class="RktPn">(</span><span class="RktSym">location</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span>, to
indicate that it is a &ldquo;bold&rdquo; or a &ldquo;tagged integer.&rdquo; In mathematical
papers, such a tag or wrapper is left implicit except for papers that dig
into the underlying set theory.</p><p><div class="SIntrapara"><span style="font-weight: bold">Note</span> If you now revisit the Type Soundness theorem from
<a href="lecture12.html" data-pltdoc="x">12 &#8212;<wbr></wbr> The Truth</a>, you see that the outcomes of evaluating programs in an
<span class="emph">untyped</span> language with safe guards against meaningless access to the
store are completely analogous to those of a typed language:
</div><div class="SIntrapara"><ul><li><p>the program either returns a properly computed value</p></li><li><p>or it runs forever</p></li><li><p>or it stops with a well-known exception if the basic &ldquo;arithmetic&rdquo;
calculations go wrong.</p></li></ul></div><div class="SIntrapara">It is thus justified to speak of <span class="emph">soundness</span> in these cases, too.</div></p><h4><a name="(part._.There_are_more_.Control_.Codes_than_.Expressions)"></a>There are more Control Codes than Expressions</h4><p>The trace above reveals something else: locations can become a part of the
control code.</p><p>First, this kind of property distinguishes the CESK machine from a virtual
machine or a hardware machine.</p><p>Second, this property is somewhat of an artifact of executing instructions
directly in the <span class="stt">*C</span> register instead of a dedicated, separate part of
the machine.</p><blockquote><p>Alternatively, this could be avoided with a
separate set of &ldquo;pop&rdquo; instructions or with an arrangement where only
variable definitions allocate storage and place the location into the
environment.</p></blockquote><p>Third, as a consequence, locations can show up only in the control code
register as the immediate operands of a control code, so they are easy to
find.</p><h4><a name="(part._.Memory_.Layout)"></a>Memory Layout</h4><p>All programs in our small language terminate, and we know exactly how many
store locations it allocates: twice the number of <span class="RktSym">alloc</span>
expressions. Nevertheless it can create rather complex memory
configurations. With this language a program can directly reach and
change every location. The even-numbered locations always represent the
left part of a pair; the odd-numbered locations contain the right part.</p><p><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">The list of colors used is blue, orange, red, purple, pink. If you have
difficulties reading these colored texts, please send email with concrete
suggestions for an alternative color list.</span></span></span>
Consider this expression:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span style="color: blue"><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">_</span><span class="hspace">&nbsp;</span><span style="color: orange"><span class="RktPn">(</span><span class="RktSym">y</span><span class="stt"> </span><span class="RktSym">set-left</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span style="color: red"><span class="RktPn">(</span><span class="RktVal">3</span><span class="stt"> </span><span class="RktSym">alloc</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span style="color: purple"><span class="RktPn">(</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">set-right</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>4<span style="font-style: italic"></span></span><span style="font-style: italic"></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">decl</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">_</span><span class="hspace">&nbsp;</span><span style="color: pink"><span class="RktPn">(</span><span class="RktSym">y</span><span class="stt"> </span><span class="RktSym">set-right</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic"></span>5<span style="font-style: italic"></span></span><span style="font-style: italic"></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">[</span><span class="RktVal">[</span><span class="RktVal">[</span><span class="RktVal">z</span><span class="hspace">&nbsp;</span><span class="RktVal">dot</span><span class="hspace">&nbsp;</span><span class="RktVal">right</span><span class="RktVal">]</span><span class="hspace">&nbsp;</span><span class="RktVal">dot</span><span class="hspace">&nbsp;</span><span class="RktVal">right</span><span class="RktVal">]</span><span class="hspace">&nbsp;</span><span class="RktVal">dot</span><span class="hspace">&nbsp;</span><span class="RktVal">right</span><span class="RktVal">]</span><span class="RktPn">]</span></td></tr></table></div><div class="SIntrapara">The two <span class="RktSym">alloc</span> expressions clearly demand the use of four
locations. The <span class="RktSym">set-left</span> and <span class="RktSym">dot</span><span class="stt"> </span><span class="RktSym">right</span> expressions
create whimsical connections among these locations. The (green) &ldquo;pair
arithmetic&rdquo; chases from <span class="RktVal">'</span><span class="RktVal">z</span> (which is clearly <span class="RktVal">'</span><span class="RktVal">x</span>)
&ldquo;to the right&rdquo; three times even though the <span class="RktSym">x</span> consists of only
two values.</div></p><p><div class="SIntrapara">Here are the different stores that this program creates during its life time:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>time</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>store at t</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p></p></td></tr><tr><td valign="top"><p>t = 1</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_42.png" alt="image" width="107.0" height="81.0"/></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="color: blue">allocate the pair [1,2]</span></p></td></tr><tr><td valign="top"><p>t = 2</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_43.png" alt="image" width="107.0" height="81.0"/></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="color: orange">set the left part of the first pair to itself</span></p></td></tr><tr><td valign="top"><p>t = 3</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_44.png" alt="image" width="209.0" height="81.0"/></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="color: red">allocate a second pair, [3,4]</span></p></td></tr><tr><td valign="top"><p>t = 4</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_45.png" alt="image" width="209.0" height="81.0"/></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="color: purple">set this second pair's right part to itself</span></p></td></tr><tr><td valign="top"><p>t = 5</p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_46.png" alt="image" width="209.0" height="81.0"/></p></td><td valign="top"><p><span class="hspace">&nbsp;&nbsp;&nbsp;</span></p></td><td valign="top"><p><span style="color: pink">set the first pair's right part to the second pair</span></p></td></tr></table></div><div class="SIntrapara">The small red numbers are the locations, the black numbers are the
content. If the content is a location <span style="font-style: italic">l</span>, an arrow points from the
center top of the box to the center top of <span style="font-style: italic">l</span>; if there is no arrow,
the black number is an integer value. While the environment only ever
contains even-numbered locations (why?), the arrows at the bottom of the
store indicate that a program can reach every odd-numbered location from
its neighbor to the left.</div></p><p><div class="SIntrapara">Let&rsquo;s generalize from this example to insights about the store. What this
example demonstrates is that the store evolves into a graph with all kinds
of connections:
</div><div class="SIntrapara"><ul><li><p>a location can point to itself; see location <span style="color: red">0</span></p></li><li><p>an even-numbered location such as <span style="color: red">0</span> implicitly points to its neighbor</p></li><li><p>two locations can point to the same one; see <span style="color: red">2</span>, reachable from
<span style="color: red">1</span> and <span style="color: red">3</span></p></li><li><p>chasing arrows can directly and indirectly get us into a &ldquo;loop;&rdquo;</p><p>with <span class="RktVal">'</span><span class="RktVal">z</span> and <span class="RktVal">'</span><span class="RktVal">x</span> pointing to <span style="color: red">2</span>, you can now see why
the three steps in the above program on a single pair succeed just fine;</p><p>see the chain of arrows starting at <span style="color: red">0</span>, which implicitly goes from
there to <span style="color: red">1</span>, explicitly to <span style="color: red">2</span>, implicitly to <span style="color: red">3</span>, and
explicitly back to <span style="color: red">2</span></p></li><li><p>but, some locations are <span class="emph">not</span> reachable from the other registers
of the machine;</p><p>see location <span style="color: red">0</span>, which is assigned to the variable <span class="RktVal">'</span><span class="RktVal">y</span> which
gets eliminated from the environment (together with <span class="RktVal">'</span><span class="RktVal">x</span>) when the
inner nests of <span class="RktSym">decl</span> return the value of <span class="RktVal">'</span><span class="RktVal">x</span> and assigns
it to <span class="RktVal">'</span><span class="RktVal">z</span></p></li></ul></div><div class="SIntrapara">And this brings us to the next topic, managing memory.</div></p><h4><a name="(part._.Memory_.Management)"></a>Memory Management</h4><p>When a programming language supplies a primitive such as <span class="RktVal">'</span><span class="RktVal">alloc</span>,
developers are guaranteed to write code that sooner or later exhausts a
computer&rsquo;s memory capacity, because contrary to all rumors, even several
gigabytes aren&rsquo;t enough.</p><p>The language implementation combines the generated code with a runtime
system; until now, we thought of this system as the prelude that defines
all primitives. But there&rsquo;s more to a runtime system, and this is the last
major critical topic of this course.</p><p>How does your code get memory? It is the job of the operating system to
manage scarce resources: network access, connections to a monitor,
printing, time, and memory. With time, we mean CPU; there&rsquo;s just a few but
on the average a computer runs many more programs than that. So the OS
allows every program to run every so often for a limited amount of time on
(some of) the CPU(s).</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">Some people have predicted for a decade or two that the
operating system will also provide a memory management service, like the
one we&rsquo;re discussing this week, to every running program. It hasn&rsquo;t
happened yet. What has happened is the emergence of two major runtime
system as <span class="emph">platforms</span>: the JVM and the .NET system. All language
implementations that target these platforms automatically benefit from the
built-in garbage collector.</span></span></span></p><p>The operating system also reserves a certain amount of memory for every
program. It is up to the program and the linked-in runtime system to manage
this space.</p><p>So what does a runtime system do when your program has <span class="RktVal">'</span><span class="RktVal">alloc</span>ed
all the space? When it has exhausted the store? It figures out what parts of
the allocated memory are garbage.</p><p><span style="font-weight: bold">The Truth</span> <span style="font-style: italic">Garbage</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">T</span></span><span style="font-style: italic"></span> is any location that, when made
inaccessible for the rest of a program evaluation, has no impact whatsoever
on the visible behavior of the program.</p><p>As always, the truth isn&rsquo;t decidable, which makes computer science and
especially programming languages an interesting subject. Decidable means
that there is no algorithm that consumes the state of a CESK machine and a
location and produces a Boolean (with <span class="RktVal">#true</span> meaning the given
location is garbage<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">T</span></span><span style="font-style: italic"></span> and <span class="RktVal">#false</span> meaning it is not).</p><p><span style="font-weight: bold">The Proof</span> <span style="font-style: italic">Garbage</span><span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">P</span></span><span style="font-style: italic"></span> is a location that, given the contents
of the registers of a CESK machine, can be <span class="emph">proven</span> (by some
algorithm) not to have any impact on the rest of the evaluation.</p><p><span style="font-weight: bold">The Key</span> Garbage<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">P</span></span><span style="font-style: italic"></span> can be reclaimed and used again for other
purposes.</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The idea of garbage collection is due to the MIT Lisp team in
the mid 1960s. Edwards implemented the first known garbage collector.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">As with many ideas in programming languages, the history of garbage
collection dates back many decades and, again, to the Lisp family of
programming languages. Over this time researchers have expanded this idea
to an area that is large enough to fill several courses. So here are some
ideas you will encounter when people discuss garbage collection:
</div><div class="SIntrapara"><ul><li><p><span style="font-style: italic">free</span> ~~ Old programming languages, such as C, C++,
Objective C and some more, provide a <span class="RktSym">free</span> function. A developer
uses this function to tell the memory management system that a specific
location is available for re-use. It is the responsibility of the developer
to make sure that the program no longer needs access to the current value
in this location. If the developer is wrong, we speak of a
<span style="font-style: italic">dangling pointer</span> problem.</p></li><li><p><span style="font-style: italic">reference counting</span> ~~ For the longest time, Python used a
schema known as reference counting. Every location <span style="font-style: italic">l</span> comes with a
&ldquo;partner&rdquo; location that contains the number of times <span style="font-style: italic">l</span> is
referenced in the program. When this counter is <span class="RktVal">0</span>, the memory
management system may recycle the two locations.</p><p>Besides the cost and complexity of maintaining thus counter, it is also
difficult to account for cycles in the memory graph. While some languages
still use this old-fashioned scheme, most of those also support a garbage
collection algorithm.</p></li><li><p><span style="font-style: italic">tracing garbage collection</span> ~~ The most common algorithm in
use starts from the (equivalent of the) E and K registers, follows the
implicit and explicit arrows to all reachable locations, and recycles the
others as garbage. We will study this algorithm in the next lecture.</p></li><li><p><span style="font-style: italic">conservative garbage collection</span> ~~ <span class="refelem"><span class="refcolumn"><span class="refcontent">Due to
Boehm, a colleague of mine at Rice.</span></span></span> The preceding description assumes that
the algorithm can distinguish between integers (natural numbers) and
locations and that it is possible to find all roots (source) locations in E
and K. If the programming language design does not allow to make these
distinctions, we speak of a <span style="font-style: italic">non-cooperative</span> <span class="refelem"><span class="refcolumn"><span class="refcontent">I
prefer &ldquo;hostile&rdquo; and told Boehm at the time.</span></span></span> language. The idea of a
conservative collector is to make, well, conservative guesses at what could
be a location as opposed to a number and not recycle it. Furthermore,
unlike tracing compilers which move &ldquo;live&rdquo; data from one place to another
to reclaim garbage<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">P</span></span><span style="font-style: italic"></span> memory, a conservative collector leaves it in
place.</p><p><span style="font-weight: bold">Note</span> The word &ldquo;conservative&rdquo; is bogus but established
terminology. Every garbage collector algorithm is conservative with respect
to garbage<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">T</span></span><span style="font-style: italic"></span>. And usually the word &ldquo;conservative&rdquo; is used when we speak
of proof vs truth&#8212;<wbr></wbr>for example when we discuss the foundations of type
systems or static analysis algorithms in compilers. But alas, the word has
taken hold.</p><p>If you are forced to program in C-like languages, consider the use of the
Boehm conservative collector.</p></li><li><p><span style="font-style: italic">generational garbage collection</span> ~~ Most people
<span class="emph">believe</span> <span class="refelem"><span class="refcolumn"><span class="refcontent">I use this word with its religious connotation
only, not in the loose sense of &ldquo;conjecture.&rdquo;</span></span></span> that allocated memory
&ldquo;dies young.&rdquo; That is, locations that have been in use for a long time
will remain in use, and recently allocated locations are more likely to be
reclaimed.</p><p>Modern garbage collectors accommodate this idea with
<span style="font-style: italic">generations</span>. They place survivors&#8212;<wbr></wbr>locations in long time
use&#8212;<wbr></wbr>into one region of allocated memory and recently allocated locations
in a <span style="font-style: italic">nursery</span>, and this nursery is inspected for garbage more
frequently than the region for survivors. When a location has lived for a
certain number of garbage collections in the nursery, it is moved to the
&ldquo;old people&rsquo;s home.&rdquo;</p><p>Clinger, a colleague who retired in 2019, conducted research
in garbage collection. For the past decade or so of his active life, he
tried to publish results that seriously question the &ldquo;young locations die
early&rdquo; hypothesis. He has significant evidence that it applies only in
some situations and that generational collectors may have fewer benefits
than acclaimed.</p></li><li><p><span style="font-style: italic">concurrent garbage collection</span> ~~ All of the above
algorithms assume that, when your program runs out of memory and must
allocate, we can stop the execution of the program (save all registers
somewhere), inspect the store, collect the garbage, and re-start the
program from where we stopped it. Hence they are called &ldquo;stop the world&rdquo;
garbage collectors.</p><p>In some situations we may not wish to stop the program. This is mostly true
for real-time system where a program must control physical objects (trains,
planes, ships, missiles, medical instruments) the entire time.</p><p>To accommodate such situations, researchers develop targeted virtual
machines with garbage collectors that run in parallel to the main
program. These algorithms are extremely complex and costly. They are only
now emerging for commercial use.</p><p>Prof. Vitek, while still at Purdue, worked on this problem with colleagues
at IBM and eventually founded a small company to commercialize a concurrent
garbage collector for a specialized Java Virtual Machine.</p></li><li><p>Crazy Ideas ~~ Remember that we discussed how to get back to the
program from the state of the registers with the introduction of a new
register. So, when we stop the program evaluation, we can actually
re-construct a program that corresponds to the current state of the CESK
machine&#8212;<wbr></wbr>not the source program. Then we can apply a type inference
algorithm to this reconstructed program. Every location&#8212;<wbr></wbr>represented as a
variable&#8212;<wbr></wbr>whose type is inferred to be just a type variable is garbage.</p><p>Why?</p><p>A group at NYU and another one at INRIA France pursued this direction of
research for a decade or so. In principle, this algorithm can discover more
garbage than a tracing collector. But performing a type inference algorithm
in the inner loop of a garbage collection world is costly. Nobody has so
far succeeded in making it affordable.</p></li></ul></div><div class="SIntrapara">But, remain aware, that you really know nothing about the field of garbage
collection&#8212;<wbr></wbr>other than that is truly complicated.</div></p><h4><a name="(part._.Which_.Programming_.Language_is_.Better_for_the_.Developer)"></a>Which Programming Language is Better for the Developer</h4><p>Managing locations and managing allocated memory is one of the most
critical concerns in the design of programming language runtime systems.</p><p>Until the late 1990s, languages that allowed the conflation of numbers and
locations dominated the software development landscape.</p><p>Until then, two claims dominated our world:</p><p>(1) people are better than &ldquo;computers&rdquo; (a language&rsquo;s runtime system
together with the hardware) at managing locations,</p><p>and anyways,</p><p>(2) this kind of store access is needed to make programs fast.</p><p>The first claim is complete bogus and we actually knew that. Given that a
program manages dozens, hundreds, and thousands of allocated
locations&#8212;<wbr></wbr>possibly via equally many software developers&#8212;<wbr></wbr>and given that
we have used computers for accounting tasks for 60 years, we clearly have a
contradiction on hand. People just refused to see it.</p><p>The second claim has some truth to it in extremely narrow niche application
areas. It may also hold when you have a brand-new machine and no real
language on it to develop any software with, though in the 1970s and 80s we
had hardware that could have distinguished locations from numbers.</p><p>As I have mentioned before, IBM ran a large-scale productivity experiment
comparing C++ with Java, and Java won big time. Initially people thought it
was type soundness that made Java superior to C++, but soon they realized
it was really memory safety that saved developers tons of development time.</p><p>Zorn, a researcher at Colorado around the same time, analyzed many
realistic C/C++ programs, equipped them with a garbage collector, and ran
timing comparisons. To his surprise, the variants with garbage collectors
ran much faster than those with manually managed memory. He knew he
wouldn&rsquo;t be able to get this result published&#8212;<wbr></wbr>given the dominant opinion
among computer &ldquo;scientists&rdquo; at the time&#8212;<wbr></wbr>and worked hard to eliminate
inefficiencies from the programs to narrow the gap. Even then he had a hard
time getting this result published.</p><p><span style="font-weight: bold">Lesson</span> Be skeptical of scientists and &ldquo;consensus science.&rdquo;</p><p><span style="font-weight: bold">Alternative</span> One can imagine a language that supports a separate
domain of location numbers and arithmetic on such things. One can also
imagine a language that allows programmers to state type-like claims about
the ownership of locations so that two collaborating developers can get the
&ldquo;type checker&rdquo; to validate their handling of locations.</p><p>This notion of ownership type was first conceived by Jan Vitek (a
Northeastern professor now), was further developed by Jesse Tov (a
Northeastern PhD who left when Vitek arrived), and became the foundation of
the <a href="https://www.rust-lang.org">Rust programming language</a>.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture23.html" title="backward to &quot;23 --- CEK, CESK&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture25.html" title="forward to &quot;25 --- Space&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
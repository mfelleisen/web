<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>III&nbsp;Project</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Socially Responsible <br/> Software Development</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Prelude</span></a></td></tr><tr><td align="right">I&nbsp;</td><td><a href="part_one.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Perspective</span></a></td></tr><tr><td align="right">II&nbsp;</td><td><a href="part_two.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Principles</span></a></td></tr><tr><td align="right">III&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="Smaller">Project</span></a></td></tr><tr><td align="right">IV&nbsp;</td><td><a href="part_four.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Programming Interfaces</span></a></td></tr><tr><td align="right">V&nbsp;</td><td><a href="part_five.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Programming Basics</span></a></td></tr><tr><td align="right"></td><td><a href="part_postlude.html" class="tocviewlink" data-pltdoc="x"><span class="Smaller">Postlude</span></a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>III&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="Smaller">Project</span></a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">7&nbsp;</td><td><a href="#%28part._ch~3aproject%29" class="tocviewlink" data-pltdoc="x">Running a Software Systems</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._ch~3aproject-idea%29" class="tocviewlink" data-pltdoc="x">Developing a Complete Software System</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="#%28part._ch~3asw-arch%29" class="tocviewlink" data-pltdoc="x">Software Architecture</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="#%28part._ch~3asample-project%29" class="tocviewlink" data-pltdoc="x">A Sample Project:<span class="mywbr"> &nbsp;</span> Analysis, Discovery, Planning</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="#%28part._ch~3amanaging%29" class="tocviewlink" data-pltdoc="x">Inspecting the Plan</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="#%28part._ch~3awhy-design-inspection%29" class="tocviewlink" data-pltdoc="x">Why Inspections Matter Even If There is No Code</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.14.0.4</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="part_two.html" title="backward to &quot;II Principles&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Socially Responsible  Software Development&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_four.html" title="forward to &quot;IV Programming Interfaces&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h3 class="heading">III<tt>&nbsp;</tt><a name="(part._part~3athree)"></a><span class="Smaller">Project</span><span class="button-group"><a href="#(part._part~3athree)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3aproject%29" class="toclink" data-pltdoc="x">7<span class="hspace">&nbsp;</span>Running a Software Systems</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3aproject-idea%29" class="toclink" data-pltdoc="x">8<span class="hspace">&nbsp;</span>Developing a Complete Software System</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aproject-proceed%29" class="toclink" data-pltdoc="x">8.1<span class="hspace">&nbsp;</span>Ways to Proceed</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aproject-facets%29" class="toclink" data-pltdoc="x">8.2<span class="hspace">&nbsp;</span>Analysis: Understanding the Project&rsquo;s Purpose and Context</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aidentify-components%29" class="toclink" data-pltdoc="x">8.3<span class="hspace">&nbsp;</span>Synthesis: Discovering Components</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aproject-plan%29" class="toclink" data-pltdoc="x">8.4<span class="hspace">&nbsp;</span>Planning: How the Construction Proceeds</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3asw-arch%29" class="toclink" data-pltdoc="x">9<span class="hspace">&nbsp;</span>Software Architecture</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pipelines%29" class="toclink" data-pltdoc="x">9.1<span class="hspace">&nbsp;</span>Pipelines</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Model__.View__.Controller%29" class="toclink" data-pltdoc="x">9.2<span class="hspace">&nbsp;</span>Model, View, Controller</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Client__.Server%29" class="toclink" data-pltdoc="x">9.3<span class="hspace">&nbsp;</span>Client, Server</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3asample-project%29" class="toclink" data-pltdoc="x">10<span class="hspace">&nbsp;</span>A Sample Project: Analysis, Discovery, Planning</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Core_.Idea%29" class="toclink" data-pltdoc="x">10.1<span class="hspace">&nbsp;</span>Core Idea</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Context_.Analysis%29" class="toclink" data-pltdoc="x">10.2<span class="hspace">&nbsp;</span>Context Analysis</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Component_.Discovery%29" class="toclink" data-pltdoc="x">10.3<span class="hspace">&nbsp;</span>Component Discovery</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Construction_.Plan%29" class="toclink" data-pltdoc="x">10.4<span class="hspace">&nbsp;</span>Construction Plan</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3amanaging%29" class="toclink" data-pltdoc="x">11<span class="hspace">&nbsp;</span>Inspecting the Plan</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ch~3awhy-design-inspection%29" class="toclink" data-pltdoc="x">12<span class="hspace">&nbsp;</span>Why Inspections Matter Even If There is No Code</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3adocuments%29" class="toclink" data-pltdoc="x">12.1<span class="hspace">&nbsp;</span>Documents: Start the README, Before the Coding Begins</a></p></td></tr></table><p><table cellspacing="0" cellpadding="0"><tr><td><p>&#160;</p></td></tr><tr><td><p></p></td></tr><tr><td><p>&#160;</p></td></tr></table></p><p>What is a software system? What goes into its production?</p><p>A software system is many lines code in the same way as an ant colony is a large
number of ants. Everyone knows that there is more to an ant colony than the huge
number of ants. Likewise, a house is much more than a large number of bricks
combined with mortar; it consists of walls and roofs and doors and many more
distinct pieces.  In this spirit, a software system is more than just 10,000
lines of code or 1,000,000 lines or even more. It consists of major and distinct
building blocks, often called subsystems or components; and yes, deep down these
components consist of code, but as we shall see, &ldquo;lines&rdquo; is the wrong idea
even at that level.</p><p>Identifying and delineating these major pieces is the first goal of any software
development project. To find the pieces, it is necessary to study the various
ways how the system interacts with its context. Once the major pieces and their
interactions are identified, someone can make a construction plan and assign the
construction of the various pieces to teams and pairs of developers.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="https://felleisen.org/srsd/Notes#simulating-maintenance">Getting Started, Getting Stressed</a></span></span></span></p><p>The following sections provide a detailed look at the nature of software systems
and the first phase of the production process. An understanding of how software
systems functions is a prerequisite to recognizing what their major pieces look
like. Identifying these pieces differs from era to era and from team to team.
But, at this point in time, we understand the basic steps of getting from a
problem statement to a software-construction plan. Understanding the general
idea of process will also help developers who join projects long after the
initial product has been constructed&#8212;<wbr></wbr>especially if the developing team has
taken the time to create a document that explains the specifics of the system:
how it came about, how to view the &ldquo;big picture,&rdquo; and how to navigate to the
&ldquo;details.&rdquo; In short, A team acting in a responsible manner will greatly help
on-boarding developers later.</p><h3 class="heading">7<tt>&nbsp;</tt><a name="(part._ch~3aproject)"></a>Running a Software Systems<span class="button-group"><a href="#(part._ch~3aproject)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>How does a software system function?</p><p>Before we tackle the question of how to construct a software system, we need to
look at how a system is run. Reflecting on how software systems work will help
understand the analysis step, the component identification, the planning phase,
and more. Clearly, an operator must launch a software; when it runs, the system
will respond to requests; and eventually the operator give the system a command
to shut itself down gracefully, which may include preparation for the next run.
But, people have also come to expect that running software systems adapt to new
contexts and end-users. That is, the system adjusts itself to various settings:
it configures and re-configure itself; it loads and unloads pieces dynamically;
and it cooperates with external systems if needed. <a href="#%28counter._%28figure._fig~3asystem-run%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">3</span></a>
illustrates a run with an abstract &ldquo;plot sketch.&rdquo;  Keep it in mind as you read
the remainder of this section.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sb.svg" alt="" width="602.91pt" height="229.67999999999998pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asystem-run))" x-target-lift="Figure"></a>Figure&nbsp;3: </span>A typical run of a software system</span></p></blockquote><p><span class="emph">The Abstract View</span> Let&rsquo;s take a look at each phase of a typical software
system run, while thinking some of the systems you have already used: a web
browser, an IDE, or perhaps an networked game.  When launched, a system
configures itself according to instructions from the command-line and/or a
configuration file. During this configuration process, the system loads
components, components initialize themselves according to configuration
parameters, and one component will pass configuration information to others.</p><p>While this setting-up process lasts, the system goes through a period of
instability. Components may become available in a concurrent manner, meaning the
order in which they are loaded or connected is unpredictable. Hence, any
individual component cannot assume that the services of some other component are
available when it starts up. Once the configuration is completed, the system
transitions to steady-state processing.</p><p>In this steady state, it responds to requests from the outside. A request
typically triggers the execution of some service&#8212;<wbr></wbr>runs some pieces of
functionality, one after another or perhaps in parallel&#8212;<wbr></wbr>and in the end
delivers a response. An external requests may trigger the loading or unloading
of components.  Such run-time extensions dynamically integrate modules or
classes into the running code. Others execute components as separate
processes&#8212;<wbr></wbr>to isolate the main system from any effects of the subsystem&#8212;<wbr></wbr>and
communicate inputs and outputs via operating systems facilities (files,
pipes). Yet others connect to completely external components for a time and then
disconnect again.</p><p>In such a multi-component system, some services are critical and some are
optional.  A component is critical if a failure in the component implies that
the system can&rsquo;t deliver a response to an external request that the context
considers absolutely necessary.  A component is optional if its externally
visible effects are of a low-priority nature.</p><p><div class="SIntrapara">Since all software comes with flaws and flaws may cause fatal failures, a system
must be constructed so that it deals differently with flaws in critical and
optional components:
</div><div class="SIntrapara"><ul><li><p>when a critical component fails, a software system should probably shut
down, ideally gracefully;</p></li><li><p>when an optional component fails, the system may recover by unloading this
component or working around it.</p></li></ul></div><div class="SIntrapara">This observation has direct consequences for the developers of the software
system. They must not only think about the proper functionality but also about
failure discovery and dealing with failures. To deal with failures in optional
pieces, they must include recovery capabilities. To deal with failures in
critical pieces, they must sufficiently harden the system to go down in a manner
that does not damage its context and, ideally, logs some error message that
gives the system&rsquo;s operators a hint as to what went wrong.</div></p><p><a name="(counter._(exercise._ex~3areliability))"></a><span style="font-weight: bold">Exercise</span>&nbsp;2. People have come to expect the fault-free, continuous
execution of some software systems, for example, the phone network or the
internet. But even these systems suffer from problems on occasion. Their
reliability is thus measured in &ldquo;the number of nines.&rdquo; For example, &ldquo;five
nines&rdquo; means the system is up and running <span style="font-style: italic"></span>9<span style="font-style: italic"></span>9<span style="font-style: italic">.</span>9<span style="font-style: italic"></span>9<span style="font-style: italic"></span>9<span style="font-style: italic">%</span> of the time, and that
it may be down for less than <span style="font-style: italic"></span>0<span style="font-style: italic">.</span>0<span style="font-style: italic"></span>0<span style="font-style: italic"></span>1<span style="font-style: italic">%</span> of the time. Calculate what these
percentages means for one month and one year.<a href="#%28counter._%28exercise._ex~3areliability%29%29" class="ex-end" data-pltdoc="x"></a></p><p>Finally, sometimes operators must take down a software system.  When a software
system receives the request to shut down, it must do so in an orderly manner.
It should save any data it may need for a re-start. It should disconnect from
external systems properly, which may mean unloading components.  It should
terminate any external processes that it launched. Generally speaking, it should
release its resources. <span class="refelem"><span class="refcolumn"><span class="refcontent">Modern operating systems properly manage
resources, but some software systems must run on impoverished platforms.</span></span></span>  Like
the start-up phase, the shut-down phase may induce some instability, and it is
thus imperative that the system no longer response to requests during this
phase.</p><p><div class="SIntrapara">Here is a summary of this analysis:
</div><div class="SIntrapara"><ol><li><p>Any interesting software system comes with a start-up configuration.</p></li><li><p>During the start-up phase, a software system loads and configures
components according to the given information. It may be unstable during this
phase.</p></li><li><p>Once the execution of a system enters its steady-state phase, external
requests call for the execution of services and responses. A request may also
result in the loading or unloading of components, again a period of potential
instability.</p></li><li><p><div class="SIntrapara">Due to bugs, multi-component systems may experience failures, some partial
and some total. Planning and developing a system must take into account failure
and options for how to react to them:
</div><div class="SIntrapara"><ul><li><p>The failure of an optional component must not tear down the entire system.</p></li><li><p>In the case of a failure of a critical component, a software system should
shut down gracefully.</p></li></ul></div><div class="SIntrapara">While a system deals with failures, it should not respond to external requests;
it would be too easy for things to go wrong.</div></p></li><li><p>Systems must also be prepared for an orderly, expected shut-down.</p></li></ol></div><div class="SIntrapara">A responsible software developer must plan for every one of these aspects of
software systems during all phases of the construction process.</div></p><p><span class="emph">A Concrete Example</span> The above overview is quite abstract. It demands a
concrete example and an illustrations of these points.</p><p>Every reader is familiar with IDEs, interactive development environments. These
IDEs are software systems in the sense of the five bullets. When a typical IDE
starts up, it consults its configuration file or directory, where it stores
information such as language modes, recently visited files, positions within
files, and much more.  If the IDE is directed to open a file for which a
language mode doesn&rsquo;t exist yet, the services for parsing and syntax-painting
the code aren&rsquo;t available&#8212;<wbr></wbr>but this must not prevent the IDE from starting up and
asking the programmer for information on how to configure these pieces of
functionality.</p><p>Once the IDE is up and running, a developer can edit the code, query it,
refactor pieces, run tests, and so on. A bug in the parsing tool or language
server will not tear down the IDE; instead the IDE will signal that there is a
problem and ask the developer how to proceed. On the other hand, if the IDE code
itself has a bug, the developer may have to &ldquo;kill&rdquo; the IDE process and restart
it. But even in this bad scenario, the IDE won&rsquo;t let down its user. It will have
stored away enough backup and recovery information that the loss will be
tolerable.  Finally, a developer is likely to shut down an IDE in the evening
and restart it in the morning.</p><p>Now that we have a common idea of what a software system is and how it runs, we
can turn to the next part, namely, the construction of systems.</p><p><a name="(counter._(exercise._ex~3aunstable))"></a><span style="font-weight: bold">Exercise</span>&nbsp;3. How could an IDE become unstable while it is looking to
load a language mode (parser, type checker) while a developer is creating code
in this language new to the IDE? What if the IDE replaces a language mode with a
revised version? Look up the term &ldquo;hot swapping.&rdquo;<a href="#%28counter._%28exercise._ex~3aunstable%29%29" class="ex-end" data-pltdoc="x"></a></p><h3 class="heading">8<tt>&nbsp;</tt><a name="(part._ch~3aproject-idea)"></a>Developing a Complete Software System<span class="button-group"><a href="#(part._ch~3aproject-idea)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>How is a software system constructed?</p><p>A modern software system consists of many interacting pieces of software. Over
time the pieces have been called by different names: component, module, package,
plug-in, (micro)service, and more. These names reflect our growing understanding
of the nature of software systems plus the advantages and disadvantages of these
organizations.</p><p>Early on, programmers thought that these components are designed, implemented,
linked, and deployed for good, like any other large engineering product, say, a
bridge or an airplane. Once a product was deployed, it just needed occasional
maintenance action, perhaps a bug fix or a port to a some new hardware.</p><p>Now we understand the nature of software differently. People view software as
the extremely malleable medium that it is. They want bugs fixed immediately;
they want new features added <span class="emph">asap</span>; and they don&rsquo;t have time to wait for
the responses of a system. All of this calls for highly responsive developer
teams and instantaneous delivery. In short, software construction has become
maintenance and maintenance is continuous construction.  One key consequence is
that developers have to look at existing code quite frequently and reconstruct
the thoughts of those who constructed it.</p><p>To understand what the construction of a software system looks like, this
section presents the imaginary scenario of being in charge of a brand-new
project. Some call this situation a &ldquo;green field&rdquo; project. Although this
situation is rare, it is idea for getting a sense of how the system&rsquo;s purpose is
refined; how its components are discovered; how these components are arranged
into a whole; and how developers describe the results of this work. After that,
it&rsquo;s onward to programming&#8212;<wbr></wbr>but all of this work is software development.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_2.png" alt="image" width="194.0" height="286.0"/></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_3.png" alt="image" width="194.0" height="286.0"/></p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3awaterfall))" x-target-lift="Figure"></a>Figure&nbsp;4: </span>Software development processes: waterfall and spiral</span></p></blockquote><h4 class="heading">8.1<tt>&nbsp;</tt><a name="(part._sec~3aproject-proceed)"></a>Ways to Proceed<span class="button-group"><a href="#(part._sec~3aproject-proceed)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In the early 1970s, Barry Boehm, one of the first software engineering
researchers, wanted to explain the cost of bugs. More specifically, he wanted to
understand the relationship between the cost and the time of bug discovery during
development. To do so, he first needed a model of development, for which he
borrowed a simplified model from ordinary engineering.</p><p><a href="#%28counter._%28figure._fig~3awaterfall%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">4</span></a> (left) shows the essence of Boehm&rsquo;s process idea, the
<span class="emph">waterfall model</span>. The engineer starts with a thorough analysis of what the
software system is to accomplish, its context, its performance characteristics,
and so on. The result is a document of requirements, and it is &ldquo;thrown over the
wall&rdquo; to specification specialists. Their task is to turn the requirements
document into a system specification, often called a <span class="emph">software
architecture</span>. Once again, the architects hand this document to people who can
write down concrete component specifications: interfaces that spell out which
functionality is needed and purpose statements for each piece of
functionality. From here, the workflow goes to coding, testing, and integration
testing until the system is ready to be deployed. The rest is simply called
&ldquo;maintenance.&rdquo;</p><p>Boehm used the diagram to state a simple-minded exponential law of bug cost. If a
bug is discovered <span style="font-style: italic">n</span> phases after its introduction into the development
process, its cost is <span style="font-style: italic">O</span>(<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span><span style="vertical-align: super; font-size: 80%"><span style="font-style: italic">n</span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span> (time, resources, money), an amount that
covers both the direct damage caused by the bug, the effort of finding the bug&rsquo;s
source, and the labor of eliminating it. Boehm&rsquo;s paper implies that the model is a
strawman, and the number is just a &ldquo;guestimate.&rdquo;  Nevertheless
people tried to follow this waterfall process of developing software, and in
principle, its sheer existence is critical because it identifies important
intermediate products: requirements; architecture and its components; unit tests
and integration tests; deployment documentation; etc.</p><p>In 1976, when Boehm consolidated his presentations into a book, he presented
a refined variant of this waterfall model of software development: a <span class="emph">spiral</span>
version. Here &ldquo;spiral&rdquo; means that each phase in the workflow diagram of
<a href="#%28counter._%28figure._fig~3awaterfall%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">4</span></a> (right) is equipped with a backarrow to its
predecessor. These backarrows indicate critical feedback, which demands a
conversation between the people working on phase <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span> and those working on
phase <span style="font-style: italic">n</span>. In the terminology of Boehm&rsquo;s book, a component specifier would
conduct a thorough review of the software architecture and thus provide feedback
for improvements. This conversation continues until the component specifier is
satisfied with the architectural specification. In turn, a demand for revisions to
the architecture may raise questions about the analysis of the purpose and context
of the software system. Generally speaking, the document of phase <span style="font-style: italic">n</span> is no
longer chiseled in stone but a negotiable product, and the negotiations may flow
all the way back to the origin.</p><p>By 2000, the ideas of agile development and extreme programming changed the landscape
of software development even more. Coding is no longer seen as a minor step in the
middle but as the beginning-and-end. Testing is tightly integrated with, and
drives, the development of code. Due to internet-based delivery of software,
deployment and maintenance aren&rsquo;t separate phases anymore but simply become another
element of a tightly knit development-and-feedback cycle.</p><p>At first glance, the analysis of requirements and the design of an architecture
plan seem to be missing, but these appearances are deceiving. Both are still
needed, though they may not play the same role. Without a goal statement and an
analysis of this statement, developers don&rsquo;t know where they are going with
their software. So formulating the goal, and analyzing how to get there,
<span class="emph">is</span> a requirements analysis.</p><p>In the same vein, a software system without some architecture cannot exist for a
long time. Like a plan for a home, a software architecture is a blue print and a
guide to the numerous interacting pieces. While a process such as spiral
development develops a draft architecture explicitly and up front, agile and
extreme-programming processes create this understanding over the course of the
creation phase. It may be implicit at first, but when the software development
process is successful, someone will have to describe the architecture explicitly
if the &ldquo;owner&rdquo; wishes to maintain the product for the long run&#8212;<wbr></wbr>or suffer the
consequences of a socially irresponsible development process.</p><p><span style="font-weight: bold">Reading</span></p><p>Barry W. Boehm. Software engineering. <span style="font-style: italic">IEEE Transactions on
Computers</span>. <span style="font-weight: bold">25</span>(12). 1976.&#8212;<wbr></wbr>On occasion, it is worth our while to read
original literature, especially when follow-up characterization of this work are
rather murky.</p><p>Kent Beck. <span style="font-style: italic">Extreme Programming Explained.</span> Addison-Wesley. 1999.&#8212;<wbr></wbr>In this
short book, Beck argues for &ldquo;programming&rdquo; as the central, creative activity and
explains how a &ldquo;programming first&rdquo; approach to software development may work in
practice.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="https:agilemanifesto.org">The Agile Manifesto</a></span></span></span>
Kent Beck, et al. <span style="font-style: italic">Manifesto for Agile Software Development.</span>
2001.&#8212;<wbr></wbr>Beck and many other signatories published a dozen
principles describing a flexible approach to software development. They fit on a
laptop screen, and decades later it is an interesting read, if only to understand
how this short piece affected industry at many levels.</p><h4 class="heading">8.2<tt>&nbsp;</tt><a name="(part._sec~3aproject-facets)"></a>Analysis: Understanding the Project&rsquo;s Purpose and Context<span class="button-group"><a href="#(part._sec~3aproject-facets)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Although this book is <span class="emph">not</span> about software engineering, it is still
important for a student of software development to see how an experienced
developer might conduct a rudimentary analysis&#8212;<wbr></wbr>because it helps explain to an
on-boarding developer the state of the software. A budding developer must
understand how software systems start with an idea; that they are always placed
in a context; and that their operation is about interacting with this
context. Once this much is understood, it is possible to create a rough,
high-level sketch of the components needed to implement the desired
functionality and how these components depend on each other. The goal is to put
the development team into a position where it can begin to work out a
construction plan.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="analysis-spiral.svg" alt="" width="680.58pt" height="738.0512pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asystem-analysis))" x-target-lift="Figure"></a>Figure&nbsp;5: </span>A spiral analysis of an imagined software system and its context</span></p></blockquote><p>Every project starts with an idea about some piece of functionality that people
would like to have implemented as a piece of code. In the beginning, military
men needed weapons-related calculations done. Engineers aimed to help with the
construction and control of airplanes and space ships. Scientists wished to
model the weather. Business people wanted to replace the tedious paper-based
bookkeeping with accounting software. Doctors asked for assistance with
diagnosing illnesses. Once the world-wide web came about, travel agents lost
their jobs to web sites. Drivers ditched their city maps and used web-based
navigation systems for trips around town. People also imagined how others might
like to share experiences via stories, links, pictures, videos, and so on. The
addition of the cell phone brought all these things and many more to our finger
tips wherever we went, whenever we requested them.</p><p>This short history points to a key insight about software: it never exists in a
vacuum. Software entrepreneurs and their developers must understand and keep in
mind the context in which the software lives. As a matter of fact, basic
development practices alone demand that they investigate this context
<span class="emph">before</span> they even start.</p><p>Diagram 1 in <a href="#%28counter._%28figure._fig~3asystem-analysis%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a> illustrates this insight. When
someone wishes to build some software, it is common to have an idea that any
non-trivial system (the square) will consist of a bunch of components (the
black rectangles inside) and that it connects to some context, which actually
determines how the software will be used. It is natural to proceed in a
spiral-like fashion, outwards from the imagined software system, to explore this
context.</p><p>As an analyst investigates the very first layer around the software,
<span class="emph">operators</span> come up; see diagram 2 in <a href="#%28counter._%28figure._fig~3asystem-analysis%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a>. An
operator could be a soldier, a construction worker, an accountant, an engineer,
or just someone looking up a friend&rsquo;s latest dance video. It may not even be a
person, but a thermostat, a camera, a light switch, or even some other software
system. Whatever it is, it must be able to <span class="emph">stimulate</span> the imagined software
system so that it <span class="emph">responds</span>. This response could affect a person, or it
could turn on/off a mechanical device such as a cannon, the injection part of a
car engine, a phone&rsquo;s speaker. Indeed, it may even be a message to some other
software system. Let&rsquo;s call this the <span class="emph">stimulus-response</span> layer.</p><p>Next an analyst is likely to find <span class="emph">passive observers</span>; see diagram 3 in
<a href="#%28counter._%28figure._fig~3asystem-analysis%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a>. These context elements may perceive the
existence of the software; they may experience the effects of the system; but
they will not directly interact with the software. If the software malfunctions
or disappears, some may notice, some may not; some might become unhappy about
it; some may welcome it. Consider a software system for designing aircraft
wings. The engineers at Boeing will interact with it. By contrast, the pilots
know about it and may notice that their new airplane consumes less fuel than the
previous model.  Similarly, the guests of a restaurant may face TV screens that
show some political conversation and most would likely be happy if the systems
malfunctioned.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="analysis-boundary.svg" alt="" width="302.48pt" height="302.48pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asystem-boundary))" x-target-lift="Figure"></a>Figure&nbsp;6: </span>Drawing the boundary between a software system and its context</span></p></blockquote><p>Finally, when the analysts have explored the context to a sufficiently large
distance, they will notice that more and more unrelated concepts show up; see
diagram 4 in <a href="#%28counter._%28figure._fig~3asystem-analysis%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a>. Think of the passengers in the
airplane or the air-traffic controllers, none of whom will interact or even
consider the wing-design program mentioned above. They all just don&rsquo;t matter for
the product development.</p><p>At this point the analysis is concluded and yields two critical pieces: a
description of the relevant context and the boundary between the software and
its context. <a href="#%28counter._%28figure._fig~3asystem-boundary%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">6</span></a> makes this point with the triangle
that separates the core functionality and its operators-and-observers
context. Now is the time to study the results of the analysis so that a
developer understands the uses. This step focuses on the operators and how they
might interact with the system, that is, the entire path from a stimulus to a
response. It also includes the observers and what they may wish (or not) to
experience when the software runs. A consultant may also make a plan on how to
deploy the finished system and how it will affect the people in its context.</p><h4 class="heading">8.3<tt>&nbsp;</tt><a name="(part._sec~3aidentify-components)"></a>Synthesis: Discovering Components<span class="button-group"><a href="#(part._sec~3aidentify-components)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Drawing the boundary between an imagined software system and its context is key
to figuring out the system&rsquo;s major components and the role they play. The starting
<span class="refelem"><span class="refcolumn"><span class="refcontent">Experienced developers know that this idea generalizes to component creation.</span></span></span>
point of this step is the set of operators in the context of the system. After
identifying them, we need to determine how they stimulate the system; we need to
imagine how this stimulus triggers communications among the system&rsquo;s components;
and we need to describe what the response is and which pieces of the context it
affects. Software engineers refer to this step as a use-case analysis.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="use-case-analysis.svg" alt="" width="468.92pt" height="226.86pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3ause-cases))" x-target-lift="Figure"></a>Figure&nbsp;7: </span>Understanding use cases</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3ause-cases%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">7</span></a> displays two diagrams that illustrate a use-case
analysis. The diagram on the left shows how an operator stimulates the
system. The stimulus affects one of the system&rsquo;s components. In turn,
stimulating this component triggers an internal event with another
component. One way to understand this second step is to think of a shift of the
boundary. The active component has become something like an operator, and to get
its computation performed, it stimulates another component. From the perspective
of a stimulus-response chain, this second stimulus is the response of the first
component to the operator&rsquo;s stimulus. This process continues until the software
system is ready to issue a response to its context. In the case of the left
diagram this response goes back to the original operator. As the diagram on the
right side of <a href="#%28counter._%28figure._fig~3ause-cases%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">7</span></a> shows, the response does not have to go
back to the operator; instead, it could be a signal to passive observers.</p><p>Keep in mind that operators and observers are not necessarily people. An
operator could be a sensor, such as a thermometer, combined with an actuator,
say, an air condition unit (A/C). A thermometer sends measurements to a software
component that checks the measured temperature relative to some preset value. If
the measured temperature is above the present value, the software system may
request cold air from the A/C. Or, think of a smart phone. It is essentially a
large software system that may receive messages from other software systems: a
ping from a cell tower, an old-fashioned text messages, notifications from
social media, a signal for its clock, and many more. While a ping may demand an
acknowledgment from the phone, a signal to the clock should not require a
response (though an owner may notice when the clock adjust to a new time zone).</p><p>The purpose of a use-case analysis is to discover a system&rsquo;s essential
components. A component typically represents information with data and
implements a complete piece of functionality. In a smart home, the software
system may come with a control component for configuring the various devices in
the home. And, this control component is likely to connect with communication
components (drivers), which translates operations from the occupants and sensors
into actions. A communication component will interact with actuators in the
home, say, music players that send the sound to the speakers in the room where
people are or light switches that turn off all light bulbs when everybody has
left a room.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="use-case-missing.svg" alt="" width="468.92pt" height="226.86pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3ause-cases++))" x-target-lift="Figure"></a>Figure&nbsp;8: </span>From use cases to component identification</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3ause-cases%2B%2B%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">8</span></a> displays the diagrams like those in
<a href="#%28counter._%28figure._fig~3ause-cases%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">7</span></a> but with an additional. Concretely the diagrams
contain a gray-shaded component. The diagram on the left indicates how this
component was missing from the stimulus-response path that starts at the
operator icon on the right and whose response goes to this very operator. Think
of a component that renders an internal data structure into a visual
presentation that a person can understand; or imagine the translation of an
internal piece of data into a piece of information for an actuator.  The diagram
on the right in <a href="#%28counter._%28figure._fig~3ause-cases%2B%2B%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> shows a use case that shares a
prefix of the stimulus-response path with the one on the left. But, the newly
discovered component does not become a part of this use case. Generally
speaking, every use case deserves its own careful analysis.</p><p><div class="SIntrapara">Moving from the abstract to the concrete, the question really is what kind of
components are being discussed. Here are some examples, inspired by our
understanding of what software systems are (<a href="#%28part._ch~3aproject%29" data-pltdoc="x">Running a Software Systems</a>):
</div><div class="SIntrapara"><ul><li><p><span class="emph">the central data structures</span></p><p>Software must represent domain-relevant information with data and (possibly
sophisticated) algorithms on this data.  And, because of the latter, people have
identified programming&#8212;<wbr></wbr>and even software development&#8212;<wbr></wbr>with
<span class="refelem"><span class="refcolumn"><span class="refcontent">Some of this confusion is still on display during job interviews, though
companies are learning that algorithm design skills do not predict socially responsible
and cost-effective software development skills.</span></span></span>
algorithm design for a long time. While this confusion is mostly gone from
industry, it is still the case that almost every software project has at its
heart a data-structure component that encodes and manages complex
information. This data-structure component plays a critical role during the
steady phase of an execution, though it may also require special attention
during the start-up phase.</p></li><li><p><span class="emph">knowledge about external actors</span></p><p>In addition to representing domain-specific information, a software system must
represent information about operators and observers in its context. Since this
data representation is unrelated to the central data structure, separating
the two into different components satisfies general software development
guidelines.</p></li><li><p><span class="emph">communication with people</span></p><p>All software systems communicates with operators and observers. When these
actors are people, the communication proceeds via graphical user interfaces
(GUIs). For a long time, the construction of GUIs called for three different,
independent components: the model, which relies on the previously mentioned,
central data-representation components; the view, which presents data to end-users
and provides mechanisms for operators to stimulate the system; and the
controller, which connects the two pieces. This arrangement comes with an
obvious name: a Model-View-Control architecture; you can search for this
arrangement and find lots of information about it.&#8212;<wbr></wbr>While the web and mobile
computing have reduced the importance of this separation&#8212;<wbr></wbr>due to separation of
devices&#8212;<wbr></wbr>keeping this architectural arrangement in mind is a good idea.</p></li><li><p><span class="emph">communication with devices and separately operating software systems</span></p><p><div class="SIntrapara">If the interaction involves other software systems or devices, the construction
depends on two levels of protocols:
</div><div class="SIntrapara"><ul><li><p>The &ldquo;logical&rdquo; communication between the system and others concerns the
timing and the kind of data that needs to be exchanged. It also refers to the
correctness of the exchange. This logic should exist in one component.</p></li><li><p>Another component should be dedicated to the &ldquo;physical&rdquo; communication,
that is, a component for receiving data from, and sending it to, other actors. It
relies on existing protocols, say, the device manufacturer&rsquo;s specifications or an
internet protocol (UDP, TCP, HTTP, and so on). In the second case, the developers
of the software systems may even build a protocol on top of the existing ones if
they have control over both parties.</p></li></ul></div><div class="SIntrapara">Keeping the two forms of communication separate is important and therefore
justifies the separation into (at least) two components. Even if the manufacturers of
devices update their protocols, the communication <span class="emph">logic</span> should probably
stay the same for the existing functionality. In other words, repairing the &ldquo;physical&rdquo;
component should suffice. Similarly, external software systems may undergo
maintenance and react to different protocols. Or, a company may decide that
switching from TCP to UDP gains enough speed to justify the effort. In both
cases, the changes are contained to the physical communication component, not its
logic-oriented one.</div></p></li><li><p><span class="emph">configuration interpretation</span></p><p>The start-up phase of a software system is specified in a configuration, data
that may live in a file, at a URI on the internet, and/or come in via the
command-line. A software system needs a component that interprets this data,
where &ldquo;interpretation&rdquo; means initializing components, connecting them, and
getting the system ready for steady-state processing.</p></li><li><p><span class="emph">re-configuration</span></p><p>Software system are dynamic. When an inessential component goes wrong, it is
disconnected. Some systems allow the loading of external components during
execution so that new pieces of functionality become available; these pieces may
not have existed when the system was launched. To monitor this dynamic
reconfiguration, a software system may come with a supervisor component, whose
task it is to manage loading, connecting, disconnecting, and even unloading
components.</p></li></ul></div></p><p>This list of examples is by no means exhaustive, but it should help with the
important idea of <span class="emph">separation of concerns as separation of components</span>. By
keeping key pieces of functionality separate, developers provide direct help
with the future maintenance. If it turns out that a central data structure is a
performance bottleneck, a developer can probably change its internals without
changing other parts of the system. Other kinds of changes to functionality can
also be isolated to one component or two if different concerns of functionality
are allocated to different components.</p><h4 class="heading">8.4<tt>&nbsp;</tt><a name="(part._sec~3aproject-plan)"></a>Planning: How the Construction Proceeds<span class="button-group"><a href="#(part._sec~3aproject-plan)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The analysis of a software system&rsquo;s context develops the big picture idea. Here
&ldquo;big picture&rdquo; means seeing the system in context&#8212;<wbr></wbr>the idea, the operators,
the observers, and their general relationships&#8212;<wbr></wbr>as well as drilling down to
discover key details, say, the exact relationship between the system and the
external actors. In computer science this way of proceeding is called
<span class="emph">top-down</span>.</p><p>Proceeding in a top-down fashion is still appropriate when developers perform a
use-case analysis to discover the distinct components of the system. The big
picture here consists of the essential data representations and the key pieces
of functionality. The &ldquo;drilling down&rdquo; discovers such details as to the
existence of one component may depend on the existence of (functionality in)
others. Understanding the exact nature of these dependencies is not yet
critical.</p><p><div class="SIntrapara">Understanding this high-level view of components and their dependencies is
critical for the next step:
</div><div class="SIntrapara"><blockquote><p>turning the component analysis into a development plan.</p></blockquote></div><div class="SIntrapara">In contrast to the context analysis and component discovery, the development of
the code base proceeds in a <span class="emph">bottom-up</span> fashion.  To discover the bottom,
it is necessary to analyze the dependencies among the identified components and
to find those components that stand alone. That is, they obviously do not depend
on any of the other major components. Once these foundations have been
identified, the components can be arranged in layers. The first layer depends on
just the components in the foundation. The layer on top of this one may depend
on both, and so on. In short, a plan is really a topological sort of the
component-nodes in an acyclic graph of dependencies.</div></p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="planning.svg" alt="" width="599.63426256pt" height="191.04pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3alayers))" x-target-lift="Figure"></a>Figure&nbsp;9: </span>Layering the identified components</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3alayers%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">9</span></a> displays a suggestive layering diagram of some of the
sample components mentioned in the preceding section. An arrow from <span style="font-style: italic">A</span>
to <span style="font-style: italic">B</span> should be read as &ldquo;component <span style="font-style: italic">A</span> depends on component
<span style="font-style: italic">B</span>.&rdquo;  In this sample arrangement, the foundation comprises the central
data structure component and the component that records knowledge about external
actors. Layer 1 consists of two components: a component that represents the
external actors and another one that implements how to communicate with
them. The top layer implements the actual, physical communication, perhaps via a
remote-proxy pattern.</p><p><a name="(counter._(exercise._ex~3aorganize))"></a><span style="font-weight: bold">Exercise</span>&nbsp;4. Organize the five components in <a href="#%28counter._%28figure._fig~3alayers%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a>
into a linear plan sequence so that a component listed at position <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span>
depends only on components <span style="font-style: italic"></span>1<span style="font-style: italic"></span> through <span style="font-style: italic">n</span>.<a href="#%28counter._%28exercise._ex~3aorganize%29%29" class="ex-end" data-pltdoc="x"></a></p><p>In addition to inter-component dependencies, external constraints also play a
role in the composition of a construction plan. For example, the ability to
demonstrate a working prototype might dominate other concerns. Consider the
development of a software system that may have to rely on interactions with
external software systems. A client, a marketing person, a manager, or an investor may be happy to see a
prototype that merely implements the logical communication and runs on just a
single computer. Depending on the various desired features, this stage can be
broken into several smaller ones, too, as long as each of them comes with
observably distinct functionalities.</p><h3 class="heading">9<tt>&nbsp;</tt><a name="(part._ch~3asw-arch)"></a>Software Architecture<span class="button-group"><a href="#(part._ch~3asw-arch)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>While developers identify the components of a software system, they also develop
an idea of how these components relate to each other. Conversely, existing ways
of relating components to each other tends to determine a bit how developers
identify components and their relationships; on some rare occasions, developers
come up with new ways of arranging components or at least variations of existing
arrangements.  Before we continue, it is therefore necessary to take a look at
these preconceptions.</p><p>Researchers refer to these established and widely used arrangement of components
as <span class="emph">software architectures</span>. They coined this phrase to describe an entire
field of study. Practicing software architects view the use of (variants of)
existing architectures as a way to arrange components so that the overall system
is easily understood and effective. In other words, it is a small act of
socially responsible development.</p><p>Any developer team that grows to a certain size has a dedicated architect, and
many developers consider this aspect of software development a sweet
spot. Becoming a software architect requires experience and reflection. The
former starts with knowing some basic architectures; the latter means having an
eye for proper relationships among components.</p><p>This section presents three architectures that every developer should
know. There are many more, and descriptions can be found in the
research<span class="refelem"><span class="refcolumn"><span class="refcontent">Though be careful, this very literature can lead people to
turn into &ldquo;architecture astronauts.&rdquo;</span></span></span>literature. The notion is also somewhat
related to the field of object-oriented design patterns, though as the name
says, the latter is focused on a specific class of programming languages (and
how to circumnavigate some of their deficiencies).</p><h4 class="heading">9.1<tt>&nbsp;</tt><a name="(part._.Pipelines)"></a>Pipelines<span class="button-group"><a href="#(part._.Pipelines)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The Unix operating system introduced the <span class="emph">pipe</span> as a mechanism for
composing programs that read their arguments from a standard input device and
write their results to a standard output device.</p><p>Operationally, the pipe mechanism enables a programmer to turn the standard
output device of one program into the input device for a second program. This
way the second program can process the output of the first and compute its
results from those. A <span class="emph">pipeline</span> is a composition of several programs with
pipes between them. While the idea sounds simple, it has consistently shown
surprising value and has been ported to almost all operating systems.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sa-pipes.svg" alt="" width="265.39177488pt" height="26.136pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asa-pipes))" x-target-lift="Figure"></a>Figure&nbsp;10: </span>The pipeline architecture</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3asa-pipes%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">10</span></a> displays a diagram that illustrates the idea
geometrically. Each component consumes an input <span class="emph">stream</span>, which contains a
number of elements. It also produces an output stream, again a sequence of
elements. The shaded elements of the input streams are those that the component
has consumed. As the diagram also shows, different components process their
input streams at different speeds.</p><p>Depending on the relative speeds, one component may have to wait for its
predecessor. The pipes-as-streams mechanism smoothly accommodates such
differences, because it clearly distinguishes the end of the stream from the
situation when the next element is not ready for processing yet.</p><p><div class="SIntrapara">Consider the following example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ls -l | grep rkt | wc -l</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">15</span></p></td></tr></table></div></p><p>The <span class="stt">ls -l</span> command&#8212;<wbr></wbr>that is, a program <span class="stt">ls</span> with a
commandline flag <span class="stt">-l</span>&#8212;<wbr></wbr>displays the files in the current directory to the
standard output device, one per line. This output device becomes the input for
the following command.  The <span class="stt">grep</span> program searches its input stream for the
word given on the commandline (<span class="stt">rkt</span>) and displays only those lines that
contain the word. Finally, <span class="stt">wc -l</span> counts the lines of its input stream. In
short, the pipeline counts the files in some directory whose name contains the
word <span class="stt">rkt</span>. The result of the entire pipeline is 15.</p><p><div class="SIntrapara">Here is a second example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ cat I.scrbl | tr -s '[:space:]' | sort | uniq | head -7</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">00</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">000</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">A</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ASCII</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Absolutely</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Addison</span></p></td></tr></table></div></p><p>This pipeline uses <span class="stt">cat</span> to display <span class="stt">I.scrbl</span>, the source of
part I of this book line by line; breaks it into words; sorts those; eliminates
duplicates; and finally displays the first seven words.</p><h4 class="heading">9.2<tt>&nbsp;</tt><a name="(part._.Model__.View__.Controller)"></a>Model, View, Controller<span class="button-group"><a href="#(part._.Model__.View__.Controller)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The introduction of graphical user interfaces in the 1970s pointed out the
essential difference between the data that a program manages, the way the data
is presented to customers, and how the latter interact with this
presentation. To realize this separation, a developer at Xerox Parc proposed a
three-part architecture: model-view-controller.</p><p>Using standard science terminology, the <span class="emph">model</span> is the essence, the data
set that the software system manages. A <span class="emph">view</span>&#8212;<wbr></wbr>notice the indeterminate
article&#8212;<wbr></wbr>is a way of displaying the data; one data set may have many views,
with none being necessarily superior to any other. If a user wishes to interact
with a particular view, the software system needs a component that translates
the user&rsquo;s gestures into updates to the view and changes to the model&#8212;<wbr></wbr>as
needed.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sa-mvc.svg" alt="" width="281.3184pt" height="143.50125792pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asa-mvc))" x-target-lift="Figure"></a>Figure&nbsp;11: </span>The model-view-controller architecture</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3asa-mvc%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">11</span></a> presents the idea as a diagram. An model-view-controller
architecture consists of one model component and <span style="font-style: italic"></span>2<span style="font-style: italic"> * n</span> controller and
view components. The latter come in pairs, because each view may need its own
way of allowing users to interact with the system. The diagram shows that the
user understands the data through a view presentation and that any gestures of
the end-user are related to the model via a controller for a view. In turn, the
model component informs the view of changes to the data display.</p><p>The ubiquitous spreadsheet is an early and well-known system that employs the
model-view-controller architecture. An end-user enters data and can then request
different views of the same data with various gestures: tables, bar charts, pie
charts, etc.</p><p>Similarly, many modern IDEs make use of the model-view-controller architecture. An IDE may display
the full program text or an outline view; it may show a hierarchical project
view; and it may allow programmers to interact with the system via a console.</p><h4 class="heading">9.3<tt>&nbsp;</tt><a name="(part._.Client__.Server)"></a>Client, Server<span class="button-group"><a href="#(part._.Client__.Server)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Another Xerox Parc effort&#8212;<wbr></wbr>a networked or distributed file system&#8212;<wbr></wbr>led to the
client-server architecture, that is, the classification of some computers as
providing a service and others as being clients of this service. The
architecture has found many uses since.</p><p>A classical client-server arrangement consists of one server program running on
a computer and an arbitrary number of client programs, usually but not always
running on different computers. Each client interacts only with the server. It
sends a request message to the server, asking for some data or for some work
to be performed on its behalf. The server sends back a response, the requested
piece of data or just an acknowledgment that the work has been performed.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sa-client-server.svg" alt="" width="147.82432512pt" height="110.53968768pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asa-client-server))" x-target-lift="Figure"></a>Figure&nbsp;12: </span>The client-server architecture</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3asa-client-server%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">12</span></a> shows an instance of a client-server
architecture, where six different clients are simultaneously interacting with
the server. Here the server sits in a &ldquo;central&rdquo; location, indicating that it
should be easily reachable for all expected clients. The double arrows between
the clients and the server&#8212;<wbr></wbr>and the absence of any other arrows and
liness&#8212;<wbr></wbr>are the only communications that take place.</p><p>Every computer user is implicitly familiar with the client-server architecture.
The web browser on laptops sends requests to a web server. Simple requests ask
for the content of a file, usually with some HTML content, which the browser
then renders on the user&rsquo;s monitor. The response may contain JavaScript
programs, which turn the browser window into an interactive graphical user
interface. Complex requests demand that the server runs a script that composes
the response.</p><p>Many apps on people&rsquo;s mobile devices (phones, watches, cameras) play client to
servers. Some are simple software wrappers around web browsers and essentially
act as such. Others are genuine graphical user interfaces whose model partially
resides on the mobile device and is supplemented by data on a server, which is
retrieved via request-response actions.</p><p>While the classical client-server architecture typically replies with one
response per request, alternative variants exist. For example, a request from a
client to a server may initiate an entire conversation, consisting of many
back-and-forth messages. Indeed, the server may engage with other clients at the
same time, concurrently or sequentially, and the server&rsquo;s responses may even
depend on how other clients react.</p><p><span style="font-weight: bold">Reading</span></p><p><div class="SIntrapara">Mary Shaw and David Garlan. <span style="font-style: italic">Software Architecure.</span> Prentice
Hall. 1996.</div><div class="SIntrapara"></div><div class="SIntrapara">&#8212;<wbr></wbr>The book is an introduction to the research area of software
architecture, covering several topics: basic architectures, style guidelines,
linguistics, formal methods, tools, and education.</div></p><h3 class="heading">10<tt>&nbsp;</tt><a name="(part._ch~3asample-project)"></a>A Sample Project: Analysis, Discovery, Planning<span class="button-group"><a href="#(part._ch~3asample-project)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="https://felleisen.org/srsd/Notes#the-project">Planning a Project</a></span></span></span></p><p>Imagine a brand-new startup that wants to engage &ldquo;hackers.&rdquo; The founders noticed
that &ldquo;hackers&rdquo; are mostly bored on their jobs and complain about the bad habits of
their teammates. So, the founders wants to run servers that host tournaments of
board games, and &ldquo;hackers&rdquo; from all over the world will produce automated players
that connect to the servers.  These &ldquo;hackers&rdquo; will pay a small fee to have their
automated players participate in tournaments, and the winning player (and its
owner) will win a significant prize. The founders are also considering
broadcasting the games to paying subscribers, and like in all unicorn dreams,
these broadcasts could become channels for delivering advertisements&#8212;<wbr></wbr>though
this really is just a dream for now.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sa-client-server-x.svg" alt="" width="147.82432512pt" height="110.53968768pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asa-client-server-x))" x-target-lift="Figure"></a>Figure&nbsp;13: </span>The player-client/game-server architecture</span></p></blockquote><p>Starting with this description of the idea, a software developer no longer sees
a blank slate but the idea of the client-server architecture in
<a href="#%28counter._%28figure._fig~3asa-client-server-x%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">13</span></a>. The clients are the automated players; the
server is a game server. Player-clients request to participate in the game, and
the game-server arranges through its responses for the execution of a game. The
architecture differs from the classical one in that (1) the server and the
client exchange a series of messages&#8212;<wbr></wbr>they conduct a complete game with many
turns&#8212;<wbr></wbr>and (2) depending on the nature of the game, the server arranges these
conversations in a particular order, as indicated by the dashed arrows in the
figure.</p><p><div class="SIntrapara">Let&rsquo;s make all this a bit more concrete via a game that this company may pick to
explore the &ldquo;market:&rdquo;
</div><div class="SIntrapara"><blockquote><p><span class="emph">Ticket to Ride</span> is a board game about the railroad
barons in the 1800s and how they built train networks. It accommodates four to
six players. The central game piece is a map of cities and direct train
connections between them.  Each connection has a distinct color: "white", "red", "blue", "green"; its <a name="(tech._length)"></a><span style="font-style: italic">length</span> is one of 3, 4, 5.</p><p>At the beginning of the game, each player receives some colored cards, which
it keeps hidden from the others, and some rails.  In addition, a player must
choose some destinations (from a small set). A destination is a pair of cities
on the game map that must be connected via at least one path (of connections).</p><p>Once all players are set up, the game begins. At each turn a player may choose
one of three actions: (1) request additional cards; (2) acquire and occupy a
connection; or (3) pass. To acquire a connection of color <span style="font-style: italic">c</span> with <span style="font-style: italic">n</span>
segments, a player must hand over <span style="font-style: italic">n</span> cards of color <span style="font-style: italic">c</span>. To occupy
it, the player must place a rail on each segment of the connection.  Once a
player has acquired and occupied a connection, no other players can acquire or
occupy it.</p><p>When one of the player&rsquo;s number of rails drops below the smallest number of
segments in a connection at the end of its turn, every other player gets to take
one more turn. The game also ends if every player has had an opportunity to play
a turn and all of them passed.</p><p>The player with the most points wins.  Each acquired rail segment is worth one
point. Each player-chosen city destination is worth 20 points if a player manages to
connect the specified places via a path; if a player fails to connect the cities
of a chosen destination, 20 points are subtracted from the player&rsquo;s
total. Lastly, the player with the longest continuous path of rail connections
receives 20 extra points.</p></blockquote></div><div class="SIntrapara">The game is simple; the details are manageable; and it also seems to mix some
strategic thinking with luck. The imagined bored &ldquo;hackers&rdquo; may just try to win
again and again&#8212;<wbr></wbr>and pay a fee each time.</div></p><p><span style="font-style: italic">Note</span> To simplify the analysis, discovery, and planning, let&rsquo;s ignore the
financial side of the software system. This side of the business is mostly
orthogonal to its core functionality: running games and tournaments.</p><h4 class="heading">10.1<tt>&nbsp;</tt><a name="(part._.Core_.Idea)"></a>Core Idea<span class="button-group"><a href="#(part._.Core_.Idea)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The starting point is somewhat clear. While human players tend to manage a game
jointly&#8212;<wbr></wbr>agreeing to and interpreting rules together; dealing with common game
tokens together or putting a trustworthy person in charge&#8212;<wbr></wbr>a software variant
calls for a neutral party, and that part is the company&rsquo;s software.</p><p>Following tradition, let&rsquo;s use <span class="emph">referee</span> for the component that manages a
game. It will have to rely on a representation of the game pieces: the
<span class="emph">map</span>, the <span class="emph">colored cards</span>, the <span class="emph">rails</span>, the
<span class="emph">destinations</span>. Furthermore, it needs to <span class="emph">represent</span> what it
<span class="emph">knows</span> about the <span class="emph">participating players</span> so that it can enforce the
rules.</p><p>Beyond games, the software is also in charge of running tournaments. This task
is completely separate from refereeing a game, so a <span class="emph">tournament manager</span> is
called for.</p><h4 class="heading">10.2<tt>&nbsp;</tt><a name="(part._.Context_.Analysis)"></a>Context Analysis<span class="button-group"><a href="#(part._.Context_.Analysis)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The operators are &ldquo;hackers&rdquo; who run <span class="emph">automated players</span>.  Where these
operators exist seems to be unrelated, other than that the company&rsquo;s interaction
with the players must allow for long distances. If the company runs its servers
in Seattle and the automated player executes on a computer in Capetown,
communication between the two takes longer than the method calls between a
&ldquo;house player&rdquo; and the game-serving software.</p><p>Concerning observers, the company must certainly accommodate its investors. Most
<span class="emph">investors</span> do not care about the code&#8212;<wbr></wbr>although they probably should&#8212;<wbr></wbr>but
a company can impress them with visual effects. Additionally, the human
<span class="emph">operators</span> of the server software may wish to have some visible means of
checking on the progress of individual games or entire tournaments. Finally, the
&ldquo;business plan&rdquo; calls for <span class="emph">subscribers</span> to be able to watch games,
possibly for a fee or in exchange of watching advertisements.</p><p>Outside this circle of operators and observers, an analyst may see sports bars,
the parents of a &ldquo;hacker,&rdquo; server-machine farms, and many more things. In
reality, though, the concepts identified so far describe the software system&rsquo;s
components and its context as much as needed for now. Put differently, the
description clearly tells us how to proceed with the development of the core of
the software system.</p><h4 class="heading">10.3<tt>&nbsp;</tt><a name="(part._.Component_.Discovery)"></a>Component Discovery<span class="button-group"><a href="#(part._.Component_.Discovery)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The context analysis yields a description of the system&rsquo;s environment with
operators and observers.  Imagining these external actors, an analyst plays
through key use cases and looks for the components of the clients and server in
the imagined architecture of <a href="#%28counter._%28figure._fig~3asa-client-server-x%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">13</span></a>.</p><p>For <span style="font-style: italic">Ticket to Ride</span>, the analysis has unearthed six components: a
tournament manager, a referee plus data representations for the map, the cards,
the rails, and the destinations.  There are two operators: &ldquo;hackers&rdquo; and
automated players. At least two kinds of observers are essential: the people who
monitor the running system and those who invest in the company before it goes
unicorn.</p><p>Let&rsquo;s look at how these external actors interact with the game system, keeping
in mind that, like all software systems, the game server starts up, runs
tournaments and games, communicates with players, informs
observers, deals with failing components, and eventually shuts down.</p><p><span style="font-style: italic">Launch</span> The &ldquo;hackers&rdquo; want to launch their automated players and
connect them to the company&rsquo;s server software. Just stating this much of a
purpose raises two questions. The first one is what they connect to. The
tournament manager is the only identified component that could even remotely
play this role. But then the tournament manager would take on two distinct
tasks: managing a tournament of hundreds or thousands or more automated players
<span class="emph">and</span> signing them up. If the idea takes off, the two tasks might have to
be performed concurrently: while a tournament is going on, the next wave of
automated players is signing up. That is, this part of the use-case analysis
points to a gap in the component identification process. The game system needs
one more component, one that signs up automated players and launches tournaments
via the manager.</p><p>The second question is how the automated player contacts the sign-up component.
Since the automated players and the game system will run on two separate
computers, choosing a physical, or remote, communication protocol is
necessary. The choice will determine how a player connects and how a game server
interacts with the players.</p><p><span style="font-style: italic">Running a Tournament</span> Once enough players are signed up for a tournament,
the manager should inform the players to get ready for their first
game. Similarly, when the tournament is eventually over, the manager component
should let the players know. At a minimum, the winner(s) of the tournament should
find out that they won a lot of money.</p><p>What this use case immediately points out is the need for a <span class="emph">logical</span>
communication protocol between server and player. This protocol specifies how
the game server and its components contact the players, which information is
revealed and as what kind of data it flows from the tournament manager to the
player, and what comes back.</p><p>Note that this concern is separate from the choice of a physical communication
protocol. Since logical ways of communicating is a distinct concern from the
transport protocol and the shape of the message, the implementations of these
two protocols should exist in separate components.</p><p><span style="font-style: italic">Running a Game</span> The tournament manager will put instances of the referee
component in charge of running games. Like the manager, the referee should inform
the players about the start of the game and the end, at least the winners of the
game. Furthermore, for the chosen game, the referee should grant players turns,
in the round-robin fashion typical for board games. Once again, this use case
calls for an extension of the logical communication protocol.</p><p><span style="font-style: italic">Communication Concerns</span> The preceding two use cases allude to the
logical ways of interaction (between the company&rsquo;s software and the players) and
remote communications. Both forms of interaction need rigorous testing before
the company runs its first tournament. Testing the logical interactions is
different from testing remote interactions; it relies on an implementation of
<span class="emph">logical players</span>, that is, players that directly interact with the game
software without going through any remote-communication protocol. This
<span class="refelem"><span class="refcolumn"><span class="refcontent">If you are unfamiliar with design patterns, check out online
resources, for example for the <a href="https://en.wikipedia.org/wiki/Proxy_pattern#Remote_proxy"><span style="font-weight: bold">remote proxy pattern</span></a>.</span></span></span>
observation exposes another oversight in the original list of components.
Performing the second kind of test demands an implementation of a bridge between
the game server and the logical player; software design principles suggest
looking into the remote proxy pattern.</p><p><span style="font-style: italic">Observing</span> Any observer will want to watch how games progress and how
the tournament progresses, two rather different forms of observation.</p><p>Watching a tournament is about observing the progress of individual players. Imagine
a knock-out tournament in which only the winner(s) of a game may move to the next
round. An observer could bet on the tournament rounds, just like people bet on
the NCAA March madness tournament or the European Champions League play-offs.</p><p>Watching a game publicly calls for visualizing the map and the acquisitions that
players make during their turns. Looking over the shoulders&rsquo; of a player should
be like watching a game but should perhaps reveal the player&rsquo;s private
knowledge.  These ideas point to yet another concern: privacy, which, to keep
things simple, is ignored here.</p><p>All these cases call for different observer components and a communication
protocol that sends information from the manager and the referees to the
respective observers. The observer components differ from each other, because
the visualization and the intended audience differ. Just as with operator
interactions, the server-observer communication protocol calls for two layers: a
logical layer and a remote layer, if the company wishes to enable observers at
distant locations.</p><p><span style="font-style: italic">Failure</span> All remote interactions between a system and its external agents
may fail. Furthermore, all logical interactions may fail due to a bug. Neither
kind of failure should bring down the entire system, unless the failure is in a
critical component, say, the sign-up server, the tournament manager, or the referee.</p><p>Failures in automated players&#8212;<wbr></wbr>an external player or one of the company&rsquo;s
&ldquo;house players&rdquo;&#8212;<wbr></wbr>are examples of non-critical failures. All player may send a
response that is illegal according to the rules of the game; human players
accuse each other of cheating in such cases. A &ldquo;house player&rdquo;&#8212;<wbr></wbr>really all
logical players&#8212;<wbr></wbr>may raise an exception or may corrupt
the referee&rsquo;s data representations, depending on the chosen programming language
and the logical communication protocol.  In the case of remote players, a
failure will take one of three forms: a lack of a timely response, an ill-formed
response, or a well-formed response that is invalid with respect to the
context.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td><ul><li><p>game server</p></li><li><p>tournament manager</p></li><li><p>player</p></li><li><p><div class="SIntrapara">player interface:
</div><div class="SIntrapara"><ul><li><p>logical</p></li><li><p>remote</p></li></ul></div></p></li><li><p>referee</p></li></ul></td><td><ul><li><p>game pieces
      <span class="hspace">&nbsp;</span>(cards, destinations,
      <span class="hspace">&nbsp;</span>connection map, rails)</p></li><li><p>game observer</p></li><li><p><div class="SIntrapara">observer interface:
</div><div class="SIntrapara"><ul><li><p>logical</p></li><li><p>remote</p></li></ul></div></p></li><li><p>failure discovery</p></li></ul></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3acomponents))" x-target-lift="Figure"></a>Figure&nbsp;14: </span>The discovered components</span></p></blockquote><p>Likewise, failures in observers should be considered non-critical. While
observers typically do not respond&#8212;<wbr></wbr>meaning the communication is basically
one-way&#8212;<wbr></wbr>it is still possible for observers to crash and close a connection; to
accidentally raise exceptions; and so on.</p><p>Since it is the manager and the referee that communicate with the automated
players and observes, it is those that must discover failures and react. The
reaction may differ from component to component, from protocol to protocol.
Given that failing player components&#8212;<wbr></wbr>external or internal&#8212;<wbr></wbr>are potentially
dangerous to the functioning of the system, one policy could be to ignore
them. By contrast, a human operator may just re-launch an observer component in
some sports bar after it has crashed and the game server could accept the
registration of this new remote observer.</p><p>The discovery of failures may call for a component in its own right or an
enrichment of the communication components. Planning the construction and
programming them will show.</p><h4 class="heading">10.4<tt>&nbsp;</tt><a name="(part._.Construction_.Plan)"></a>Construction Plan<span class="button-group"><a href="#(part._.Construction_.Plan)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The process of making a construction plan starts with a listing of all
discovered components and how they (might) depend on each other. For the second
part, it is best to draw a graph of dependencies.  This graph will then suggest
layers of the software system and thus a preliminary construction plan. Turning
these layers into an actual plan must take into account external constraints.</p><p><a href="#%28counter._%28figure._fig~3acomponents%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">14</span></a> presents the requested list of discovered components
in two columns. The entry for game pieces summarizes the need for four
components, each data-representing a piece of information that corresponds to a
physical game piece. Both the player component and the observer component
interact with the game system at two levels: one for the logical data exchange
and one for remote communication.</p><p>A close look suggests that the game-pieces components do not depend on anything
else in this list, while, for example, the game server depends on almost every
other component, directly or indirectly. Similarly, the manager must rely on the
referee component to run each of the games in a tournament, meaning the former
depends on the latter. Working through the whole list in this manner yields the
graph of <a href="#%28counter._%28figure._fig~3agame-plan%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>.</p><p>The figure also shows how this dependency graph naturally yields five layers.
Each layer&rsquo;s components depend on components in layers below but not on
components in layers above the current one. As before, an arrow points from
component <span class="RktSym">A</span><span class="RktMeta"></span> to component <span class="RktSym">B</span><span class="RktMeta"></span> means <span class="RktSym">A</span><span class="RktMeta"></span> can be developed and
compiled only if <span class="RktSym">B</span><span class="RktMeta"></span> exists&#8212;<wbr></wbr>or in terms of modules, if <span class="RktSym">A</span><span class="RktMeta"></span>
imports <span class="RktSym">B</span><span class="RktMeta"></span>. Note that even though none of the components depend on the
&ldquo;failure recovery&rdquo; component, its vertical positioning suggests that it might
be omnipresent in many of them; as indicated already, its actual existence and
dependencies are likely to be discovered during the development of the code.</p><p>Simply put, a construction plan arranges this graph in a linear order;
technically, any topologically sorted arrangement might do. If a component <span class="RktSym">A</span><span class="RktMeta"></span>
depends on <span class="RktSym">B</span><span class="RktMeta"></span>, the latter appears first in the list. Following this plan
ensures that each component is properly tested before a developer moves on to
components that depend on it. If a bug appears during the construction of a
dependent component, the likelihood is high that it is in the component under
construction, not those that already exist and are tested. Additionally, it is
possible to formulate and run preliminary integration tests that exercise the
flow of use cases from the highest layer in the graph to the bottom. Such
preliminary integration test often reveal different kinds of bugs than plain unit
tests.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="game-plan-construction.svg" alt="" width="624.03663744pt" height="343.87199999999996pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3agame-plan))" x-target-lift="Figure"></a>Figure&nbsp;15: </span>Planning the game server; its dependencies</span></p></blockquote><p>One key improvement over such a simple plan is to take into account external
constraints. Examples of important constraints are delivery speed or demo
sessions with investors, potential customers, focus groups, and so on. To pick
an example for this particular case, an investor might wish to watch an
individual game on a single computer to make sure the team is making
progress. The next logical step is to run a demo for an entire tournament, again
on a single computer. Finally, the investors will wish to see how tournaments
are run on a bunch of computers, perhaps all in a single room. Eventually the
company must also ascertain that a country-wide or world-wide distribution
satisfies basic performance criteria.</p><p>In order to reflect these external constraints, the construction will proceed in
three major phases. Each yields a prototype that illustrates progress on the
basic ideas: local games, local tournaments, and remote tournaments. Once these
goals are accomplished, the product will need performance tuning&#8212;<wbr></wbr>something
beyond the scope of a course project. Note how the first two phases are all
about the game and tournament logic, while the last one deals with
remote-communication concerns.</p><p><div class="SIntrapara"><span class="emph">Phase 1: Game Logic</span> The goal of the first phase is to build a complete,
observable game implementation. So here is the concrete plan:
</div><div class="SIntrapara"><ul><li><p>the basic game pieces</p><p>Of those, the game map is clearly the most complex piece. Both the logical
&ldquo;house&rdquo; player and the remote-connected players built by the &ldquo;hackers&rdquo; and
the company&rsquo;s testers will have to use such a component, but in different
ways. The running example demands the representation of a bidirectional graph
and certain traversal operations on this graph. Working on the remaining
components, especially the player and the referee, is likely to reveal specifics
and call for changes.</p><p>By implication, a developer has to revisit the game-map component several times
during the development of the rest the system. In terms of our
social-responsibility terminology, an older version of the developer is going to
read the code of a younger self. A &ldquo;design-it-well&rdquo; approach is going to pay
off for just one developer alone. Now imagine the departure of the original
game-map developer during phase 1 and what it takes for a different developer to
modify the implementation when it becomes clear that, for example, a player&rsquo;s
strategizing calls for more operations on the map than are available.</p></li><li><p>the logical player interface</p><p>The player interface is one of two central pieces for the company&rsquo;s goal. It
describes how the referee <span class="emph">logically</span> interacts with the automated
player, meaning it is an interface description. As such it consists of
descriptions of data that the referee delivers to players and vice versa. Since
the logical interface exists in the same programming language as the referee and
player components, it is likely to express this information in terms of
method or function signatures for classes or modules, respectively.</p><p>Inspecting the player interface in detail is critical. The clients of the
company must accept this specification as the logical interface of automated
player, and this means the clients must understand what this data means
in terms of information about the game. If there is not enough information in
the description, the clients will fail to complete games, which will
obstruct the company&rsquo;s goals.</p><p>The following sections address this issue in depth, ending in a section on how
important a precise, common vocabulary is for all parties.</p></li><li><p>the logical player and the referee</p><p>The referee and player components are independent and symmetric to the
player-interface component. In principle, different developers or even
developer teams could implement them. The player-interface component dictates
how the referee component connects with the player and how the player responds.</p></li><li><p>the observer interface and an observer</p><p>During phase 1, the observer and its interface exist so that the team can demo
the software system to people who do not appreciate a code base. Like the
player-interface component, the observer-interface dictates how the referee
component connects to observers and what the data denotes in terms of the
on-going game. It is up to the implementer of the observer component to render
this information in a meaningful and quickly comprehensible manner.</p><p>In the long term, the observer interface may play the same kind of role as the
player interface. The company may allow outsiders to implement observers,
perhaps for a fee.</p></li></ul></div><div class="SIntrapara">Keep in mind that all of these components are constructed within the same
programming language. Sticking to one language enforces a logic-of-code
perspective, ensures that the logic is correct before the challenging
remote communication is implemented, and thus facilitates the construction of
the complete system.</div></p><p><div class="SIntrapara"><span class="emph">Phase 2: Tournament Logic</span> The goal of the second phase is to construct
the tournament management system. Since this construction also involves some
amount of sophisticated logic, the development continues under the assumption
that all code is in one and the same language. In contrast to the first phase,
this one seems to involve just a single component:
</div><div class="SIntrapara"><ul><li><p>The tournament manager implements the functionality that allocates players
to games, run games using referees, promotes some players while designating some
as tournament drop-outs, and so on.</p><p>This description suggests that the team or the company must settle on the form
of tournament they wish to organize.  In the real world, tournaments often use
one of two modes: round robin, pitching every player against every other player
in some form, or a play-off format, filtering out winners in one round and
moving them to the next. Some tournaments, like the World Cup, mix the two,
starting with a round-robin format and switching to play-off style later.</p><p>In some way, this refinement implies that the analysis of this system layer is
superficial. Perhaps the tournament manager should employ auxiliary components
for allocating players and referees to games and for managing the games from the
beginning to the end.</p><p>Beyond these considerations, thinking about the tasks of the manager also
clarifies that it will have to communicate with the players directly. It may, for
example, inform the participating players that a tournament has started, that they will
participate in a particular game, or that they won the big prize. In short, the
development of the tournament manager will likely require changes to the player
interface description. As always, a well-designed interface is easier to
change than one that is ad hoc.</p></li></ul></div></p><p>As at the end of phase 2, the company might wish to demonstrate the product
again. While the tournament still runs on a single computer, an investor could
observe it&#8212;<wbr></wbr>if the team had thought of specifying a tournament-observer
interface and a rendering component.</p><p>In general, just thinking about such external constraints at this stage reveals
gaps in the analysis and the construction plan. See the next section for how
to inspect analyses and plans.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="sa-client-server-xyz.svg" alt="" width="306.20864976pt" height="110.53968768pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asa-client-server-xyz))" x-target-lift="Figure"></a>Figure&nbsp;16: </span>The logical and remove client-server architectures</span></p></blockquote><p><span class="emph">Phase 3: The Game Server</span> The goal of the third phase is to break up the
monolithic prototype into server-and-client
pieces. <a href="#%28counter._%28figure._fig~3asa-client-server-xyz%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">16</span></a> contrasts the two view. While the
left side shows the entire logical system running on a single computer&#8212;<wbr></wbr>the
bold boundary&#8212;<wbr></wbr>the right side puts the clients outside of the game-server&rsquo;s
machine box.</p><p><div class="SIntrapara">So, the goal of this last phase is to inject remote-communication capabilities
in a systematic manner:
</div><div class="SIntrapara"><ul><li><p>the remote communication interface</p><p>Just like the player-interface component, a developer must plan to write down
how external players&#8212;<wbr></wbr>clients&#8212;<wbr></wbr>communicate with the software
communicates. While the player interface dictates the logic, the remote
communication interface fixes the choice of data-exchange language and the
format of the data that is exchanged. Creating the remote interface after the
player interface has been thoroughly tested and explored <span class="emph">logically</span> also
reduces the chances that someone must work out cross-cutting fixes to all layers
later on.</p></li><li><p>the game server and the client player</p><p>Also like the referee and the player, these two pieces are independent and
symmetric. Once the remote communication interface describes how the function
and method calls of the player interface become long-distance data exchanges,
different developers should be able to create those components separately.</p><p>The server signs up clients, which implies that the remote protocol specifies
the sign-up step. When the server has signed up enough players, it can hand over
the players to the tournament manager, because running tournaments is distinct
from signing up players.</p><p>The client encapsulates a logical player component and connects it to the
server. The remote communication protocol dictates how establishing a connection
works. When the connection is established, the client code hands control to the
player.</p><p>For splitting a monolithic system into a client-server one, developers employ
the <span class="emph">remote proxy pattern</span>. In essence, the pattern explains how to
&ldquo;splice&rdquo; remote communication components between two logical components that
already exist.</p></li></ul></div><div class="SIntrapara">This last phase once again explains why it is so important to develop and test
the logic well. The developers who add the remote-communication layer do not
wish to have to &ldquo;fight&rdquo; bugs in the layers below. When bugs show up now, they
are mostly likely in the communication components, which narrows the debugging
space a lot.</div></p><p><div class="SIntrapara">We could go on with the analysis and the construction plan to add many more
details. But the existing pieces suffice to turn to the key point:
</div><div class="SIntrapara"><blockquote><p>Can the developer find problems at this stage with reviews? 
Does the early discovery of problems help?
Are all insights documented in a presentable manner?</p></blockquote></div><div class="SIntrapara">These questions are the topic of the next section, which brings us back to the
socially responsible aspects of software development.</div></p><h3 class="heading">11<tt>&nbsp;</tt><a name="(part._ch~3amanaging)"></a>Inspecting the Plan<span class="button-group"><a href="#(part._ch~3amanaging)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Between each of the three steps&#8212;<wbr></wbr>context analysis, use-case analysis, and
construction plan&#8212;<wbr></wbr>developers should take a close look at the result of the
step. While there is no code yet, it is still good practice to have a second
pair of eyes, and even a few more, inspect the analyst&rsquo;s thinking about the
project. Just because there is no code, we can still speak of &ldquo;software
inspection&rdquo;&#8212;<wbr></wbr>component identification and construction plans are a part of the
software product.</p><p>Let&rsquo;s take a look at what could happen when a planner presents the diagram of
<a href="#%28counter._%28figure._fig~3agame-plan%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a> and the construction plan to his development team.
The presenters would probably give a brief summary of the context analysis and
then move to the diagram as the result of the component discovery. Most of the
time would be spent on the construction plan, simply because the team is about
to embark on the code developing phase of the project.</p><p><div class="SIntrapara">The presenters would explain the plan as is, proceeding bottom up in terms of the
dependency diagram. While the first layer of game pieces looks
uncontroversial, inspecting the second layer&#8212;<wbr></wbr>the player interface
and the two interacting component (referee, player)&#8212;<wbr></wbr>might trigger something
like the following dialog:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> This brings us to the second layer from the bottom in our diagram  (<a href="#%28counter._%28figure._fig~3agame-plan%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>), the first interesting one. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> The one that  contains the referee, the player interface, and the player? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Yes, it describes how a player interacts with the referee. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Is it correct to  assume that the referee instructs the player to get ready for the game? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>   Indeed, we imagine that the interface will specify a method signature that  corresponds to setting up the game. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Does this mean the interface will also  specify how the referee grants the player a turn? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Correct, the referee tells a player that it is its turn and expects data that  describes what the player wants to do. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Here is what I understand now. The  &ldquo;referee&rdquo; is a component that manages a game and enforces the rules. </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>   Absolutely. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Doesn&rsquo;t this co-mingle two pieces of functionality in one  component? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  What do you mean? </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> The referee seems to be in charge of both managing the  mechanics of running a game and making sure the players play by the  rules. These could be two major, complex pieces of functionality.</p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Now that you say so I think this is right. We may be looking at a component that  is relatively large already. And even if the rules are easy to check for this  game, in the future we may deal with games that come with complex sets of  rules. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Okay. Note this as a possible gap in the construction plan. </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Agreed. Ready to move on? </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> ...</p></td></tr></table></div></p><p>Let&rsquo;s take a break here and reflect on the style and content of this dialog.</p><p>The style of the dialog illustrates egoless reviewing. Find all references to
the artifacts (plan, components) and re-read the passage. None of them use &ldquo;how
do you check the rules&rdquo; (or similar language) to discuss what the intended
software is supposed to do, what attributes it should possess. Otherwise
the participants would identify the creator and the creation, which injects
unnecessary personal attributes into the conversation.  Inspections of code or
designs are <span class="emph">not</span> about their creators, only their products. Language
reinforces this idea.</p><p>The content of this dialog is about a first planning issue. While it is clear
that the presenters and the reviewers have discovered a potential problem, think
about what kind of problem it is. For code, we think of design flaws and
bugs. For pre-code designs, it is better to think in terms of &ldquo;looking ahead&rdquo;
vs. &ldquo;needed now&rdquo; or about a component&rsquo;s size and functionality versus
functionality that is not at all allocated to a specific component. The
discovery of a possibly overly complex component is the analog of a design flaw,
and it is sometimes premature to address such issues at this stage. The
discovery of a missing functionality allocation is definitely something that the
team must incorporate into its work schedule as soon as possible.</p><p><div class="SIntrapara">The next part of the dialog is going to discover such a gap:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>... </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Can we take a closer look at the player interface? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Sure. As I said, it specifies the method signatures that a player must  implement. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> One of the methods should be about taking a turn. A player that  takes a turn must know something about other players. How does this work? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  What we have in mind is a RESTful approach. The referee sends the information a player is allowed to know about others when it&rsquo;s the player&rsquo;s turn. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Why is this? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  It makes testing the player method easy. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  ...</p></td></tr></table></div></p><p>Note how the creator of the construction plan has something specific in mind
already plus a supportive rationale. Still, this design choice deserves an
additional discussion at some point; see <a href="part_four.html#%28part._ch~3adesign-alt%29" data-pltdoc="x">Interface Inspections, Systematically</a>. For now, let&rsquo;s
resume this inspection.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>... </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> That makes sense. We could call it <span class="emph">public game state</span>. </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  That&rsquo;s a great name for it. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> But don&rsquo;t we need a component to represent this  information? While we&rsquo;re at it, doesn&rsquo;t the referee need a way to know  everything about the game state? </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Well, now that I think about it, you&rsquo;re right. Without complete knowledge, the  referee can&rsquo;t decide whether the actions a player wants to perform are legal. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Good. Let&rsquo;s take a note that the game state is a component for recording the referee&rsquo;s knowledge about the current state of the game. </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  Yes, we need that, but we also need to get players their knowledge. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> The game-state component can come with a method that extracts what a player should know for a turn. </p></td></tr><tr><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p>  I am glad we discussed this point, and I like the idea. We should record this relationship in the README file. </p></td><td valign="top" width="280" style="border-bottom: 1px solid black;; padding: 10px;"><p> Glad we discussed the plan. I&rsquo;ll take care of updating the README.</p></td></tr></table></p><p>Consider the difference between splitting off the rule checker from the referee
and not having a component for representing the state of the game at all. Both
pieces of functionality&#8212;<wbr></wbr>checking rules and dealing with the current state of
the game&#8212;<wbr></wbr>are necessary. If we assume that each component is developed by a
pair of developers, we immediately see a big difference, however. The pair
assigned to the referee is going to discover the need for checking rules. They
may decide that rule checking is simple and fits into the referee, or they may
alert the rest of the team about the need for a separate component. By contrast,
the state component isn&rsquo;t even in the graph or on the list of components
needed. The developers of the player interface are going to write signatures in
terms of the state representation but they may not immediately see that
the component is missing from the construction plan. The nature of disruption is quite
different.</p><blockquote class="Herefigure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="game-plan-fixed.svg" alt="" width="624.03663744pt" height="420.288pt"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3agame-plan-fixed))" x-target-lift="Figure"></a>Figure&nbsp;17: </span>Fixing the construction plan for the game server</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3agame-plan-fixed%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">17</span></a> displays a revision of the dependency graph in
<a href="#%28counter._%28figure._fig~3agame-plan%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>, based on the feedback from the plan inspection. The
diagram comes with a new layer for the component that represents the game
state. It is in the middle between the &ldquo;Foundation&rdquo; layer and the &ldquo;Games&rdquo;
layer. Almost all dependency lines go through this new module box, because it is
likely to depend on the entire foundation and both the referee and the logical
player component depend on it. Additionally, the referee component is modified
to indicate that it may need a separate rule checker functionality.</p><p><a name="(counter._(exercise._ex~3agame-state))"></a><span style="font-weight: bold">Exercise</span>&nbsp;5. Describe at least two methods that the game-state
component should implement: their signatures and their purpose
statements. Also describe informally how they implement the functionality.<a href="#%28counter._%28exercise._ex~3agame-state%29%29" class="ex-end" data-pltdoc="x"></a></p><p><a name="(counter._(exercise._ex~3adesign-inspection))"></a><span style="font-weight: bold">Exercise</span>&nbsp;6. Read up on the remote-proxy design pattern.
Then imagine a dialog that inspects the layer at the top of
<a href="#%28counter._%28figure._fig~3agame-plan-fixed%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a> that discovers at least one missing component.<a href="#%28counter._%28exercise._ex~3adesign-inspection%29%29" class="ex-end" data-pltdoc="x"></a></p><h3 class="heading">12<tt>&nbsp;</tt><a name="(part._ch~3awhy-design-inspection)"></a>Why Inspections Matter Even If There is No Code<span class="button-group"><a href="#(part._ch~3awhy-design-inspection)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Software development includes all steps from the initial conception to its
realization as code. This applies equally whether a team works on a brand-new
system, the repair of an old legacy system, or just the addition of a new
feature.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">In the distant past, software engineers insisted that these
products had to exist before developers started coding. They had good arguments,
but the emergence of (near) continuous software deployment has promoted agile
and extreme programming approaches. These approaches push that programming comes
first and code is the only &ldquo;thing&rdquo; that really exists.  This book is agnostic
about the two alternatives.</span></span></span></p><p><span class="emph">The Purpose</span> In all likelihood, the purpose statement for a system or a
feature and a contextual analysis is the result of a negotiation between
&ldquo;marketing&rdquo; and the leader(s) of the development team. The latter translates
the agreement into an actionable task, that is, something developers can
actually implement.  While a purpose statement should be written down and turned
into a one-line slogan, the result of a contextual analysis may exist only in
the heads of the negotiation team.</p><p>A clear purpose statement for software systems and their features, like the one
in <a href="#%28part._ch~3asample-project%29" data-pltdoc="x">A Sample Project: Analysis, Discovery, Planning</a>, helps the developer team focus. The leader and
the team members can evaluate every new feature request with respect to the
overarching purpose. If it doesn&rsquo;t (seem to) fit, the statement should help the
leader start a renegotiation process and articulate arguments in support of the
changes.</p><p>Writing down the results of a contextual analysis&#8212;<wbr></wbr>with sketches like those in
<a href="#%28counter._%28figure._fig~3asystem-boundary%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">6</span></a> and component lists like in
<a href="#%28counter._%28figure._fig~3acomponents%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a>&#8212;<wbr></wbr>helps both the current team and future
maintainers. The discovered constraints and contextual peculiarities (may) help
explain the organization of the system and particularly intricate pieces of
code. The description is also going to help with planning future extensions and
adaptations of the system.</p><p><span class="emph">The Plan</span> A dependency diagram&#8212;<wbr></wbr>or a set of dependency descriptions&#8212;<wbr></wbr>is
equally likely to be needed, and hopefully created, up front or during the
coding process, when a first draft of the (essential) software has been
developed. In either case, it needs adaptation as inspections uncover flaws and
additional coding change the relationships or create new ones. If a team dives
into coding without a dependency diagram, it should develop one as soon as any
of its members expresses concerns about any relationship between components
during a meeting or inspection.</p><p>Every new team member is going to welcome a dependency diagram. Imagine yourself
joining a team, being assigned a feature ticket, and staring at dozens of files
and modules in the code base. Where to begin. A dependency diagram, such as the
one in <a href="#%28counter._%28figure._fig~3agame-plan%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>, will greatly facilitate the navigation of the
code. If the components come with short purpose statements, a new team member can
quickly hone in on the places where code has to be adapted or added. By using
the relationships, a maintainer can also inspect functionality in use contexts,
which may explain oddities in the implementations of some piece of
functionality.</p><h4 class="heading">12.1<tt>&nbsp;</tt><a name="(part._sec~3adocuments)"></a>Documents: Start the README, Before the Coding Begins<span class="button-group"><a href="#(part._sec~3adocuments)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">At this point, the developer team has a good understanding of the basic project
parameters:
</div><div class="SIntrapara"><ul><li><p>its purpose and its context;</p></li><li><p>its major components plus their dependencies; and</p></li><li><p>a plan for building these components and its major stages.</p></li></ul></div><div class="SIntrapara">Someone should record this understanding in some way.</div></p><p>These steps may have taken place in informal manner, with conversations near
white boards in a meeting room, using napkins in a coffee shop, or some other
form like that. In some settings&#8212;<wbr></wbr>say a safety-critical project concerning a
nuclear reactor&#8212;<wbr></wbr>someone will be asked to turn those discussions into formal
documents. In other settings&#8212;<wbr></wbr>a start-up whose founders are impatiently waiting
for code so that they can run demos&#8212;<wbr></wbr>nobody may wish to take the time. But even
in these latter settings, someone should preserve whatever was written down. At
a minimum, someone should take pictures with a cell phone and collect those in a
project repository. Getting started with the README is the hard part, but it is
critical to make the development socially responsible.</p><p>Once the repository is created, it makes sense to add a document that guides
future readers through its files. In many cases, people call this document a</p><blockquote class="SCentered"><p>README file</p></blockquote><p>and the joke is that this file is the best place to hide secrets.  The
problem with such read-me files is that they are often an after-thought. Someone
may remember late in the creation process that such a document should exist, and
it is compiled in a rushed manner, yielding an incomplete and possibly
uninformative content. If such a file is created at the very beginning, is
thought of as a guide to the project, and is updated regularly, it may just help
future maintainers understand the big picture behind the project, its pieces, and
their relationships.</p><p>Once someone has performed a context analysis, identified components, created a
construction plan, and documented this all in a README file (or several), it is
time to tackle what most developers think is the key task&#8212;<wbr></wbr>coding&#8212;<wbr></wbr>but which
we now understand is just a part of the overall software product and the
software development process.</p><p><a name="(counter._(exercise._ex~3areadme))"></a><span style="font-weight: bold">Exercise</span>&nbsp;7. Distill the sample project from the preceding section
into a README file. It is okay to take pictures of the diagram in this book, but
use your own words to describe what&rsquo;s going on.<a href="#%28counter._%28exercise._ex~3areadme%29%29" class="ex-end" data-pltdoc="x"></a></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="part_two.html" title="backward to &quot;II Principles&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Socially Responsible  Software Development&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="part_four.html" title="forward to &quot;IV Programming Interfaces&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>